import { createElement } from 'react';
import { BaseWidget, OpType } from '@blink-mind/renderer-react';
import styled from 'styled-components';
import RichMarkDownEditor from 'awehook-rich-markdown-editor';
import debug from 'debug';
import { BlockType } from '@blink-mind/core';
import MarkdownSerializer from 'slate-md-serializer';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}

var log = debug('node:topic-content-editor');
var NodeContent = styled.div(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  padding: 6px;\n  background-color: ", ";\n  cursor: ", ";\n"], ["\n  padding: 6px;\n  background-color: ", ";\n  cursor: ", ";\n"])), function (props) { return (props.readOnly ? null : 'white'); }, function (props) { return (props.readOnly ? 'pointer' : 'text'); });
var RichTextEditor = /** @class */ (function (_super) {
    __extends(RichTextEditor, _super);
    function RichTextEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.onMouseDown = function (e) {
            e.stopPropagation();
        };
        _this.onMouseMove = function (e) {
            e.stopPropagation();
        };
        _this.onChange = function (value) { };
        _this.getCustomizeProps = function () {
            return null;
        };
        return _this;
    }
    RichTextEditor.prototype.render = function () {
        var _a = this.props, topicKey = _a.topicKey, saveRef = _a.saveRef;
        var _b = this.getCustomizeProps(), block = _b.block, readOnly = _b.readOnly, refKeyPrefix = _b.refKeyPrefix;
        var content = block.data;
        if (content == null)
            return null;
        var key = refKeyPrefix + "-" + topicKey;
        return (createElement(NodeContent, { key: key, readOnly: readOnly, ref: saveRef(key), onMouseDown: this.onMouseDown, onMouseMove: this.onMouseMove },
            createElement(RichMarkDownEditor, { editorValue: content, readOnly: readOnly, onChange: this.onChange })));
    };
    return RichTextEditor;
}(BaseWidget));
var templateObject_1;

var TopicContentEditor = /** @class */ (function (_super) {
    __extends(TopicContentEditor, _super);
    function TopicContentEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getCustomizeProps = function () {
            var _a = _this.props, model = _a.model, topicKey = _a.topicKey;
            var block = model.getTopic(topicKey).getBlock(BlockType.CONTENT).block;
            var readOnly = model.editingContentKey !== topicKey;
            var refKeyPrefix = 'content-editor';
            return {
                block: block,
                readOnly: readOnly,
                refKeyPrefix: refKeyPrefix
            };
        };
        _this.onChange = function (value) {
            _this.operation(OpType.SET_TOPIC_CONTENT, __assign(__assign({}, _this.props), { content: value }));
        };
        return _this;
    }
    return TopicContentEditor;
}(RichTextEditor));

var TopicDescEditor = /** @class */ (function (_super) {
    __extends(TopicDescEditor, _super);
    function TopicDescEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.getCustomizeProps = function () {
            var _a = _this.props, model = _a.model, topicKey = _a.topicKey;
            var block = model.getTopic(topicKey).getBlock(BlockType.DESC).block;
            var readOnly = model.editingDescKey !== topicKey;
            var refKeyPrefix = 'desc-editor';
            return {
                block: block,
                readOnly: readOnly,
                refKeyPrefix: refKeyPrefix
            };
        };
        _this.onChange = function (value) {
            _this.operation(OpType.SET_TOPIC_DESC, __assign(__assign({}, _this.props), { desc: value }));
        };
        return _this;
    }
    return TopicDescEditor;
}(RichTextEditor));

var markdownSerializer = new MarkdownSerializer();

function RichTextEditorPlugin() {
    return {
        renderTopicContentEditor: function (props) {
            return createElement(TopicContentEditor, __assign({}, props));
        },
        renderTopicDescEditor: function (props) {
            return createElement(TopicDescEditor, __assign({}, props));
        },
        serializeBlock: function (props, next) {
            var block = props.block;
            if (block.type === BlockType.CONTENT || block.type === BlockType.DESC) {
                var res = {
                    type: block.type,
                    data: typeof block.data === 'string'
                        ? block.data
                        : markdownSerializer.serialize(block.data)
                };
                return res;
            }
            return next();
        },
        deserializeBlock: function (props, next) {
            return next();
        }
    };
}

export default RichTextEditorPlugin;
//# sourceMappingURL=main.es.js.map
