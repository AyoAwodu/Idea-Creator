{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = MarkdownShortcuts;\n\nvar _slate = require(\"slate\");\n\nvar inlineShortcuts = [{\n  mark: \"bold\",\n  shortcut: \"**\"\n}, {\n  mark: \"bold\",\n  shortcut: \"__\"\n}, {\n  mark: \"italic\",\n  shortcut: \"*\"\n}, {\n  mark: \"italic\",\n  shortcut: \"_\"\n}, {\n  mark: \"code\",\n  shortcut: \"`\"\n}, {\n  mark: \"inserted\",\n  shortcut: \"++\"\n}, {\n  mark: \"deleted\",\n  shortcut: \"~~\"\n}];\n\nfunction MarkdownShortcuts() {\n  function onKeyDown(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock;\n    if (!startBlock) return next(); // markdown shortcuts should not be parsed in code\n\n    if (startBlock.type.match(/code/)) return next();\n\n    switch (ev.key) {\n      case \"-\":\n        return onDash(ev, editor, next);\n\n      case \"`\":\n        return onBacktick(ev, editor, next);\n\n      case \" \":\n        return onSpace(ev, editor, next);\n\n      default:\n        return next();\n    }\n  }\n  /**\n   * On space, if it was after an auto-markdown shortcut, convert the current\n   * node into the shortcut's corresponding type.\n   */\n\n\n  function onSpace(ev, editor, next) {\n    var value = editor.value;\n    var selection = value.selection,\n        startBlock = value.startBlock;\n    if (selection.isExpanded) return next();\n    var chars = startBlock.text.slice(0, selection.start.offset).trim();\n    var type = getType(chars);\n\n    if (type && !editor.isSelectionInTable()) {\n      // only shortcuts to change heading size should work in headings\n      if (startBlock.type.match(/heading/) && !type.match(/heading/)) {\n        return next();\n      } // don't allow doubling up a list item\n\n\n      if (type === \"list-item\" && startBlock.type === \"list-item\") {\n        return next();\n      }\n\n      ev.preventDefault();\n      var checked = void 0;\n      if (chars === \"[x]\") checked = true;\n      if (chars === \"[ ]\") checked = false;\n      editor.withoutNormalizing(function (c) {\n        c.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n          type: type,\n          data: {\n            checked: checked\n          }\n        });\n\n        if (type === \"list-item\") {\n          if (checked !== undefined) {\n            return c.wrapBlock(\"todo-list\");\n          } else if (chars === \"1.\") {\n            return c.wrapBlock(\"ordered-list\");\n          } else {\n            return c.wrapBlock(\"bulleted-list\");\n          }\n        }\n\n        return next();\n      });\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = inlineShortcuts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value; // find all inline characters\n\n        var mark = key.mark,\n            shortcut = key.shortcut;\n        var inlineTags = []; // only add tags if they have spaces around them or the tag is beginning\n        // or the end of the block\n\n        for (var i = 0; i < startBlock.text.length; i++) {\n          var text = startBlock.text;\n          var start = i;\n          var end = i + shortcut.length;\n          var beginningOfBlock = start === 0;\n          var endOfBlock = end === text.length;\n          var surroundedByWhitespaces = [text.slice(start - 1, start), text.slice(end, end + 1)].includes(\" \");\n\n          if (text.slice(start, end) === shortcut && (beginningOfBlock || endOfBlock || surroundedByWhitespaces)) {\n            inlineTags.push(i);\n          }\n        } // if we have multiple tags then mark the text between\n\n\n        if (inlineTags.length > 1) {\n          var firstText = startBlock.getFirstText();\n          var firstCodeTagIndex = inlineTags[0];\n          var lastCodeTagIndex = inlineTags[inlineTags.length - 1];\n          return editor.removeTextByKey(firstText.key, lastCodeTagIndex, shortcut.length).removeTextByKey(firstText.key, firstCodeTagIndex, shortcut.length).moveAnchorTo(firstCodeTagIndex, lastCodeTagIndex - shortcut.length).addMark(mark).moveToEnd().removeMark(mark);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return next();\n  }\n\n  function onDash(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock,\n        selection = value.selection;\n    if (selection.isExpanded) return next();\n    if (startBlock.type.match(/heading/)) return next();\n    if (editor.isSelectionInTable()) return next();\n    var chars = startBlock.text.slice(0, selection.start.offset).replace(/\\s*/g, \"\");\n\n    if (chars === \"--\") {\n      ev.preventDefault();\n      return editor.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n        type: \"horizontal-rule\",\n        isVoid: true\n      }, {\n        normalize: false\n      }).insertBlock(\"paragraph\").moveToStart();\n    }\n\n    return next();\n  }\n\n  function onBacktick(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock,\n        selection = value.selection;\n    if (selection.isExpanded) return next();\n    if (startBlock.type.match(/heading/)) return next();\n    var chars = startBlock.text.slice(0, selection.start.offset).replace(/\\s*/g, \"\");\n\n    if (chars === \"``\") {\n      ev.preventDefault();\n      return editor.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n        type: \"code\"\n      });\n    }\n\n    return next();\n  }\n  /**\n   * Get the block type for a series of auto-markdown shortcut `chars`.\n   */\n\n\n  function getType(chars) {\n    switch (chars) {\n      case \"*\":\n      case \"-\":\n      case \"+\":\n      case \"1.\":\n      case \"[ ]\":\n      case \"[x]\":\n        return \"list-item\";\n\n      case \">\":\n        return \"block-quote\";\n\n      case \"#\":\n        return \"heading1\";\n\n      case \"##\":\n        return \"heading2\";\n\n      case \"###\":\n        return \"heading3\";\n\n      case \"####\":\n        return \"heading4\";\n\n      case \"#####\":\n        return \"heading5\";\n\n      case \"######\":\n        return \"heading6\";\n\n      default:\n        return null;\n    }\n  }\n\n  return {\n    onKeyDown: onKeyDown\n  };\n}","map":{"version":3,"sources":["C:/Users/ayomi/Source/Repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/awehook-rich-markdown-editor/lib/plugins/MarkdownShortcuts.js"],"names":["Object","defineProperty","exports","value","default","MarkdownShortcuts","_slate","require","inlineShortcuts","mark","shortcut","onKeyDown","ev","editor","next","startBlock","type","match","key","onDash","onBacktick","onSpace","selection","isExpanded","chars","text","slice","start","offset","trim","getType","isSelectionInTable","preventDefault","checked","withoutNormalizing","c","moveFocusToStartOfNode","delete","setBlocks","data","undefined","wrapBlock","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","Symbol","iterator","_step","done","inlineTags","i","length","end","beginningOfBlock","endOfBlock","surroundedByWhitespaces","includes","push","firstText","getFirstText","firstCodeTagIndex","lastCodeTagIndex","removeTextByKey","moveAnchorTo","addMark","moveToEnd","removeMark","err","return","replace","isVoid","normalize","insertBlock","moveToStart"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = MarkdownShortcuts;\n\nvar _slate = require(\"slate\");\n\nvar inlineShortcuts = [{ mark: \"bold\", shortcut: \"**\" }, { mark: \"bold\", shortcut: \"__\" }, { mark: \"italic\", shortcut: \"*\" }, { mark: \"italic\", shortcut: \"_\" }, { mark: \"code\", shortcut: \"`\" }, { mark: \"inserted\", shortcut: \"++\" }, { mark: \"deleted\", shortcut: \"~~\" }];\nfunction MarkdownShortcuts() {\n  function onKeyDown(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock;\n\n    if (!startBlock) return next();\n\n    // markdown shortcuts should not be parsed in code\n    if (startBlock.type.match(/code/)) return next();\n\n    switch (ev.key) {\n      case \"-\":\n        return onDash(ev, editor, next);\n      case \"`\":\n        return onBacktick(ev, editor, next);\n      case \" \":\n        return onSpace(ev, editor, next);\n      default:\n        return next();\n    }\n  }\n\n  /**\n   * On space, if it was after an auto-markdown shortcut, convert the current\n   * node into the shortcut's corresponding type.\n   */\n  function onSpace(ev, editor, next) {\n    var value = editor.value;\n    var selection = value.selection,\n        startBlock = value.startBlock;\n\n    if (selection.isExpanded) return next();\n\n    var chars = startBlock.text.slice(0, selection.start.offset).trim();\n    var type = getType(chars);\n\n    if (type && !editor.isSelectionInTable()) {\n      // only shortcuts to change heading size should work in headings\n      if (startBlock.type.match(/heading/) && !type.match(/heading/)) {\n        return next();\n      }\n\n      // don't allow doubling up a list item\n      if (type === \"list-item\" && startBlock.type === \"list-item\") {\n        return next();\n      }\n      ev.preventDefault();\n\n      var checked = void 0;\n      if (chars === \"[x]\") checked = true;\n      if (chars === \"[ ]\") checked = false;\n\n      editor.withoutNormalizing(function (c) {\n        c.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n          type: type,\n          data: { checked: checked }\n        });\n\n        if (type === \"list-item\") {\n          if (checked !== undefined) {\n            return c.wrapBlock(\"todo-list\");\n          } else if (chars === \"1.\") {\n            return c.wrapBlock(\"ordered-list\");\n          } else {\n            return c.wrapBlock(\"bulleted-list\");\n          }\n        }\n\n        return next();\n      });\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = inlineShortcuts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var key = _step.value;\n\n        // find all inline characters\n        var mark = key.mark,\n            shortcut = key.shortcut;\n\n        var inlineTags = [];\n\n        // only add tags if they have spaces around them or the tag is beginning\n        // or the end of the block\n        for (var i = 0; i < startBlock.text.length; i++) {\n          var text = startBlock.text;\n\n          var start = i;\n          var end = i + shortcut.length;\n          var beginningOfBlock = start === 0;\n          var endOfBlock = end === text.length;\n          var surroundedByWhitespaces = [text.slice(start - 1, start), text.slice(end, end + 1)].includes(\" \");\n\n          if (text.slice(start, end) === shortcut && (beginningOfBlock || endOfBlock || surroundedByWhitespaces)) {\n            inlineTags.push(i);\n          }\n        }\n\n        // if we have multiple tags then mark the text between\n        if (inlineTags.length > 1) {\n          var firstText = startBlock.getFirstText();\n          var firstCodeTagIndex = inlineTags[0];\n          var lastCodeTagIndex = inlineTags[inlineTags.length - 1];\n          return editor.removeTextByKey(firstText.key, lastCodeTagIndex, shortcut.length).removeTextByKey(firstText.key, firstCodeTagIndex, shortcut.length).moveAnchorTo(firstCodeTagIndex, lastCodeTagIndex - shortcut.length).addMark(mark).moveToEnd().removeMark(mark);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return next();\n  }\n\n  function onDash(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock,\n        selection = value.selection;\n\n    if (selection.isExpanded) return next();\n\n    if (startBlock.type.match(/heading/)) return next();\n    if (editor.isSelectionInTable()) return next();\n\n    var chars = startBlock.text.slice(0, selection.start.offset).replace(/\\s*/g, \"\");\n\n    if (chars === \"--\") {\n      ev.preventDefault();\n      return editor.moveFocusToStartOfNode(startBlock).delete().setBlocks({\n        type: \"horizontal-rule\",\n        isVoid: true\n      }, { normalize: false }).insertBlock(\"paragraph\").moveToStart();\n    }\n\n    return next();\n  }\n\n  function onBacktick(ev, editor, next) {\n    var value = editor.value;\n    var startBlock = value.startBlock,\n        selection = value.selection;\n\n    if (selection.isExpanded) return next();\n    if (startBlock.type.match(/heading/)) return next();\n\n    var chars = startBlock.text.slice(0, selection.start.offset).replace(/\\s*/g, \"\");\n\n    if (chars === \"``\") {\n      ev.preventDefault();\n      return editor.moveFocusToStartOfNode(startBlock).delete().setBlocks({ type: \"code\" });\n    }\n\n    return next();\n  }\n\n  /**\n   * Get the block type for a series of auto-markdown shortcut `chars`.\n   */\n  function getType(chars) {\n    switch (chars) {\n      case \"*\":\n      case \"-\":\n      case \"+\":\n      case \"1.\":\n      case \"[ ]\":\n      case \"[x]\":\n        return \"list-item\";\n      case \">\":\n        return \"block-quote\";\n      case \"#\":\n        return \"heading1\";\n      case \"##\":\n        return \"heading2\";\n      case \"###\":\n        return \"heading3\";\n      case \"####\":\n        return \"heading4\";\n      case \"#####\":\n        return \"heading5\";\n      case \"######\":\n        return \"heading6\";\n      default:\n        return null;\n    }\n  }\n\n  return { onKeyDown: onKeyDown };\n}"]},"metadata":{},"sourceType":"script"}