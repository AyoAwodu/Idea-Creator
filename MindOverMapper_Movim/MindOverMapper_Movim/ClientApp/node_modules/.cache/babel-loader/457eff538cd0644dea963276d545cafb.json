{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _utils = require('../utils');\n/**\n * Increase the depth of the current item by putting it in a sub-list\n * of previous item.\n * For first items in a list, does nothing.\n */\n\n\nfunction increaseItemDepth(opts, change) {\n  var previousItem = (0, _utils.getPreviousItem)(opts, change.value);\n  var currentItem = (0, _utils.getCurrentItem)(opts, change.value);\n  var maxDepth = opts.maxDepth * 2;\n\n  if (!previousItem) {\n    return change;\n  }\n\n  if (!currentItem) {\n    return change;\n  } // Get the depth of the focused list item.\n\n\n  var currentItemDepth = change.value.document.getDepth(currentItem.key); // Make sure the level of the focused item is below the defined maximum.\n\n  if (currentItemDepth >= maxDepth) {\n    return change;\n  } // Get the depth of the deepest `li` descendant of the focused item.\n\n\n  var deepestItemDepth = (0, _utils.getDeepestItemDepth)(currentItem, change.value.document); // This prevents from indenting parents of too deeply nested list items.\n\n  if (deepestItemDepth >= maxDepth) {\n    return change;\n  } // Move the item in the sublist of previous item\n\n\n  return moveAsSubItem(opts, change, currentItem, previousItem.key);\n}\n/**\n * Move the given item to the sublist at the end of destination item,\n * creating a sublist if needed.\n */\n\n\nfunction moveAsSubItem(opts, change, // The list item to add\nitem, // The key of the destination node\ndestKey) {\n  var destination = change.value.document.getDescendant(destKey);\n  var lastIndex = destination.nodes.size;\n  var lastChild = destination.nodes.last(); // The potential existing last child list\n\n  var existingList = (0, _utils.isList)(opts, lastChild) ? lastChild : null;\n\n  if (existingList) {\n    return change.moveNodeByKey(item.key, existingList.key, existingList.nodes.size // as last item\n    );\n  }\n\n  var currentList = (0, _utils.getListForItem)(opts, change.value, destination);\n\n  if (!currentList) {\n    throw new Error('Destination is not in a list');\n  } // Creating empty list creates also empty list item - placeholder item is meant to be easily deleted in the end\n\n\n  var tmpBlock = _slate.Block.create({\n    object: 'block',\n    type: opts.typeItem\n  }); // @TODO Why does empty list contain empty item?\n\n\n  var newSublist = _slate.Block.create({\n    object: 'block',\n    type: currentList.type,\n    data: currentList.data,\n    nodes: [tmpBlock]\n  });\n\n  change.withoutNormalizing(function () {\n    change.insertNodeByKey(destKey, lastIndex, newSublist);\n  });\n  change.moveNodeByKey(item.key, newSublist.key, 0);\n  change.removeNodeByKey(tmpBlock.key);\n  return change;\n}\n\nexports.default = increaseItemDepth;","map":{"version":3,"sources":["C:/Users/ayomi/Source/Repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/@tommoor/slate-edit-list/dist/changes/increaseItemDepth.js"],"names":["Object","defineProperty","exports","value","_slate","require","_utils","increaseItemDepth","opts","change","previousItem","getPreviousItem","currentItem","getCurrentItem","maxDepth","currentItemDepth","document","getDepth","key","deepestItemDepth","getDeepestItemDepth","moveAsSubItem","item","destKey","destination","getDescendant","lastIndex","nodes","size","lastChild","last","existingList","isList","moveNodeByKey","currentList","getListForItem","Error","tmpBlock","Block","create","object","type","typeItem","newSublist","data","withoutNormalizing","insertNodeByKey","removeNodeByKey","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slate = require('slate');\n\nvar _utils = require('../utils');\n\n/**\n * Increase the depth of the current item by putting it in a sub-list\n * of previous item.\n * For first items in a list, does nothing.\n */\nfunction increaseItemDepth(opts, change) {\n    var previousItem = (0, _utils.getPreviousItem)(opts, change.value);\n    var currentItem = (0, _utils.getCurrentItem)(opts, change.value);\n    var maxDepth = opts.maxDepth * 2;\n\n    if (!previousItem) {\n        return change;\n    }\n\n    if (!currentItem) {\n        return change;\n    }\n\n    // Get the depth of the focused list item.\n    var currentItemDepth = change.value.document.getDepth(currentItem.key);\n\n    // Make sure the level of the focused item is below the defined maximum.\n    if (currentItemDepth >= maxDepth) {\n        return change;\n    }\n\n    // Get the depth of the deepest `li` descendant of the focused item.\n    var deepestItemDepth = (0, _utils.getDeepestItemDepth)(currentItem, change.value.document);\n\n    // This prevents from indenting parents of too deeply nested list items.\n    if (deepestItemDepth >= maxDepth) {\n        return change;\n    }\n\n    // Move the item in the sublist of previous item\n    return moveAsSubItem(opts, change, currentItem, previousItem.key);\n}\n\n/**\n * Move the given item to the sublist at the end of destination item,\n * creating a sublist if needed.\n */\nfunction moveAsSubItem(opts, change,\n// The list item to add\nitem,\n// The key of the destination node\ndestKey) {\n    var destination = change.value.document.getDescendant(destKey);\n    var lastIndex = destination.nodes.size;\n    var lastChild = destination.nodes.last();\n\n    // The potential existing last child list\n    var existingList = (0, _utils.isList)(opts, lastChild) ? lastChild : null;\n\n    if (existingList) {\n        return change.moveNodeByKey(item.key, existingList.key, existingList.nodes.size // as last item\n        );\n    }\n    var currentList = (0, _utils.getListForItem)(opts, change.value, destination);\n    if (!currentList) {\n        throw new Error('Destination is not in a list');\n    }\n\n    // Creating empty list creates also empty list item - placeholder item is meant to be easily deleted in the end\n    var tmpBlock = _slate.Block.create({\n        object: 'block',\n        type: opts.typeItem\n    });\n\n    // @TODO Why does empty list contain empty item?\n    var newSublist = _slate.Block.create({\n        object: 'block',\n        type: currentList.type,\n        data: currentList.data,\n        nodes: [tmpBlock]\n    });\n\n    change.withoutNormalizing(function () {\n        change.insertNodeByKey(destKey, lastIndex, newSublist);\n    });\n\n    change.moveNodeByKey(item.key, newSublist.key, 0);\n    change.removeNodeByKey(tmpBlock.key);\n\n    return change;\n}\n\nexports.default = increaseItemDepth;"]},"metadata":{},"sourceType":"script"}