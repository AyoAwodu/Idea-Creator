{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _slateSchemaViolations = require('slate-schema-violations');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Create a schema definition with rules to normalize blockquotes\n */\n\n\nfunction schema(opts) {\n  return {\n    blocks: _defineProperty({}, opts.type, {\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code;\n\n        switch (code) {\n          case _slateSchemaViolations.CHILD_OBJECT_INVALID:\n            return containBlocks(opts, editor, error);\n\n          default:\n            return undefined;\n        }\n      }\n    })\n  };\n}\n/**\n *  Ensures that blockquotes always contain blocks.\n */\n\n\nfunction containBlocks(opts, editor, error) {\n  var toWrap = error.node.nodes.filter(function (n) {\n    return n.object !== 'block';\n  });\n\n  if (toWrap.isEmpty()) {\n    return undefined;\n  } // Wrap text/inline nodes in default block\n\n\n  var wrapper = _slate.Block.create({\n    type: opts.typeDefault,\n    nodes: []\n  }); // Be careful of Slate's core schema removing inlines or blocks when\n  // a block contains a mix of them.\n\n\n  editor.withoutNormalizing(function () {\n    editor.insertNodeByKey(error.node.key, 0, wrapper);\n  });\n  toWrap.forEach(function (child, index) {\n    var isLast = index === toWrap.size - 1;\n\n    if (isLast) {\n      editor.moveNodeByKey(child.key, wrapper.key, index);\n    } else {\n      editor.withoutNormalizing(function () {\n        editor.moveNodeByKey(child.key, wrapper.key, index);\n      });\n    }\n  });\n  return editor;\n}\n\nexports.default = schema;","map":{"version":3,"sources":["C:/Users/ayomi/Source/Repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/@wikifactory/slate-edit-blockquote/dist/validation/schema.js"],"names":["Object","defineProperty","exports","value","_slate","require","_slateSchemaViolations","_defineProperty","obj","key","enumerable","configurable","writable","schema","opts","blocks","type","nodes","match","object","normalize","editor","error","code","CHILD_OBJECT_INVALID","containBlocks","undefined","toWrap","node","filter","n","isEmpty","wrapper","Block","create","typeDefault","withoutNormalizing","insertNodeByKey","forEach","child","index","isLast","size","moveNodeByKey","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slate = require('slate');\n\nvar _slateSchemaViolations = require('slate-schema-violations');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Create a schema definition with rules to normalize blockquotes\n */\nfunction schema(opts) {\n    return {\n        blocks: _defineProperty({}, opts.type, {\n            nodes: [{\n                match: { object: 'block' }\n            }],\n            normalize: function normalize(editor, error) {\n                var code = error.code;\n\n                switch (code) {\n                    case _slateSchemaViolations.CHILD_OBJECT_INVALID:\n                        return containBlocks(opts, editor, error);\n                    default:\n                        return undefined;\n                }\n            }\n        })\n    };\n}\n\n/**\n *  Ensures that blockquotes always contain blocks.\n */\nfunction containBlocks(opts, editor, error) {\n    var toWrap = error.node.nodes.filter(function (n) {\n        return n.object !== 'block';\n    });\n\n    if (toWrap.isEmpty()) {\n        return undefined;\n    }\n\n    // Wrap text/inline nodes in default block\n    var wrapper = _slate.Block.create({\n        type: opts.typeDefault,\n        nodes: []\n    });\n\n    // Be careful of Slate's core schema removing inlines or blocks when\n    // a block contains a mix of them.\n    editor.withoutNormalizing(function () {\n        editor.insertNodeByKey(error.node.key, 0, wrapper);\n    });\n\n    toWrap.forEach(function (child, index) {\n        var isLast = index === toWrap.size - 1;\n        if (isLast) {\n            editor.moveNodeByKey(child.key, wrapper.key, index);\n        } else {\n            editor.withoutNormalizing(function () {\n                editor.moveNodeByKey(child.key, wrapper.key, index);\n            });\n        }\n    });\n\n    return editor;\n}\n\nexports.default = schema;"]},"metadata":{},"sourceType":"script"}