{"ast":null,"code":"import React from 'react';\nvar isProduction = \"development\" === 'production';\nvar prefix = 'Invariant failed';\n\nvar index = function (condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/*\n * Instance counter to enable unique marks for multiple Placeholder instances.\n */\n\n\nvar instanceCounter = 0;\n/**\n * A plugin that renders a React placeholder for a given Slate node.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction SlateReactPlaceholder() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var instanceId = instanceCounter++;\n  var placeholderMark = {\n    type: 'placeholder',\n    data: {\n      key: instanceId\n    }\n  };\n  var placeholder = options.placeholder,\n      when = options.when,\n      _options$style = options.style,\n      style = _options$style === undefined ? {} : _options$style;\n  index(placeholder, 'You must pass `SlateReactPlaceholder` an `options.placeholder` string.');\n  index(when, 'You must pass `SlateReactPlaceholder` an `options.when` query.');\n  /**\n   * Decorate a match node with a placeholder mark when it fits the query.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    if (!editor.query(when, node)) {\n      return next();\n    }\n\n    var others = next();\n    var document = editor.value.document;\n    var first = node.getFirstText();\n    var last = node.getLastText();\n    var decoration = {\n      anchor: {\n        key: first.key,\n        offset: 0,\n        path: document.getPath(first.key)\n      },\n      focus: {\n        key: last.key,\n        offset: last.text.length,\n        path: document.getPath(last.key)\n      },\n      mark: placeholderMark\n    };\n    return [].concat(toConsumableArray(others), [decoration]);\n  }\n  /**\n   * Render an inline placeholder for the placeholder mark.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n\n  function renderMark(props, editor, next) {\n    var children = props.children,\n        mark = props.mark;\n\n    if (mark.type === 'placeholder' && mark.data.get('key') === instanceId) {\n      var placeHolderStyle = _extends({\n        pointerEvents: 'none',\n        display: 'inline-block',\n        width: '0',\n        maxWidth: '100%',\n        whiteSpace: 'nowrap',\n        opacity: '0.333'\n      }, style);\n\n      return React.createElement('span', null, React.createElement('span', {\n        contentEditable: false,\n        style: placeHolderStyle\n      }, placeholder), children);\n    }\n\n    return next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @return {Object}\n   */\n\n\n  return {\n    decorateNode: decorateNode,\n    renderMark: renderMark\n  };\n}\n\nexport default SlateReactPlaceholder;","map":{"version":3,"sources":["../../../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../src/index.js"],"names":["instanceCounter","options","instanceId","placeholderMark","key","placeholder","when","style","editor","next","others","document","first","node","last","decoration","offset","path","children","mark","props","placeHolderStyle","decorateNode","renderMark"],"mappings":";AAAA,IAAI,YAAY,GAAG,kBAAyB,YAA5C;AACA,IAAI,MAAM,GAAG,kBAAb;;AACA,IAAI,KAAK,GAAI,UAAU,SAAV,EAAqB,OAArB,EAA8B;AACzC,MAAI,SAAJ,EAAe;AACb;AACD;;AAED,MAAI,YAAJ,EAAkB;AAChB,UAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACD,GAFD,MAEO;AACL,UAAM,IAAI,KAAJ,CAAU,MAAM,GAAG,IAAT,IAAiB,OAAO,IAAI,EAA5B,CAAV,CAAN;AACD;AACF,CAVD;;;;;;;;;;;;;;;;;;;;;;;;;ACCA;;;;;AAIA,IAAIA,eAAAA,GAAJ,CAAA;;;;;;;;AASA,SAAA,qBAAA,GAA6C;MAAdC,OAAc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,E;MACjCC,UAAAA,GAAaF,eAAnB,E;MACMG,eAAAA,GAAkB;UAAA,aAAA;UAEhB;AAAEC,MAAAA,GAAAA,EAAF;AAAA;AAFgB,G;MAKhBC,WAPmC,GAODJ,OAPC,CAAA,W;MAOtBK,IAPsB,GAODL,OAPC,CAAA,I;uBAODA,OAPC,CAAA,K;MAOhBM,KAPgB,GAAA,cAAA,KAAA,SAAA,GAAA,EAAA,GAAA,c;QAS3C,W,EAAA,wE;QAKA,I,EAAA,gE;;;;;;;;;;WAcA,Y,CAAA,I,EAAA,M,EAAA,I,EAA0C;QACpC,CAACC,MAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAL,IAAKA,C,EAA0B;aACtBC,IAAP,E;;;QAGIC,MAAAA,GAASD,IAAf,E;QACME,QAAAA,GAAWH,MAAAA,CAAAA,KAAAA,CAAjB,Q;QACMI,KAAAA,GAAQC,IAAAA,CAAd,YAAcA,E;QACRC,IAAAA,GAAOD,IAAAA,CAAb,WAAaA,E;QACPE,UAAAA,GAAa;cACT;AAAEX,QAAAA,GAAAA,EAAKQ,KAAAA,CAAP,GAAA;AAAkBI,QAAAA,MAAAA,EAAlB,CAAA;AAA6BC,QAAAA,IAAAA,EAAMN,QAAAA,CAAAA,OAAAA,CAAiBC,KAAAA,CAD3C,GAC0BD;AAAnC,OADS;aAEV;aACAG,IAAAA,CADA,GAAA;gBAEGA,IAAAA,CAAAA,IAAAA,CAFH,MAAA;cAGCH,QAAAA,CAAAA,OAAAA,CAAiBG,IAAAA,CAAjBH,GAAAA;AAHD,OAFU;YAOXR;AAPW,K;uCAUnB,M,GAAA,CAAA,UAAA,C;;;;;;;;;;;;WAYF,U,CAAA,K,EAAA,M,EAAA,I,EAAyC;QAC/Be,QAD+B,GACZE,KADY,CAAA,Q;QACrBD,IADqB,GACZC,KADY,CAAA,I;;QAGnCD,IAAAA,CAAAA,IAAAA,KAAAA,aAAAA,IAA+BA,IAAAA,CAAAA,IAAAA,CAAAA,GAAAA,CAAAA,KAAAA,MAAnC,U,EAAwE;UAChEE,gBAAAA,GAAAA,QAAAA,CAAAA;uBAAAA,MAAAA;iBAAAA,cAAAA;eAAAA,GAAAA;kBAAAA,MAAAA;oBAAAA,QAAAA;iBAMK;AANLA,OAAAA,EAAN,KAAMA,C;;aAWJ,KAAA,CAAA,aAAA,C,MAAA,E,IAAA,E;AACQ,QAAA,eAAA,EAAN,K;AAA8B,QAAA,KAAA,EAA9B;qBADF,E,QAAA,C;;;WASGZ,IAAP,E;;;;;;;;;SASK;AAAEa,IAAAA,YAAAA,EAAF,YAAA;AAAgBC,IAAAA,UAAAA,EAAvB;AAAO,G","sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nvar index = (function (condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n});\n\nexport default index;\n","import invariant from 'tiny-invariant'\nimport React from 'react'\n\n/*\n * Instance counter to enable unique marks for multiple Placeholder instances.\n */\n\nlet instanceCounter = 0\n\n/**\n * A plugin that renders a React placeholder for a given Slate node.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction SlateReactPlaceholder(options = {}) {\n  const instanceId = instanceCounter++\n  const placeholderMark = {\n    type: 'placeholder',\n    data: { key: instanceId },\n  }\n\n  const { placeholder, when, style = {} } = options\n\n  invariant(\n    placeholder,\n    'You must pass `SlateReactPlaceholder` an `options.placeholder` string.'\n  )\n\n  invariant(\n    when,\n    'You must pass `SlateReactPlaceholder` an `options.when` query.'\n  )\n\n  /**\n   * Decorate a match node with a placeholder mark when it fits the query.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    if (!editor.query(when, node)) {\n      return next()\n    }\n\n    const others = next()\n    const document = editor.value.document\n    const first = node.getFirstText()\n    const last = node.getLastText()\n    const decoration = {\n      anchor: { key: first.key, offset: 0, path: document.getPath(first.key) },\n      focus: {\n        key: last.key,\n        offset: last.text.length,\n        path: document.getPath(last.key),\n      },\n      mark: placeholderMark,\n    }\n\n    return [...others, decoration]\n  }\n\n  /**\n   * Render an inline placeholder for the placeholder mark.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n  function renderMark(props, editor, next) {\n    const { children, mark } = props\n\n    if (mark.type === 'placeholder' && mark.data.get('key') === instanceId) {\n      const placeHolderStyle = {\n        pointerEvents: 'none',\n        display: 'inline-block',\n        width: '0',\n        maxWidth: '100%',\n        whiteSpace: 'nowrap',\n        opacity: '0.333',\n        ...style,\n      }\n\n      return (\n        <span>\n          <span contentEditable={false} style={placeHolderStyle}>\n            {placeholder}\n          </span>\n          {children}\n        </span>\n      )\n    }\n\n    return next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @return {Object}\n   */\n\n  return { decorateNode, renderMark }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default SlateReactPlaceholder\n"]},"metadata":{},"sourceType":"module"}