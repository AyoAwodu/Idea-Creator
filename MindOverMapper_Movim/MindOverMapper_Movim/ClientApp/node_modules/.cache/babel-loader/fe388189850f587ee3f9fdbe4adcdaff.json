{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _options = require('../options');\n\nvar _options2 = _interopRequireDefault(_options);\n\nvar _ = require('.');\n\nvar _utils = require('../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction isListOrItem(options, node) {\n  return (0, _utils.isList)(options, node) || (0, _utils.isItem)(options, node);\n}\n\nfunction mapListDescendants(document) {\n  return function (node) {\n    return {\n      depth: document.getDepth(node.key),\n      node: node\n    };\n  };\n}\n\nfunction sortListDescendants(options, a, b) {\n  if (a.depth !== b.depth) {\n    return b.depth - a.depth;\n  }\n\n  if (a.node.type === b.node.type) {\n    return 0;\n  }\n\n  if (a.node.type === options.typeItem) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction unwrapMappedNodes(change, mappedNode) {\n  return change.withoutNormalizing(function () {\n    change.unwrapBlockByKey(mappedNode.node.key, mappedNode.node.type);\n  });\n}\n\nfunction findAncestorList(change, options, commonAncestor) {\n  var _change$value = change.value,\n      document = _change$value.document,\n      selection = _change$value.selection; // This flag should be true, when elements are in selection\n\n  var flag = false;\n  return commonAncestor.filterDescendants(function (node) {\n    return isListOrItem(options, node);\n  }).filter(function (node) {\n    var hasStart = node.hasNode(selection.start.key);\n    var hasEnd = node.hasNode(selection.end.key);\n    var isListItem = (0, _utils.isItem)(options, node);\n    if (hasStart && isListItem) flag = true;\n    if (hasEnd && isListItem) flag = false;\n    return flag || hasStart || hasEnd;\n  }).map(mapListDescendants(document)).sort(function () {\n    for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n\n    return sortListDescendants.apply(undefined, [options].concat(params));\n  });\n}\n\nfunction isSameLevel(sortedMappedNodes) {\n  if (!sortedMappedNodes.size) {\n    return true;\n  }\n\n  var max = sortedMappedNodes.first().depth;\n  var min = sortedMappedNodes.last().depth;\n  return max === min;\n}\n/**\n * Toggle list on the selected range.\n */\n\n\nfunction toggleList(options, change) {\n  var _change$value2 = change.value,\n      document = _change$value2.document,\n      selection = _change$value2.selection;\n  var startBlock = document.getClosestBlock(selection.start.key);\n  var endBlock = document.getClosestBlock(selection.end.key); // -------- SINGLE BLOCK ---------------------------------------------------\n  // The selection is in a single block.\n  // Let's unwrap just the block, not the whole list.\n\n  if (startBlock === endBlock) {\n    return (0, _utils.isSelectionInList)(options, change.value) ? (0, _.unwrapList)(options, change) : (0, _.wrapInList)(options, change);\n  } // -------- NOT A SINGLE BLOCK -------------------------------------------\n\n\n  var commonAncestor = document.getCommonAncestor(startBlock.key, endBlock.key);\n  var sortedMappedNodes = findAncestorList(change, options, commonAncestor); // There are no lists or items in selection => wrap them\n\n  if (!sortedMappedNodes.size) {\n    return (0, _.wrapInList)(options, change);\n  } // All items are the same level => unwrap them\n\n\n  if (isSameLevel(sortedMappedNodes)) {\n    return (0, _.unwrapList)(options, change);\n  } // Common Ancestor is not a list or item\n\n\n  if (!isListOrItem(options, commonAncestor)) {\n    var _newChange = sortedMappedNodes // @TODO last item is filtered, so it wouldn't break down flat whole list -> unwrapNodeByKey should be solution (problem with key)\n    .filter(function (item) {\n      return sortedMappedNodes.last().depth !== item.depth;\n    }).reduce(unwrapMappedNodes, change);\n\n    return _newChange;\n  } // Unwrap all nested nodes\n\n\n  var newChange = sortedMappedNodes.reduce(unwrapMappedNodes, change); // Unwrap common ancestor\n\n  return (0, _.unwrapList)(options, newChange);\n}\n\nexports.default = toggleList;","map":{"version":3,"sources":["C:/Users/ayomi/source/repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/@tommoor/slate-edit-list/dist/changes/toggleList.js"],"names":["Object","defineProperty","exports","value","_slate","require","_options","_options2","_interopRequireDefault","_","_utils","obj","__esModule","default","isListOrItem","options","node","isList","isItem","mapListDescendants","document","depth","getDepth","key","sortListDescendants","a","b","type","typeItem","unwrapMappedNodes","change","mappedNode","withoutNormalizing","unwrapBlockByKey","findAncestorList","commonAncestor","_change$value","selection","flag","filterDescendants","filter","hasStart","hasNode","start","hasEnd","end","isListItem","map","sort","_len","arguments","length","params","Array","_key","apply","undefined","concat","isSameLevel","sortedMappedNodes","size","max","first","min","last","toggleList","_change$value2","startBlock","getClosestBlock","endBlock","isSelectionInList","unwrapList","wrapInList","getCommonAncestor","_newChange","item","reduce","newChange"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slate = require('slate');\n\nvar _options = require('../options');\n\nvar _options2 = _interopRequireDefault(_options);\n\nvar _ = require('.');\n\nvar _utils = require('../utils');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isListOrItem(options, node) {\n    return (0, _utils.isList)(options, node) || (0, _utils.isItem)(options, node);\n}\n\nfunction mapListDescendants(document) {\n    return function (node) {\n        return {\n            depth: document.getDepth(node.key),\n            node: node\n        };\n    };\n}\n\nfunction sortListDescendants(options, a, b) {\n    if (a.depth !== b.depth) {\n        return b.depth - a.depth;\n    }\n\n    if (a.node.type === b.node.type) {\n        return 0;\n    }\n\n    if (a.node.type === options.typeItem) {\n        return -1;\n    }\n\n    return 1;\n}\n\nfunction unwrapMappedNodes(change, mappedNode) {\n    return change.withoutNormalizing(function () {\n        change.unwrapBlockByKey(mappedNode.node.key, mappedNode.node.type);\n    });\n}\n\nfunction findAncestorList(change, options, commonAncestor) {\n    var _change$value = change.value,\n        document = _change$value.document,\n        selection = _change$value.selection;\n    // This flag should be true, when elements are in selection\n\n    var flag = false;\n\n    return commonAncestor.filterDescendants(function (node) {\n        return isListOrItem(options, node);\n    }).filter(function (node) {\n        var hasStart = node.hasNode(selection.start.key);\n        var hasEnd = node.hasNode(selection.end.key);\n        var isListItem = (0, _utils.isItem)(options, node);\n\n        if (hasStart && isListItem) flag = true;\n        if (hasEnd && isListItem) flag = false;\n\n        return flag || hasStart || hasEnd;\n    }).map(mapListDescendants(document)).sort(function () {\n        for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n            params[_key] = arguments[_key];\n        }\n\n        return sortListDescendants.apply(undefined, [options].concat(params));\n    });\n}\n\nfunction isSameLevel(sortedMappedNodes) {\n    if (!sortedMappedNodes.size) {\n        return true;\n    }\n\n    var max = sortedMappedNodes.first().depth;\n    var min = sortedMappedNodes.last().depth;\n\n    return max === min;\n}\n\n/**\n * Toggle list on the selected range.\n */\nfunction toggleList(options, change) {\n    var _change$value2 = change.value,\n        document = _change$value2.document,\n        selection = _change$value2.selection;\n\n    var startBlock = document.getClosestBlock(selection.start.key);\n    var endBlock = document.getClosestBlock(selection.end.key);\n\n    // -------- SINGLE BLOCK ---------------------------------------------------\n    // The selection is in a single block.\n    // Let's unwrap just the block, not the whole list.\n    if (startBlock === endBlock) {\n        return (0, _utils.isSelectionInList)(options, change.value) ? (0, _.unwrapList)(options, change) : (0, _.wrapInList)(options, change);\n    }\n\n    // -------- NOT A SINGLE BLOCK -------------------------------------------\n    var commonAncestor = document.getCommonAncestor(startBlock.key, endBlock.key);\n\n    var sortedMappedNodes = findAncestorList(change, options, commonAncestor);\n\n    // There are no lists or items in selection => wrap them\n    if (!sortedMappedNodes.size) {\n        return (0, _.wrapInList)(options, change);\n    }\n\n    // All items are the same level => unwrap them\n    if (isSameLevel(sortedMappedNodes)) {\n        return (0, _.unwrapList)(options, change);\n    }\n\n    // Common Ancestor is not a list or item\n    if (!isListOrItem(options, commonAncestor)) {\n        var _newChange = sortedMappedNodes\n        // @TODO last item is filtered, so it wouldn't break down flat whole list -> unwrapNodeByKey should be solution (problem with key)\n        .filter(function (item) {\n            return sortedMappedNodes.last().depth !== item.depth;\n        }).reduce(unwrapMappedNodes, change);\n        return _newChange;\n    }\n\n    // Unwrap all nested nodes\n    var newChange = sortedMappedNodes.reduce(unwrapMappedNodes, change);\n\n    // Unwrap common ancestor\n    return (0, _.unwrapList)(options, newChange);\n}\n\nexports.default = toggleList;"]},"metadata":{},"sourceType":"script"}