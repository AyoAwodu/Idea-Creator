{"ast":null,"code":"/**\r\n * @module methodWrapperScoped\r\n *\r\n */\nimport matchKeys from '../lib/match_keys';\nimport parseKeys from '../lib/parse_keys';\n/**\r\n * methodWrapperScoped\r\n *\r\n * @access public\r\n * @param {object} args All args necessary for decorating the method\r\n * @param {object} args.target The decorated method's class object\r\n * @param {object} args.descriptor The method's descriptor object\r\n * @param {array} args.keys The key codes bound to the decorated method\r\n * @return {object} The method's descriptor object\r\n */\n\nfunction methodWrapperScoped(_ref) {\n  var target = _ref.target,\n      descriptor = _ref.descriptor,\n      keys = _ref.keys;\n  var componentWillReceiveProps = target.componentWillReceiveProps;\n  var fn = descriptor.value;\n\n  if (!keys) {\n    console.warn(fn + ': keydownScoped requires one or more keys');\n  } else {\n    /**\r\n     * _shouldTrigger\r\n     *\r\n     * @access private\r\n     * @param {object} thisProps Exsting props from the wrapped component\r\n     * @param {object} thisProps.keydown The namespaced state from the higher-order\r\n     * component (class_decorator)\r\n     * @param {object} nextProps The incoming props from the wrapped component\r\n     * @param {object} nextProps.keydown The namescaped state from the higher-order\r\n     * component (class_decorator)\r\n     * @param {array} keys The keys bound to the decorated method\r\n     * @return {boolean} Whether all tests have passed\r\n     */\n    var _shouldTrigger = function _shouldTrigger(keydownThis, keydownNext) {\n      if (!(keydownNext && keydownNext.event && !keydownThis.event)) return false;\n      return keySets.some(function (keySet) {\n        return matchKeys({\n          keySet: keySet,\n          event: keydownNext.event\n        });\n      });\n    }; // wrap the component's lifecycle method to intercept key codes coming down\n    // from the wrapped/scoped component up the view hierarchy. if new keydown\n    // event has arrived and the key codes match what was specified in the\n    // decorator, call the wrapped method.\n\n\n    var keySets = parseKeys(keys);\n\n    target.componentWillReceiveProps = function (nextProps) {\n      var keydownNext = nextProps.keydown;\n      var keydownThis = this.props.keydown;\n\n      if (_shouldTrigger(keydownThis, keydownNext)) {\n        return fn.call(this, keydownNext.event);\n      }\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (componentWillReceiveProps) return componentWillReceiveProps.call.apply(componentWillReceiveProps, [this, nextProps].concat(args));\n    };\n  }\n\n  return descriptor;\n}\n\nexport default methodWrapperScoped;","map":null,"metadata":{},"sourceType":"module"}