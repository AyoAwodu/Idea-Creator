{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nrequire('slate');\n\nvar _utils = require('../utils');\n/**\n * Create a schema definition with rules to normalize lists\n */\n\n\nfunction normalizeNode(opts) {\n  return function (node, editor, next) {\n    return joinAdjacentLists(opts, node, next);\n  };\n}\n/**\n * A rule that joins adjacent lists of the same type\n */\n\n\nfunction joinAdjacentLists(opts, node, next) {\n  if (node.object !== 'document' && node.object !== 'block') {\n    return next();\n  }\n\n  var invalids = node.nodes.map(function (child, i) {\n    if (!(0, _utils.isList)(opts, child)) return null;\n    var nextNode = node.nodes.get(i + 1);\n\n    if (!nextNode || !(0, _utils.isList)(opts, nextNode) || !opts.canMerge(child, nextNode)) {\n      return null;\n    }\n\n    return [child, nextNode];\n  }).filter(Boolean);\n\n  if (invalids.isEmpty()) {\n    return next();\n  }\n  /**\n   * Join the list pairs\n   */\n  // We join in reverse order, so that multiple lists folds onto the first one\n\n\n  return function (change) {\n    change.withoutNormalizing(function () {\n      invalids.reverse().forEach(function (pair) {\n        var _pair = _slicedToArray(pair, 2),\n            first = _pair[0],\n            second = _pair[1];\n\n        var updatedSecond = change.value.document.getDescendant(second.key);\n        updatedSecond.nodes.forEach(function (secondNode, index) {\n          change.moveNodeByKey(secondNode.key, first.key, first.nodes.size + index);\n        });\n        change.removeNodeByKey(second.key);\n      });\n    });\n  };\n}\n\nexports.default = normalizeNode;","map":{"version":3,"sources":["C:/Users/ayomi/Source/Repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/@tommoor/slate-edit-list/dist/validation/normalizeNode.js"],"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","require","_utils","normalizeNode","opts","node","editor","joinAdjacentLists","object","invalids","nodes","map","child","isList","nextNode","get","canMerge","filter","Boolean","isEmpty","change","withoutNormalizing","reverse","forEach","pair","_pair","first","second","updatedSecond","document","getDescendant","key","secondNode","index","moveNodeByKey","size","removeNodeByKey","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nrequire('slate');\n\nvar _utils = require('../utils');\n\n/**\n * Create a schema definition with rules to normalize lists\n */\nfunction normalizeNode(opts) {\n    return function (node, editor, next) {\n        return joinAdjacentLists(opts, node, next);\n    };\n}\n\n/**\n * A rule that joins adjacent lists of the same type\n */\nfunction joinAdjacentLists(opts, node, next) {\n    if (node.object !== 'document' && node.object !== 'block') {\n        return next();\n    }\n\n    var invalids = node.nodes.map(function (child, i) {\n        if (!(0, _utils.isList)(opts, child)) return null;\n        var nextNode = node.nodes.get(i + 1);\n        if (!nextNode || !(0, _utils.isList)(opts, nextNode) || !opts.canMerge(child, nextNode)) {\n            return null;\n        }\n\n        return [child, nextNode];\n    }).filter(Boolean);\n\n    if (invalids.isEmpty()) {\n        return next();\n    }\n\n    /**\n     * Join the list pairs\n     */\n    // We join in reverse order, so that multiple lists folds onto the first one\n    return function (change) {\n        change.withoutNormalizing(function () {\n            invalids.reverse().forEach(function (pair) {\n                var _pair = _slicedToArray(pair, 2),\n                    first = _pair[0],\n                    second = _pair[1];\n\n                var updatedSecond = change.value.document.getDescendant(second.key);\n                updatedSecond.nodes.forEach(function (secondNode, index) {\n                    change.moveNodeByKey(secondNode.key, first.key, first.nodes.size + index);\n                });\n\n                change.removeNodeByKey(second.key);\n            });\n        });\n    };\n}\n\nexports.default = normalizeNode;"]},"metadata":{},"sourceType":"script"}