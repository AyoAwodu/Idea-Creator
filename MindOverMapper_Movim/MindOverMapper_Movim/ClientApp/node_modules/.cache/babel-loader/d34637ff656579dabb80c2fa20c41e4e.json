{"ast":null,"code":"import getWindow from 'get-window';\nimport invariant from 'tiny-invariant';\nimport { Value, Node, PathUtils, Editor } from 'slate';\nimport Debug from 'debug';\nimport pick from 'lodash/pick';\nimport { ANDROID_API_VERSION, IS_IE, IS_IOS, IS_EDGE, IS_FIREFOX, HAS_INPUT_EVENTS_LEVEL_2, IS_ANDROID, IS_SAFARI } from 'slate-dev-environment';\nimport Base64 from 'slate-base64-serializer';\nimport Plain from 'slate-plain-serializer';\nimport Hotkeys from 'slate-hotkeys';\nimport ReactDOM from 'react-dom';\nimport React from 'react';\nimport Types from 'prop-types';\nimport SlateTypes from 'slate-prop-types';\nimport ImmutableTypes from 'react-immutable-proptypes';\nimport { Set } from 'immutable';\nimport warning from 'tiny-warning';\nimport isBackward from 'selection-is-backward';\nimport throttle from 'lodash/throttle';\nimport PlaceholderPlugin from 'slate-react-placeholder';\nimport memoizeOne from 'memoize-one';\n/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onClick', 'onContextMenu', 'onCompositionEnd', 'onCompositionStart', 'onCopy', 'onCut', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onInput', 'onFocus', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseUp', 'onPaste', 'onSelect'];\n/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\nfunction fixSelectionInZeroWidthBlock(window) {\n  var domSelection = window.getSelection();\n  var anchorNode = domSelection.anchorNode;\n  var dataset = anchorNode.parentElement.dataset;\n  var isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false; // We are doing three checks to see if we need to move the cursor.\n  // Is this a zero-width slate span?\n  // Is the current cursor position not at the start of it?\n  // Is there more than one character (i.e. the zero-width space char) in here?\n\n  if (isZeroWidth && anchorNode.textContent.length === 1 && domSelection.anchorOffset !== 0) {\n    var range = window.document.createRange();\n    range.setStart(anchorNode, 0);\n    range.setEnd(anchorNode, 0);\n    domSelection.removeAllRanges();\n    domSelection.addRange(range);\n  }\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\n\nvar PARSER = /^([\\w-]+)(?::(\\d+))?$/;\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  var matches = PARSER.exec(string);\n\n  if (!matches) {\n    throw new Error(\"Invalid offset key string \\\"\" + string + \"\\\".\");\n  }\n\n  var _matches = slicedToArray(matches, 3),\n      original = _matches[0],\n      key = _matches[1],\n      index = _matches[2]; // eslint-disable-line no-unused-vars\n\n\n  return {\n    key: key,\n    index: parseInt(index, 10)\n  };\n}\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\n\nfunction stringify(object) {\n  return object.key + \":\" + object.index;\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar OffsetKey = {\n  parse: parse,\n  stringify: stringify\n};\n/**\n * Constants.\n *\n * @type {String}\n */\n\nvar ZERO_WIDTH_ATTRIBUTE = 'data-slate-zero-width';\nvar ZERO_WIDTH_SELECTOR = '[' + ZERO_WIDTH_ATTRIBUTE + ']';\nvar OFFSET_KEY_ATTRIBUTE = 'data-offset-key';\nvar RANGE_SELECTOR = '[' + OFFSET_KEY_ATTRIBUTE + ']';\nvar TEXT_SELECTOR = '[data-key]';\nvar VOID_SELECTOR = '[data-slate-void]';\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.');\n\n  var _normalizeNodeAndOffs = normalizeNodeAndOffset(nativeNode, nativeOffset),\n      nearestNode = _normalizeNodeAndOffs.node,\n      nearestOffset = _normalizeNodeAndOffs.offset;\n\n  var window = getWindow(nativeNode);\n  var parentNode = nearestNode.parentNode;\n  var rangeNode = parentNode.closest(RANGE_SELECTOR);\n  var offset = void 0;\n  var node = void 0; // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n\n  if (rangeNode) {\n    var range = window.document.createRange();\n    var textNode = rangeNode.closest(TEXT_SELECTOR);\n    range.setStart(textNode, 0);\n    range.setEnd(nearestNode, nearestOffset);\n    node = textNode; // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n    offset = range.cloneContents().textContent.length;\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    var voidNode = parentNode.closest(VOID_SELECTOR);\n    if (!voidNode) return null;\n    rangeNode = voidNode.querySelector(RANGE_SELECTOR);\n    if (!rangeNode) return null;\n    node = rangeNode;\n    offset = node.textContent.length;\n  } // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n\n\n  if (offset === node.textContent.length && parentNode.hasAttribute(ZERO_WIDTH_ATTRIBUTE)) {\n    offset--;\n  } // Get the string value of the offset key attribute.\n\n\n  var offsetKey = rangeNode.getAttribute(OFFSET_KEY_ATTRIBUTE);\n  if (!offsetKey) return null;\n\n  var _OffsetKey$parse = OffsetKey.parse(offsetKey),\n      key = _OffsetKey$parse.key; // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n\n\n  var value = editor.value;\n  if (!value.document.hasDescendant(key)) return null;\n  var point = value.document.createPoint({\n    key: key,\n    offset: offset\n  });\n  return point;\n}\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (node.nodeType === 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return {\n    node: node,\n    offset: offset\n  };\n}\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\n\nfunction getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction === 'forward') i++;\n    if (direction === 'backward') i--;\n  }\n\n  return child || null;\n}\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\n\nfunction findRange(native, editor) {\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n  var el = native.anchorNode || native.startContainer;\n  if (!el) return null;\n  var window = getWindow(el); // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n\n  if (native instanceof window.Range || window.StaticRange && native instanceof window.StaticRange) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset\n    };\n  }\n\n  var _native = native,\n      anchorNode = _native.anchorNode,\n      anchorOffset = _native.anchorOffset,\n      focusNode = _native.focusNode,\n      focusOffset = _native.focusOffset,\n      isCollapsed = _native.isCollapsed;\n  var value = editor.value;\n  var anchor = findPoint(anchorNode, anchorOffset, editor);\n  var focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor);\n  if (!anchor || !focus) return null;\n  var document = value.document;\n  var range = document.createRange({\n    anchor: anchor,\n    focus: focus\n  });\n  return range;\n}\n\nfunction getSelectionFromDOM(window, editor, domSelection) {\n  var value = editor.value;\n  var document = value.document; // If there are no ranges, the editor was blurred natively.\n\n  if (!domSelection.rangeCount) {\n    editor.blur();\n    return;\n  } // Otherwise, determine the Slate selection from the native one.\n\n\n  var range = findRange(domSelection, editor);\n\n  if (!range) {\n    return;\n  }\n\n  var _range = range,\n      anchor = _range.anchor,\n      focus = _range.focus;\n  var anchorText = document.getNode(anchor.key);\n  var focusText = document.getNode(focus.key);\n  var anchorInline = document.getClosestInline(anchor.key);\n  var focusInline = document.getClosestInline(focus.key);\n  var focusBlock = document.getClosestBlock(focus.key);\n  var anchorBlock = document.getClosestBlock(anchor.key); // COMPAT: If the anchor point is at the start of a non-void, and the\n  // focus point is inside a void node with an offset that isn't `0`, set\n  // the focus offset to `0`. This is due to void nodes <span>'s being\n  // positioned off screen, resulting in the offset always being greater\n  // than `0`. Since we can't know what it really should be, and since an\n  // offset of `0` is less destructive because it creates a hanging\n  // selection, go with `0`. (2017/09/07)\n\n  if (anchorBlock && !editor.isVoid(anchorBlock) && anchor.offset === 0 && focusBlock && editor.isVoid(focusBlock) && focus.offset !== 0) {\n    range = range.setFocus(focus.setOffset(0));\n  } // COMPAT: If the selection is at the end of a non-void inline node, and\n  // there is a node after it, put it in the node after instead. This\n  // standardizes the behavior, since it's indistinguishable to the user.\n\n\n  if (anchorInline && !editor.isVoid(anchorInline) && anchor.offset === anchorText.text.length) {\n    var block = document.getClosestBlock(anchor.key);\n    var nextText = block.getNextText(anchor.key);\n    if (nextText) range = range.moveAnchorTo(nextText.key, 0);\n  }\n\n  if (focusInline && !editor.isVoid(focusInline) && focus.offset === focusText.text.length) {\n    var _block = document.getClosestBlock(focus.key);\n\n    var _nextText = _block.getNextText(focus.key);\n\n    if (_nextText) range = range.moveFocusTo(_nextText.key, 0);\n  }\n\n  var selection = document.createSelection(range);\n  selection = selection.setIsFocused(true); // Preserve active marks from the current selection.\n  // They will be cleared by `editor.select` if the selection actually moved.\n\n  selection = selection.set('marks', value.selection.marks);\n  return selection;\n}\n/**\n * Looks at the DOM and generates the equivalent Slate Selection.\n *\n * @param {Window} window\n * @param {Editor} editor\n * @param {Selection} domSelection - The DOM's selection Object\n */\n\n\nfunction setSelectionFromDOM(window, editor, domSelection) {\n  var selection = getSelectionFromDOM(window, editor, domSelection);\n  editor.select(selection);\n}\n/**\n * setTextFromDomNode lets us take a domNode and reconcile the text in the\n * editor's Document such that it reflects the text in the DOM. This is the\n * opposite of what the Editor usually does which takes the Editor's Document\n * and React modifies the DOM to match. The purpose of this method is for\n * composition changes where we don't know what changes the user made by\n * looking at events. Instead we wait until the DOM is in a safe state, we\n * read from it, and update the Editor's Document.\n *\n * @param {Window} window\n * @param {Editor} editor\n * @param {Node} domNode\n */\n\n\nfunction setTextFromDomNode(window, editor, domNode) {\n  var point = findPoint(domNode, 0, editor);\n  if (!point) return; // Get the text node and leaf in question.\n\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var node = document.getDescendant(point.key);\n  var block = document.getClosestBlock(node.key);\n  var leaves = node.getLeaves();\n  var lastText = block.getLastText();\n  var lastLeaf = leaves.last();\n  var start = 0;\n  var end = 0;\n  var leaf = leaves.find(function (r) {\n    start = end;\n    end += r.text.length;\n    if (end > point.offset) return true;\n  }) || lastLeaf; // Get the text information.\n\n  var text = leaf.text;\n  var textContent = domNode.textContent;\n  var isLastText = node === lastText;\n  var isLastLeaf = leaf === lastLeaf;\n  var lastChar = textContent.charAt(textContent.length - 1); // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n  // we will have added another new line in <Leaf>'s render method to account\n  // for browsers collapsing a single trailing new lines, so remove it.\n\n  if (isLastText && isLastLeaf && lastChar === '\\n') {\n    textContent = textContent.slice(0, -1);\n  } // If the text is no different, abort.\n\n\n  if (textContent === text) return; // Determine what the selection should be after changing the text.\n  // const delta = textContent.length - text.length\n  // const corrected = selection.moveToEnd().moveForward(delta)\n\n  var entire = selection.moveAnchorTo(point.key, start).moveFocusTo(point.key, end);\n  entire = document.resolveRange(entire); // Change the current value to have the leaf's text replaced.\n\n  editor.insertTextAtRange(entire, textContent, leaf.marks);\n}\n/**\n * In Android API 26 and 27 we can tell if the input key was pressed by\n * waiting for the `beforeInput` event and seeing that the last character\n * of its `data` property is char code `10`.\n *\n * Note that at this point it is too late to prevent the event from affecting\n * the DOM so we use other methods to clean the DOM up after we have detected\n * the input.\n *\n * @param  {String} data\n * @return {Boolean}\n */\n\n\nfunction isInputDataEnter(data) {\n  if (data == null) return false;\n  var lastChar = data[data.length - 1];\n  var charCode = lastChar.charCodeAt(0);\n  return charCode === 10;\n}\n/**\n * In Android sometimes the only way to tell what the user is trying to do\n * is to look at an event's `data` property and see if the last characters\n * matches a character. This method helps us make that determination.\n *\n * @param {String} data\n * @param {[String]} chars\n * @return {Boolean}\n */\n\n\nfunction isInputDataLastChar(data, chars) {\n  if (!Array.isArray(chars)) throw new Error(\"chars must be an array of one character strings\");\n  if (data == null) return false;\n  var lastChar = data[data.length - 1];\n  return chars.includes(lastChar);\n}\n/**\n * Is the given node a text node?\n *\n * @param {node} node\n * @param {Window} window\n * @return {Boolean}\n */\n\n\nfunction isTextNode(node, window) {\n  return node.nodeType === window.Node.TEXT_NODE;\n}\n/**\n * Takes a node and returns a snapshot of the node.\n *\n * @param {node} node\n * @param {Window} window\n * @return {object} element snapshot\n */\n\n\nfunction getElementSnapshot(node, window) {\n  var snapshot = {};\n  snapshot.node = node;\n\n  if (isTextNode(node, window)) {\n    snapshot.text = node.textContent;\n  }\n\n  snapshot.children = Array.from(node.childNodes).map(function (childNode) {\n    return getElementSnapshot(childNode, window);\n  });\n  return snapshot;\n}\n/**\n * Takes an array of elements and returns a snapshot\n *\n * @param {elements[]} elements\n * @param {Window} window\n * @return {object} snapshot\n */\n\n\nfunction getSnapshot(elements, window) {\n  if (!elements.length) throw new Error('elements must be an Array');\n  var lastElement = elements[elements.length - 1];\n  var snapshot = {\n    elements: elements.map(function (element) {\n      return getElementSnapshot(element, window);\n    }),\n    parent: lastElement.parentElement,\n    next: lastElement.nextElementSibling\n  };\n  return snapshot;\n}\n/**\n * Takes an element snapshot and applies it to the element in the DOM.\n * Basically, it fixes the DOM to the point in time that the snapshot was\n * taken. This will put the DOM back in sync with React.\n *\n * @param {Object} snapshot\n * @param {Window} window\n */\n\n\nfunction applyElementSnapshot(snapshot, window) {\n  var el = snapshot.node;\n\n  if (isTextNode(el, window)) {\n    // Update text if it is different\n    if (el.textContent !== snapshot.text) {\n      el.textContent = snapshot.text;\n    }\n  }\n\n  snapshot.children.forEach(function (childSnapshot) {\n    applyElementSnapshot(childSnapshot, window);\n    el.appendChild(childSnapshot.node);\n  }); // remove children that shouldn't be there\n\n  var snapLength = snapshot.children.length;\n\n  while (el.childNodes.length > snapLength) {\n    el.removeChild(el.childNodes[0]);\n  } // remove any clones from the DOM. This can happen when a block is split.\n\n\n  var dataset = el.dataset;\n  if (!dataset) return; // if there's no dataset, don't remove it\n\n  var key = dataset.key;\n  if (!key) return; // if there's no `data-key`, don't remove it\n\n  var dups = new window.Set(Array.from(window.document.querySelectorAll('[data-key=\\'' + key + '\\']')));\n  dups.delete(el);\n  dups.forEach(function (dup) {\n    return dup.parentElement.removeChild(dup);\n  });\n}\n/**\n * Takes a snapshot and applies it to the DOM. Rearranges both the contents\n * of the elements in the snapshot as well as putting the elements back into\n * position relative to each other and also makes sure the last element is\n * before the same element as it was when the snapshot was taken.\n *\n * @param {snapshot} snapshot\n * @param {Window} window\n */\n\n\nfunction applySnapshot(snapshot, window) {\n  var elements = snapshot.elements,\n      next = snapshot.next,\n      parent = snapshot.parent;\n  elements.forEach(function (element) {\n    return applyElementSnapshot(element, window);\n  });\n  var lastElement = elements[elements.length - 1].node;\n\n  if (snapshot.next) {\n    parent.insertBefore(lastElement, next);\n  } else {\n    parent.appendChild(lastElement);\n  }\n\n  var prevElement = lastElement;\n\n  for (var i = elements.length - 2; i >= 0; i--) {\n    var element = elements[i].node;\n    parent.insertBefore(element, prevElement);\n    prevElement = element;\n  }\n}\n/**\n * A snapshot of one or more elements.\n */\n\n\nvar ElementSnapshot = function () {\n  /**\n   * constructor\n   * @param {elements[]} elements - array of element to snapshot. Must be in order.\n   * @param {object} data - any arbitrary data you want to store with the snapshot\n   */\n  function ElementSnapshot(elements, data) {\n    classCallCheck(this, ElementSnapshot);\n    this.window = getWindow(elements[0]);\n    this.snapshot = getSnapshot(elements, this.window);\n    this.data = data;\n  }\n  /**\n   * apply the current snapshot to the DOM.\n   */\n\n\n  createClass(ElementSnapshot, [{\n    key: 'apply',\n    value: function apply() {\n      applySnapshot(this.snapshot, this.window);\n    }\n    /**\n     * get the data you passed into the constructor.\n     *\n     * @return {object} data\n     */\n\n  }, {\n    key: 'getData',\n    value: function getData() {\n      return this.data;\n    }\n  }]);\n  return ElementSnapshot;\n}();\n/**\n * Returns the closest element that matches the selector.\n * Unlike the native `Element.closest` method, this doesn't require the\n * starting node to be an Element.\n *\n * @param  {Node} node to start at\n * @param  {String} css selector to match\n * @return {Element} the closest matching element\n */\n\n\nfunction closest(node, selector) {\n  var win = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n\n  if (node.nodeType === win.Node.TEXT_NODE) {\n    node = node.parentNode;\n  }\n\n  return node.closest(selector);\n}\n/**\n * A DomSnapshot remembers the state of elements at a given point in time\n * and also remembers the state of the Editor at that time as well.\n * The state can be applied to the DOM at a time in the future.\n */\n\n\nvar DomSnapshot = function () {\n  /**\n   * Constructor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {Boolean} options.before - should we remember the element before the one passed in\n   */\n  function DomSnapshot(window, editor) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref$before = _ref.before,\n        before = _ref$before === undefined ? false : _ref$before;\n\n    classCallCheck(this, DomSnapshot);\n    var domSelection = window.getSelection();\n    var anchorNode = domSelection.anchorNode;\n    var subrootEl = closest(anchorNode, '[data-slate-editor] > *');\n    var elements = [subrootEl]; // The before option is for when we need to take a snapshot of the current\n    // subroot and the element before when the user hits the backspace key.\n\n    if (before) {\n      var previousElementSibling = subrootEl.previousElementSibling;\n\n      if (previousElementSibling) {\n        elements.unshift(previousElementSibling);\n      }\n    }\n\n    this.snapshot = new ElementSnapshot(elements);\n    this.selection = getSelectionFromDOM(window, editor, domSelection);\n  }\n  /**\n   * Apply the snapshot to the DOM and set the selection in the Editor.\n   *\n   * @param {Editor} editor\n   */\n\n\n  createClass(DomSnapshot, [{\n    key: 'apply',\n    value: function apply(editor) {\n      var snapshot = this.snapshot,\n          selection = this.selection;\n      snapshot.apply();\n      editor.moveTo(selection.anchor.key, selection.anchor.offset);\n    }\n  }]);\n  return DomSnapshot;\n}();\n/**\n * A function that does nothing\n * @return {Function}\n */\n\n\nfunction noop() {}\n/**\n * Creates an executor like a `resolver` or a `deleter` that handles\n * delayed execution of a method using a `requestAnimationFrame` or `setTimeout`.\n *\n * Unlike a `requestAnimationFrame`, after a method is cancelled, it can be\n * resumed. You can also optionally add a `timeout` after which time the\n * executor is automatically cancelled.\n */\n\n\nvar Executor =\n/**\n * Executor\n * @param {window} window\n * @param {Function} fn - the function to execute when done\n * @param {Object} options\n */\nfunction Executor(window, fn) {\n  var _this = this;\n\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  classCallCheck(this, Executor);\n\n  this.__call__ = function () {\n    // I don't clear the timeout since it will be noop'ed anyways. Less code.\n    _this.fn();\n\n    _this.preventFurtherCalls(); // Ensure you can only call the function once\n\n  };\n\n  this.preventFurtherCalls = function () {\n    _this.fn = noop;\n  };\n\n  this.resume = function (ms) {\n    // in case resume is called more than once, we don't want old timers\n    // from executing because the `timeoutId` or `callbackId` is overwritten.\n    _this.cancel();\n\n    if (ms) {\n      _this.mode = 'timeout';\n      _this.timeoutId = _this.window.setTimeout(_this.__call__, ms);\n    } else {\n      _this.mode = 'animationFrame';\n      _this.callbackId = _this.window.requestAnimationFrame(_this.__call__);\n    }\n  };\n\n  this.cancel = function () {\n    if (_this.mode === 'timeout') {\n      _this.window.clearTimeout(_this.timeoutId);\n    } else {\n      _this.window.cancelAnimationFrame(_this.callbackId);\n    }\n\n    if (_this.onCancel) _this.onCancel();\n  };\n\n  this.__setTimeout__ = function (timeout) {\n    if (timeout == null) return;\n\n    _this.window.setTimeout(function () {\n      _this.cancel();\n\n      _this.preventFurtherCalls();\n    }, timeout);\n  };\n\n  this.fn = fn;\n  this.window = window;\n  this.resume();\n  this.onCancel = options.onCancel;\n\n  this.__setTimeout__(options.timeout);\n};\n\nvar debug = Debug('slate:android');\ndebug.reconcile = Debug('slate:reconcile');\ndebug('ANDROID_API_VERSION', {\n  ANDROID_API_VERSION: ANDROID_API_VERSION\n});\n/**\n * Define variables related to composition state.\n */\n\nvar NONE = 0;\nvar COMPOSING = 1;\n\nfunction AndroidPlugin() {\n  /**\n   * The current state of composition.\n   *\n   * @type {NONE|COMPOSING|WAITING}\n   */\n  var status = NONE;\n  /**\n   * The set of nodes that we need to process when we next reconcile.\n   * Usually this is soon after the `onCompositionEnd` event.\n   *\n   * @type {Set} set containing Node objects\n   */\n\n  var nodes = new window.Set();\n  /**\n   * Keep a snapshot after a composition end for API 26/27. If a `beforeInput`\n   * gets called with data that ends in an ENTER then we need to use this\n   * snapshot to revert the DOM so that React doesn't get out of sync with the\n   * DOM. We also need to cancel the `reconcile` operation as it interferes in\n   * certain scenarios like hitting 'enter' at the end of a word.\n   *\n   * @type {DomSnapshot} [compositionEndSnapshot]\n   \n   */\n\n  var compositionEndSnapshot = null;\n  /**\n   * When there is a `compositionEnd` we ened to reconcile Slate's Document\n   * with the DOM. The `reconciler` is an instance of `Executor` that does\n   * this for us. It is created on every `compositionEnd` and executes on the\n   * next `requestAnimationFrame`. The `Executor` can be cancelled and resumed\n   * which some methods do.\n   *\n   * @type {Executor}\n   */\n\n  var reconciler = null;\n  /**\n   * A snapshot that gets taken when there is a `keydown` event in API26/27.\n   * If an `input` gets called with `inputType` of `deleteContentBackward`\n   * we need to undo the delete that Android does to keep React in sync with\n   * the DOM.\n   *\n   * @type {DomSnapshot}\n   */\n\n  var keyDownSnapshot = null;\n  /**\n   * The deleter is an instace of `Executor` that will execute a delete\n   * operation on the next `requestAnimationFrame`. It has to wait because\n   * we need Android to finish all of its DOM operations to do with deletion\n   * before we revert them to a Snapshot. After reverting, we then execute\n   * Slate's version of delete.\n   *\n   * @type {Executor}\n   */\n\n  var deleter = null;\n  /**\n   * Because Slate implements its own event handler for `beforeInput` in\n   * addition to React's version, we actually get two. If we cancel the\n   * first native version, the React one will still fire. We set this to\n   * `true` if we don't want that to happen. Remember that when we prevent it,\n   * we need to tell React to `preventDefault` so the event doesn't continue\n   * through React's event system.\n   *\n   * type {Boolean}\n   */\n\n  var preventNextBeforeInput = false;\n  /**\n   * When a composition ends, in some API versions we may need to know what we\n   * have learned so far about the composition and what we want to do because of\n   * some actions that may come later.\n   *\n   * For example in API 26/27, if we get a `beforeInput` that tells us that the\n   * input was a `.`, then we want the reconcile to happen even if there are\n   * `onInput:delete` events that follow. In this case, we would set\n   * `compositionEndAction` to `period`. During the `onInput` we would check if\n   * the `compositionEndAction` says `period` and if so we would not start the\n   * `delete` action.\n   *\n   * @type {(String|null)}\n   */\n\n  var compositionEndAction = null;\n  /**\n   * Looks at the `nodes` we have collected, usually the things we have edited\n   * during the course of a composition, and then updates Slate's internal\n   * Document based on the text values in these DOM nodes and also updates\n   * Slate's Selection based on the current cursor position in the Editor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {String} options.from - where reconcile was called from for debug\n   */\n\n  function reconcile(window, editor, _ref) {\n    var from = _ref.from;\n    debug.reconcile({\n      from: from\n    });\n    var domSelection = window.getSelection();\n    nodes.forEach(function (node) {\n      setTextFromDomNode(window, editor, node);\n    });\n    setSelectionFromDOM(window, editor, domSelection);\n    nodes.clear();\n  }\n  /**\n   * On before input.\n   *\n   * Check `components/content` because some versions of Android attach a\n   * native `beforeinput` event on the Editor. In this case, you might need\n   * to distinguish whether the event coming through is the native or React\n   * version of the event. Also, if you cancel the native version that does\n   * not necessarily mean that the React version is cancelled.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBeforeInput(event, editor, next) {\n    var isNative = !event.nativeEvent;\n    debug('onBeforeInput', {\n      isNative: isNative,\n      event: event,\n      status: status,\n      e: pick(event, ['data', 'inputType', 'isComposing', 'nativeEvent'])\n    });\n    var window = getWindow(event.target);\n\n    if (preventNextBeforeInput) {\n      event.preventDefault();\n      preventNextBeforeInput = false;\n      return;\n    }\n\n    switch (ANDROID_API_VERSION) {\n      case 25:\n        // prevent onBeforeInput to allow selecting an alternate suggest to\n        // work.\n        break;\n\n      case 26:\n      case 27:\n        if (deleter) {\n          deleter.cancel();\n          reconciler.resume();\n        } // This analyses Android's native `beforeInput` which Slate adds\n        // on in the `Content` component. It only fires if the cursor is at\n        // the end of a block. Otherwise, the code below checks.\n\n\n        if (isNative) {\n          if (event.inputType === 'insertParagraph' || event.inputType === 'insertLineBreak') {\n            debug('onBeforeInput:enter:native', {});\n            var domSelection = window.getSelection();\n            var selection = getSelectionFromDOM(window, editor, domSelection);\n            preventNextBeforeInput = true;\n            event.preventDefault();\n            editor.moveTo(selection.anchor.key, selection.anchor.offset);\n            editor.splitBlock();\n          }\n        } else {\n          if (isInputDataLastChar(event.data, ['.'])) {\n            debug('onBeforeInput:period');\n            reconciler.cancel();\n            compositionEndAction = 'period';\n            return;\n          } // This looks at the beforeInput event's data property and sees if it\n          // ends in a linefeed which is character code 10. This appears to be\n          // the only way to detect that enter has been pressed except at end\n          // of line where it doesn't work.\n\n\n          var isEnter = isInputDataEnter(event.data);\n\n          if (isEnter) {\n            if (reconciler) reconciler.cancel();\n            window.requestAnimationFrame(function () {\n              debug('onBeforeInput:enter:react', {});\n              compositionEndSnapshot.apply(editor);\n              editor.splitBlock();\n            });\n          }\n        }\n\n        break;\n\n      case 28:\n        // If a `beforeInput` event fires after an `input:deleteContentBackward`\n        // event, it appears to be a good indicator that it is some sort of\n        // special combined Android event. If this is the case, then we don't\n        // want to have a deletion to happen, we just want to wait until Android\n        // has done its thing and then at the end we just want to reconcile.\n        if (deleter) {\n          deleter.cancel();\n          reconciler.resume();\n        }\n\n        break;\n\n      default:\n        if (status !== COMPOSING) next();\n    }\n  }\n  /**\n   * On Composition end. By default, when a `compositionEnd` event happens,\n   * we start a reconciler. The reconciler will update Slate's Document using\n   * the DOM as the source of truth. In some cases, the reconciler needs to\n   * be cancelled and can also be resumed. For example, when a delete\n   * immediately followed a `compositionEnd`, we don't want to reconcile.\n   * Instead, we want the `delete` to take precedence.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onCompositionEnd(event, editor, next) {\n    debug('onCompositionEnd', {\n      event: event\n    });\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var anchorNode = domSelection.anchorNode;\n\n    switch (ANDROID_API_VERSION) {\n      case 26:\n      case 27:\n        compositionEndSnapshot = new DomSnapshot(window, editor); // fixes a bug in Android API 26 & 27 where a `compositionEnd` is triggered\n        // without the corresponding `compositionStart` event when clicking a\n        // suggestion.\n        //\n        // If we don't add this, the `onBeforeInput` is triggered and passes\n        // through to the `before` plugin.\n\n        status = COMPOSING;\n        break;\n    }\n\n    compositionEndAction = 'reconcile';\n    nodes.add(anchorNode);\n    reconciler = new Executor(window, function () {\n      status = NONE;\n      reconcile(window, editor, {\n        from: 'onCompositionEnd:reconciler'\n      });\n      compositionEndAction = null;\n    });\n  }\n  /**\n   * On composition start.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onCompositionStart(event, editor, next) {\n    debug('onCompositionStart', {\n      event: event\n    });\n    status = COMPOSING;\n    nodes.clear();\n  }\n  /**\n   * On composition update.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onCompositionUpdate(event, editor, next) {\n    debug('onCompositionUpdate', {\n      event: event\n    });\n  }\n  /**\n   * On input.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    debug('onInput', {\n      event: event,\n      status: status,\n      e: pick(event, ['data', 'nativeEvent', 'inputType', 'isComposing'])\n    });\n\n    switch (ANDROID_API_VERSION) {\n      case 24:\n      case 25:\n        break;\n\n      case 26:\n      case 27:\n      case 28:\n        var nativeEvent = event.nativeEvent;\n\n        if (ANDROID_API_VERSION === 28) {\n          // NOTE API 28:\n          // When a user hits space and then backspace in `middle` we end up\n          // with `midle`.\n          //\n          // This is because when the user hits space, the composition is not\n          // ended because `compositionEnd` is not called yet. When backspace is\n          // hit, the `compositionEnd` is called. We need to revert the DOM but\n          // the reconciler has not had a chance to run from the\n          // `compositionEnd` because it is set to run on the next\n          // `requestAnimationFrame`. When the backspace is carried out on the\n          // Slate Value, Slate doesn't know about the space yet so the\n          // backspace is carried out without the space cuasing us to lose a\n          // character.\n          //\n          // This fix forces Android to reconcile immediately after hitting\n          // the space.\n          //\n          // NOTE API 27:\n          // It is confirmed that this bug does not present itself on API27.\n          // A space fires a `compositionEnd` (as well as other events including\n          // an input that is a delete) so the reconciliation happens.\n          //\n          if (nativeEvent.inputType === 'insertText' && nativeEvent.data === ' ') {\n            if (reconciler) reconciler.cancel();\n            if (deleter) deleter.cancel();\n            reconcile(window, editor, {\n              from: 'onInput:space'\n            });\n            return;\n          }\n        }\n\n        if (ANDROID_API_VERSION === 26 || ANDROID_API_VERSION === 27) {\n          if (compositionEndAction === 'period') {\n            debug('onInput:period:abort'); // This means that there was a `beforeInput` that indicated the\n            // period was pressed. When a period is pressed, you get a bunch\n            // of delete actions mixed in. We want to ignore those. At this\n            // point, we add the current node to the list of things we need to\n            // resolve at the next compositionEnd. We know that a new\n            // composition will start right after this event so it is safe to\n            // do this.\n\n            var _window$getSelection = window.getSelection(),\n                anchorNode = _window$getSelection.anchorNode;\n\n            nodes.add(anchorNode);\n            return;\n          }\n        }\n\n        if (nativeEvent.inputType === 'deleteContentBackward') {\n          debug('onInput:delete', {\n            keyDownSnapshot: keyDownSnapshot\n          });\n\n          var _window = getWindow(event.target);\n\n          if (reconciler) reconciler.cancel();\n          if (deleter) deleter.cancel();\n          deleter = new Executor(_window, function () {\n            debug('onInput:delete:callback', {\n              keyDownSnapshot: keyDownSnapshot\n            });\n            keyDownSnapshot.apply(editor);\n            editor.deleteBackward();\n            deleter = null;\n          }, {\n            onCancel: function onCancel() {\n              deleter = null;\n            }\n          });\n          return;\n        }\n\n        if (status === COMPOSING) {\n          var _window$getSelection2 = window.getSelection(),\n              _anchorNode = _window$getSelection2.anchorNode;\n\n          nodes.add(_anchorNode);\n          return;\n        } // Some keys like '.' are input without compositions. This happens\n        // in API28. It might be happening in API 27 as well. Check by typing\n        // `It me. No.` On a blank line.\n\n\n        if (ANDROID_API_VERSION === 28) {\n          debug('onInput:fallback');\n\n          var _window$getSelection3 = window.getSelection(),\n              _anchorNode2 = _window$getSelection3.anchorNode;\n\n          nodes.add(_anchorNode2);\n          window.requestAnimationFrame(function () {\n            debug('onInput:fallback:callback');\n            reconcile(window, editor, {\n              from: 'onInput:fallback'\n            });\n          });\n          return;\n        }\n\n        break;\n\n      default:\n        if (status === COMPOSING) return;\n        next();\n    }\n  }\n  /**\n   * On key down.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', {\n      event: event,\n      status: status,\n      e: pick(event, ['char', 'charCode', 'code', 'key', 'keyCode', 'keyIdentifier', 'keyLocation', 'location', 'nativeEvent', 'which'])\n    });\n    var window = getWindow(event.target);\n\n    switch (ANDROID_API_VERSION) {\n      // 1. We want to allow enter keydown to allows go through\n      // 2. We want to deny keydown, I think, when it fires before the composition\n      //    or something. Need to remember what it was.\n      case 25:\n        // in API25 prevent other keys to fix clicking a word and then\n        // selecting an alternate suggestion.\n        //\n        // NOTE:\n        // The `setSelectionFromDom` is to allow hitting `Enter` to work\n        // because the selection needs to be in the right place; however,\n        // for now we've removed the cancelling of `onSelect` and everything\n        // appears to be working. Not sure why we removed `onSelect` though\n        // in API25.\n        if (event.key === 'Enter') {\n          // const window = getWindow(event.target)\n          // const selection = window.getSelection()\n          // setSelectionFromDom(window, editor, selection)\n          next();\n        }\n\n        break;\n\n      case 26:\n      case 27:\n        if (event.key === 'Enter') {\n          debug('onKeyDown:enter', {});\n\n          if (deleter) {\n            // If a `deleter` exists which means there was an onInput with\n            // `deleteContentBackward` that hasn't fired yet, then we know\n            // this is one of the cases where we have to revert to before\n            // the split.\n            deleter.cancel();\n            event.preventDefault();\n            window.requestAnimationFrame(function () {\n              debug('onKeyDown:enter:callback');\n              compositionEndSnapshot.apply(editor);\n              editor.splitBlock();\n            });\n          } else {\n            event.preventDefault(); // If there is no deleter, all we have to do is prevent the\n            // action before applying or splitBlock. In this scenario, we\n            // have to grab the selection from the DOM.\n\n            var domSelection = window.getSelection();\n            var selection = getSelectionFromDOM(window, editor, domSelection);\n            editor.moveTo(selection.anchor.key, selection.anchor.offset);\n            editor.splitBlock();\n          }\n\n          return;\n        } // We need to take a snapshot of the current selection and the\n        // element before when the user hits the backspace key. This is because\n        // we only know if the user hit backspace if the `onInput` event that\n        // follows has an `inputType` of `deleteContentBackward`. At that time\n        // it's too late to stop the event.\n\n\n        keyDownSnapshot = new DomSnapshot(window, editor, {\n          before: true\n        }); // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n\n        break;\n\n      case 28:\n        {\n          if (event.key === 'Enter') {\n            debug('onKeyDown:enter');\n            event.preventDefault();\n            if (reconciler) reconciler.cancel();\n            if (deleter) deleter.cancel();\n            window.requestAnimationFrame(function () {\n              reconcile(window, editor, {\n                from: 'onKeyDown:enter'\n              });\n              editor.splitBlock();\n            });\n            return;\n          } // We need to take a snapshot of the current selection and the\n          // element before when the user hits the backspace key. This is because\n          // we only know if the user hit backspace if the `onInput` event that\n          // follows has an `inputType` of `deleteContentBackward`. At that time\n          // it's too late to stop the event.\n\n\n          keyDownSnapshot = new DomSnapshot(window, editor, {\n            before: true\n          });\n          debug('onKeyDown:snapshot', {\n            keyDownSnapshot: keyDownSnapshot\n          });\n        } // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n\n        break;\n\n      default:\n        if (status !== COMPOSING) {\n          next();\n        }\n\n    }\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', {\n      event: event,\n      status: status\n    });\n\n    switch (ANDROID_API_VERSION) {\n      // We don't want to have the selection move around in an onSelect because\n      // it happens after we press `enter` in the same transaction. This\n      // causes the cursor position to not be properly placed.\n      case 26:\n      case 27:\n      case 28:\n        var _window2 = getWindow(event.target);\n\n        fixSelectionInZeroWidthBlock(_window2);\n        break;\n\n      default:\n        break;\n    }\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onCompositionUpdate: onCompositionUpdate,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onSelect: onSelect\n  };\n}\n/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\n\nvar TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain'\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\n  if (Node.isNode(key)) {\n    key = key.key;\n  }\n\n  var el = win.document.querySelector('[data-key=\"' + key + '\"]');\n\n  if (!el) {\n    throw new Error('Unable to find a DOM node for \"' + key + '\". This is often because of forgetting to add `props.attributes` to a custom component.');\n  }\n\n  return el;\n}\n/**\n * COMPAT: if we are in <= IE11 and the selection contains\n * tables, `removeAllRanges()` will throw\n * \"unable to complete the operation due to error 800a025e\"\n *\n * @param {Selection} selection document selection\n */\n\n\nfunction removeAllRanges(selection) {\n  var doc = window.document;\n\n  if (doc && doc.body.createTextRange) {\n    // All IE but Edge\n    var range = doc.body.createTextRange();\n    range.collapse();\n    range.select();\n  } else {\n    selection.removeAllRanges();\n  }\n}\n\nvar FRAGMENT = TRANSFER_TYPES.FRAGMENT;\nvar HTML = TRANSFER_TYPES.HTML;\nvar TEXT = TRANSFER_TYPES.TEXT;\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor) {\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return undefined;\n  };\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.');\n  var window = getWindow(event.target);\n  var native = window.getSelection();\n  var value = editor.value;\n  var document = value.document,\n      fragment = value.fragment,\n      selection = value.selection;\n  var start = selection.start,\n      end = selection.end;\n  var startVoid = document.getClosestVoid(start.key, editor);\n  var endVoid = document.getClosestVoid(end.key, editor); // If the selection is collapsed, and it isn't inside a void node, abort.\n\n  if (native.isCollapsed && !startVoid) return; // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n\n  var encoded = Base64.serializeNode(fragment);\n  var range = native.getRangeAt(0);\n  var contents = range.cloneContents();\n  var attach = contents.childNodes[0]; // Make sure attach is a non-empty node, since empty nodes will not get copied\n\n  contents.childNodes.forEach(function (node) {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node;\n    }\n  }); // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n\n  if (endVoid) {\n    var r = range.cloneRange();\n    var node = findDOMNode(endVoid, window);\n    r.setEndAfter(node);\n    contents = r.cloneContents();\n  } // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n\n\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild;\n  } // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n\n\n  [].slice.call(contents.querySelectorAll(ZERO_WIDTH_SELECTOR)).forEach(function (zw) {\n    var isNewline = zw.getAttribute(ZERO_WIDTH_ATTRIBUTE) === 'n';\n    zw.textContent = isNewline ? '\\n' : '';\n  }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n  if (attach.nodeType === 3) {\n    var span = window.document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n\n    span.style.whiteSpace = 'pre';\n    span.appendChild(attach);\n    contents.appendChild(span);\n    attach = span;\n  }\n\n  attach.setAttribute('data-slate-fragment', encoded); //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n\n  var valFromSelection = Value.create({\n    document: fragment\n  });\n  var plainText = Plain.serialize(valFromSelection); // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n\n  var div = window.document.createElement('div');\n  div.appendChild(contents); // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault();\n    event.clipboardData.setData(TEXT, plainText);\n    event.clipboardData.setData(FRAGMENT, encoded);\n    event.clipboardData.setData(HTML, div.innerHTML);\n    callback();\n    return;\n  } // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n\n\n  var editorEl = event.target.closest('[data-slate-editor]');\n  div.setAttribute('contenteditable', true);\n  div.style.position = 'absolute';\n  div.style.left = '-9999px';\n  editorEl.appendChild(div);\n  native.selectAllChildren(div); // Revert to the previous selection right after copying.\n\n  window.requestAnimationFrame(function () {\n    editorEl.removeChild(div);\n    removeAllRanges(native);\n    native.addRange(range);\n    callback();\n  });\n}\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\n\nfunction findNode(element, editor) {\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n  var closest = element.closest('[data-key]');\n  if (!closest) return null;\n  var key = closest.getAttribute('data-key');\n  if (!key) return null;\n  var value = editor.value;\n  var document = value.document;\n  var node = document.getNode(key);\n  return node || null;\n}\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\n\nfunction getEventRange(event, editor) {\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var _event = event,\n      x = _event.clientX,\n      y = _event.clientY,\n      target = _event.target;\n  if (x == null || y == null) return null;\n  var value = editor.value;\n  var document = value.document;\n  var node = findNode(target, editor);\n  if (!node) return null; // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n\n  if (editor.query('isVoid', node)) {\n    var rect = target.getBoundingClientRect();\n    var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n    var text = node.getFirstText();\n\n    var _range = document.createRange();\n\n    if (isPrevious) {\n      var previousText = document.getPreviousText(text.key);\n\n      if (previousText) {\n        return _range.moveToEndOfNode(previousText);\n      }\n    }\n\n    var nextText = document.getNextText(text.key);\n    return nextText ? _range.moveToStartOfNode(nextText) : null;\n  } // Else resolve a range from the caret position where the drop occured.\n\n\n  var window = getWindow(target);\n  var native = void 0; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y);\n  } else if (window.document.caretPositionFromPoint) {\n    var position = window.document.caretPositionFromPoint(x, y);\n    native = window.document.createRange();\n    native.setStart(position.offsetNode, position.offset);\n    native.setEnd(position.offsetNode, position.offset);\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange();\n\n    try {\n      native.moveToPoint(x, y);\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null;\n    }\n  } // Resolve a Slate range from the DOM range.\n\n\n  var range = findRange(native, editor);\n  if (!range) return null;\n  return range;\n}\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\n\nvar FRAGMENT$1 = TRANSFER_TYPES.FRAGMENT;\nvar HTML$1 = TRANSFER_TYPES.HTML;\nvar NODE = TRANSFER_TYPES.NODE;\nvar RICH = TRANSFER_TYPES.RICH;\nvar TEXT$1 = TRANSFER_TYPES.TEXT;\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/;\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n  var fragment = getType(transfer, FRAGMENT$1);\n  var node = getType(transfer, NODE);\n  var html = getType(transfer, HTML$1);\n  var rich = getType(transfer, RICH);\n  var text = getType(transfer, TEXT$1);\n  var files = void 0; // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n\n  if (!fragment && html && ~html.indexOf(' data-slate-fragment=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  } // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n\n\n  if (text) {\n    var embeddedTypes = getEmbeddedTypes(text);\n    if (embeddedTypes[FRAGMENT$1]) fragment = embeddedTypes[FRAGMENT$1];\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE];\n    if (embeddedTypes[TEXT$1]) text = embeddedTypes[TEXT$1];\n  } // Decode a fragment or node if they exist.\n\n\n  if (fragment) fragment = Base64.deserializeNode(fragment);\n  if (node) node = Base64.deserializeNode(node); // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items).map(function (item) {\n        return item.kind === 'file' ? item.getAsFile() : null;\n      }).filter(function (exists) {\n        return exists;\n      });\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } // Determine the type of the data.\n\n\n  var data = {\n    files: files,\n    fragment: fragment,\n    html: html,\n    node: node,\n    rich: rich,\n    text: text\n  };\n  data.type = getTransferType(data);\n  return data;\n}\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\n\nfunction getEmbeddedTypes(text) {\n  var prefix = 'SLATE-DATA-EMBED::';\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return {\n      TEXT: text\n    };\n  } // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n\n\n  try {\n    return JSON.parse(text.substring(prefix.length));\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.');\n  }\n}\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node'; // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n  if (data.files && data.files.length) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT$1 ? transfer.getData('Text') || null : null;\n  } // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n\n\n  var types = Array.from(transfer.types);\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\n}\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\n\nvar TEXT$2 = TRANSFER_TYPES.TEXT;\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  var mime = TRANSFER_TYPES[type.toUpperCase()];\n\n  if (!mime) {\n    throw new Error('Cannot set unknown transfer type \"' + mime + '\".');\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n\n  try {\n    transfer.setData(mime, content); // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n\n    transfer.setData('text', transfer.getData('text'));\n  } catch (err) {\n    var prefix = 'SLATE-DATA-EMBED::';\n    var text = transfer.getData(TEXT$2);\n    var obj = {}; // If the existing plain text data is prefixed, it's Slate JSON data.\n\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length));\n      } catch (e) {\n        throw new Error('Failed to parse Slate data from `DataTransfer` object.');\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT$2] = text;\n    }\n\n    obj[mime] = content;\n    var string = '' + prefix + JSON.stringify(obj);\n    transfer.setData(TEXT$2, string);\n  }\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$1 = Debug('slate:after');\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin() {\n  var isDraggingInternally = null;\n  var isMouseDown = false;\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var value = editor.value;\n    var isSynthetic = !!event.nativeEvent; // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n\n    if (isSynthetic) {\n      event.preventDefault();\n      editor.insertText(event.data);\n      return next();\n    } // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n\n\n    var _event$getTargetRange = event.getTargetRanges(),\n        _event$getTargetRange2 = slicedToArray(_event$getTargetRange, 1),\n        targetRange = _event$getTargetRange2[0];\n\n    if (!targetRange) return next();\n    debug$1('onBeforeInput', {\n      event: event\n    });\n    event.preventDefault();\n    var document = value.document,\n        selection = value.selection;\n    var range = findRange(targetRange, editor);\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        {\n          editor.deleteAtRange(range);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          editor.deleteWordBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          editor.deleteWordForwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward':\n        {\n          editor.deleteLineBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward':\n        {\n          editor.deleteLineForwardAtRange(range);\n          break;\n        }\n\n      case 'insertLineBreak':\n      case 'insertParagraph':\n        {\n          var hasVoidParent = document.hasVoidParent(selection.start.path, editor);\n\n          if (hasVoidParent) {\n            editor.moveToStartOfNextText();\n          } else {\n            editor.splitBlockAtRange(range);\n          }\n\n          break;\n        }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          // COMPAT: `data` should have the text for the `insertText` input type\n          // and `dataTransfer` should have the text for the\n          // `insertReplacementText` input type, but Safari uses `insertText` for\n          // spell check replacements and sets `data` to `null`. (2018/08/09)\n          var text = event.data == null ? event.dataTransfer.getData('text/plain') : event.data;\n          if (text == null) break;\n          editor.insertTextAtRange(range, text, selection.marks); // If the text was successfully inserted, and the selection had marks\n          // on it, unset the selection's marks.\n\n          if (selection.marks && value.document !== editor.value.document) {\n            editor.select({\n              marks: null\n            });\n          }\n\n          break;\n        }\n    }\n\n    next();\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBlur(event, editor, next) {\n    debug$1('onBlur', {\n      event: event\n    });\n    editor.blur();\n    next();\n  }\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next();\n    var value = editor.value;\n    var document = value.document;\n    var node = findNode(event.target, editor);\n    if (!node) return next();\n    debug$1('onClick', {\n      event: event\n    });\n    var ancestors = document.getAncestors(node.key);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node);\n    }\n\n    next();\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCopy(event, editor, next) {\n    debug$1('onCopy', {\n      event: event\n    });\n    cloneFragment(event, editor);\n    next();\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCut(event, editor, next) {\n    debug$1('onCut', {\n      event: event\n    }); // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n\n    cloneFragment(event, editor, function () {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      var value = editor.value;\n      var endBlock = value.endBlock,\n          endInline = value.endInline,\n          selection = value.selection;\n      var isCollapsed = selection.isCollapsed;\n      var isVoidBlock = endBlock && editor.isVoid(endBlock) && isCollapsed;\n      var isVoidInline = endInline && editor.isVoid(endInline) && isCollapsed;\n\n      if (isVoidBlock) {\n        editor.removeNodeByKey(endBlock.key);\n      } else if (isVoidInline) {\n        editor.removeNodeByKey(endInline.key);\n      } else {\n        editor.delete();\n      }\n    });\n    next();\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnd(event, editor, next) {\n    debug$1('onDragEnd', {\n      event: event\n    });\n    isDraggingInternally = null;\n    next();\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragStart(event, editor, next) {\n    debug$1('onDragStart', {\n      event: event\n    });\n    isDraggingInternally = true;\n    var value = editor.value;\n    var document = value.document;\n    var node = findNode(event.target, editor);\n    var ancestors = document.getAncestors(node.key);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n    var selectionIncludesNode = value.blocks.some(function (block) {\n      return block.key === node.key;\n    }); // If a void block is dragged and is not selected, select it (necessary for local drags).\n\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node);\n    }\n\n    var fragment = editor.value.fragment;\n    var encoded = Base64.serializeNode(fragment);\n    setEventTransfer(event, 'fragment', encoded);\n    next();\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDrop(event, editor, next) {\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var window = getWindow(event.target);\n    var target = getEventRange(event, editor);\n    if (!target) return next();\n    debug$1('onDrop', {\n      event: event\n    });\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n    editor.focus(); // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n\n    if (isDraggingInternally && selection.end.key === target.end.key && selection.end.offset < target.end.offset) {\n      target = target.moveForward(selection.start.key === selection.end.key ? 0 - selection.end.offset + selection.start.offset : 0 - selection.end.offset);\n    }\n\n    if (isDraggingInternally) {\n      editor.delete();\n    }\n\n    editor.select(target);\n\n    if (type === 'text' || type === 'html') {\n      var _target = target,\n          anchor = _target.anchor;\n      var hasVoidParent = document.hasVoidParent(anchor.key, editor);\n\n      if (hasVoidParent) {\n        var n = document.getNode(anchor.key);\n\n        while (hasVoidParent) {\n          n = document.getNextText(n.key);\n          if (!n) break;\n          hasVoidParent = document.hasVoidParent(n.key, editor);\n        }\n\n        if (n) editor.moveToStartOfNode(n);\n      }\n\n      if (text) {\n        text.split('\\n').forEach(function (line, i) {\n          if (i > 0) editor.splitBlock();\n          editor.insertText(line);\n        });\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    } // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n\n\n    var focusNode = document.getNode(target.focus.key);\n    var el = findDOMNode(focusNode, window);\n\n    if (el) {\n      el.dispatchEvent(new MouseEvent('mouseup', {\n        view: window,\n        bubbles: true,\n        cancelable: true\n      }));\n    }\n\n    next();\n  }\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onFocus(event, editor, next) {\n    debug$1('onFocus', {\n      event: event\n    }); // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n\n    if (isMouseDown && !IS_IE && !IS_EDGE) {\n      editor.deselect().focus();\n    } else {\n      editor.focus();\n    }\n\n    next();\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    debug$1('onInput');\n    var window = getWindow(event.target); // Get the selection point.\n\n    var selection = window.getSelection();\n    var anchorNode = selection.anchorNode;\n    setTextFromDomNode(window, editor, anchorNode);\n    setSelectionFromDOM(window, editor, selection);\n    next();\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    debug$1('onKeyDown', {\n      event: event\n    });\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var hasVoidParent = document.hasVoidParent(selection.start.path, editor); // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent ? editor.moveToStartOfNextText() : editor.splitBlock();\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward();\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward();\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward();\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward();\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward();\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward();\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo();\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo();\n    } // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n\n\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveToStartOfBlock();\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault();\n      return editor.moveToEndOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToStartOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToEndOfBlock();\n    } // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n\n\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart();\n      }\n\n      return editor.moveBackward();\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd();\n      }\n\n      return editor.moveForward();\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault();\n      return editor.moveWordBackward();\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault();\n      return editor.moveWordForward();\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      var previousText = value.previousText,\n          startText = value.startText;\n      var isPreviousInVoid = previousText && document.hasVoidParent(previousText.key, editor);\n\n      if (hasVoidParent || isPreviousInVoid || startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusBackward();\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      var nextText = value.nextText,\n          _startText = value.startText;\n      var isNextInVoid = nextText && document.hasVoidParent(nextText.key, editor);\n\n      if (hasVoidParent || isNextInVoid || _startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusForward();\n      }\n    }\n\n    next();\n  }\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onMouseDown(event, editor, next) {\n    debug$1('onMouseDown', {\n      event: event\n    });\n    isMouseDown = true;\n    next();\n  }\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onMouseUp(event, editor, next) {\n    debug$1('onMouseUp', {\n      event: event\n    });\n    isMouseDown = false;\n    next();\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onPaste(event, editor, next) {\n    debug$1('onPaste', {\n      event: event\n    });\n    var value = editor.value;\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next();\n      var document = value.document,\n          selection = value.selection,\n          startBlock = value.startBlock;\n      if (editor.isVoid(startBlock)) return next();\n      var defaultBlock = startBlock;\n      var defaultMarks = document.getInsertMarksAtRange(selection);\n      var frag = Plain.deserialize(text, {\n        defaultBlock: defaultBlock,\n        defaultMarks: defaultMarks\n      }).document;\n      editor.insertFragment(frag);\n    }\n\n    next();\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    debug$1('onSelect', {\n      event: event\n    });\n    var window = getWindow(event.target);\n    var selection = window.getSelection();\n    setSelectionFromDOM(window, editor, selection); // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n\n    isMouseDown = false;\n    next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onPaste: onPaste,\n    onSelect: onSelect\n  };\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$2 = Debug('slate:before');\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  var activeElement = null;\n  var compositionCount = 0;\n  var isComposing = false;\n  var isCopying = false;\n  var isDragging = false;\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var isSynthetic = !!event.nativeEvent;\n    if (editor.readOnly) return; // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return;\n    debug$2('onBeforeInput', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n    var relatedTarget = event.relatedTarget,\n        target = event.target;\n    var window = getWindow(target); // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n\n    if (activeElement === window.document.activeElement) return; // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n\n    if (relatedTarget) {\n      var el = ReactDOM.findDOMNode(editor); // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n\n      if (relatedTarget === el) return; // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n\n      if (relatedTarget.hasAttribute('data-slate-spacer')) return; // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n\n      var node = findNode(relatedTarget, editor);\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) return;\n    }\n\n    debug$2('onBlur', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCompositionEnd(event, editor, next) {\n    var n = compositionCount; // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n\n    window.requestAnimationFrame(function () {\n      if (compositionCount > n) return;\n      isComposing = false;\n    });\n    debug$2('onCompositionEnd', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onClick(event, editor, next) {\n    debug$2('onClick', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true;\n    compositionCount++;\n    var value = editor.value;\n    var selection = value.selection;\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete();\n    }\n\n    debug$2('onCompositionStart', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCopy(event, editor, next) {\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$2('onCopy', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return;\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$2('onCut', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false;\n    debug$2('onDragEnd', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnter(event, editor, next) {\n    debug$2('onDragEnter', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragExit(event, editor, next) {\n    debug$2('onDragExit', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragLeave(event, editor, next) {\n    debug$2('onDragLeave', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    var node = findNode(event.target, editor);\n    if (editor.isVoid(node)) event.preventDefault(); // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n\n    if (IS_IE) {\n      event.preventDefault();\n    } // If a drag is already in progress, don't do this again.\n\n\n    if (!isDragging) {\n      isDragging = true; // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move';\n      }\n    }\n\n    debug$2('onDragOver', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragStart(event, editor, next) {\n    isDragging = true;\n    debug$2('onDragStart', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return; // Prevent default so the DOM's value isn't corrupted.\n\n    event.preventDefault();\n    debug$2('onDrop', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n    var el = ReactDOM.findDOMNode(editor); // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement; // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n\n    if (IS_FIREFOX && event.target !== el) {\n      el.focus();\n      return;\n    }\n\n    debug$2('onFocus', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    if (isComposing) return;\n    if (editor.value.selection.isBlurred) return;\n    debug$2('onInput', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return; // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault();\n      return;\n    } // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n\n\n    if (!IS_IOS && (Hotkeys.isBold(event) || Hotkeys.isDeleteBackward(event) || Hotkeys.isDeleteForward(event) || Hotkeys.isDeleteLineBackward(event) || Hotkeys.isDeleteLineForward(event) || Hotkeys.isDeleteWordBackward(event) || Hotkeys.isDeleteWordForward(event) || Hotkeys.isItalic(event) || Hotkeys.isRedo(event) || Hotkeys.isSplitBlock(event) || Hotkeys.isTransposeCharacter(event) || Hotkeys.isUndo(event))) {\n      event.preventDefault();\n    }\n\n    debug$2('onKeyDown', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return; // Prevent defaults so the DOM state isn't corrupted.\n\n    event.preventDefault();\n    debug$2('onPaste', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return;\n    if (isComposing) return;\n    if (editor.readOnly) return; // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement;\n    debug$2('onSelect', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragEnter: onDragEnter,\n    onDragExit: onDragExit,\n    onDragLeave: onDragLeave,\n    onDragOver: onDragOver,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect\n  };\n}\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\n\nfunction DOMPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins; // Add Android specific handling separately before it gets to the other\n  // plugins because it is specific (other browser don't need it) and finicky\n  // (it has to come before other plugins to work).\n\n  var beforeBeforePlugins = IS_ANDROID ? [AndroidPlugin()] : [];\n  var beforePlugin = BeforePlugin();\n  var afterPlugin = AfterPlugin();\n  return [].concat(beforeBeforePlugins, [beforePlugin], toConsumableArray(plugins), [afterPlugin]);\n}\n/**\n * Debugger.\n *\n * @type {Function}\n */\n\n\nvar debug$3 = Debug('slate:leaves');\n/**\n * Leaf.\n *\n * @type {Component}\n */\n\nvar Leaf = function (_React$Component) {\n  inherits(Leaf, _React$Component);\n\n  function Leaf() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Leaf);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Leaf.__proto__ || Object.getPrototypeOf(Leaf)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Leaf, [{\n    key: 'shouldComponentUpdate',\n\n    /**\n     * Should component update?\n     *\n     * @param {Object} props\n     * @return {Boolean}\n     */\n    value: function shouldComponentUpdate(props) {\n      // If any of the regular properties have changed, re-render.\n      if (props.index !== this.props.index || props.marks !== this.props.marks || props.text !== this.props.text || props.parent !== this.props.parent) {\n        return true;\n      } // Otherwise, don't update.\n\n\n      return false;\n    }\n    /**\n     * Render the leaf.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      this.debug('render', this);\n      var _props = this.props,\n          node = _props.node,\n          index = _props.index;\n      var offsetKey = OffsetKey.stringify({\n        key: node.key,\n        index: index\n      });\n      return React.createElement('span', {\n        'data-slate-leaf': true,\n        'data-offset-key': offsetKey\n      }, this.renderMarks());\n    }\n    /**\n     * Render all of the leaf's mark components.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderMarks',\n    value: function renderMarks() {\n      var _props2 = this.props,\n          marks = _props2.marks,\n          node = _props2.node,\n          offset = _props2.offset,\n          text = _props2.text,\n          editor = _props2.editor;\n      var leaf = this.renderText();\n      var attributes = {\n        'data-slate-mark': true\n      };\n      return marks.reduce(function (children, mark) {\n        var props = {\n          editor: editor,\n          mark: mark,\n          marks: marks,\n          node: node,\n          offset: offset,\n          text: text,\n          children: children,\n          attributes: attributes\n        };\n        var element = editor.run('renderMark', props);\n        return element || children;\n      }, leaf);\n    }\n    /**\n     * Render the text content of the leaf, accounting for browsers.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderText',\n    value: function renderText() {\n      var _props3 = this.props,\n          block = _props3.block,\n          node = _props3.node,\n          editor = _props3.editor,\n          parent = _props3.parent,\n          text = _props3.text,\n          index = _props3.index,\n          leaves = _props3.leaves; // COMPAT: Render text inside void nodes with a zero-width space.\n      // So the node can contain selection but the text is not visible.\n\n      if (editor.query('isVoid', parent)) {\n        return React.createElement('span', {\n          'data-slate-zero-width': 'z',\n          'data-slate-length': parent.text.length\n        }, '\\uFEFF');\n      } // COMPAT: If this is the last text node in an empty block, render a zero-\n      // width space that will convert into a line break when copying and pasting\n      // to support expected plain text.\n\n\n      if (text === '' && parent.object === 'block' && parent.text === '' && parent.nodes.last() === node) {\n        return React.createElement('span', {\n          'data-slate-zero-width': 'n',\n          'data-slate-length': 0\n        }, '\\uFEFF', React.createElement('br', null));\n      } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n      // node, so we render a zero-width space so that the selection can be\n      // inserted next to it still.\n\n\n      if (text === '') {\n        return React.createElement('span', {\n          'data-slate-zero-width': 'z',\n          'data-slate-length': 0\n        }, '\\uFEFF');\n      } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n      // so we need to add an extra trailing new lines to prevent that.\n\n\n      var lastText = block.getLastText();\n      var lastChar = text.charAt(text.length - 1);\n      var isLastText = node === lastText;\n      var isLastLeaf = index === leaves.size - 1;\n      if (isLastText && isLastLeaf && lastChar === '\\n') return React.createElement('span', {\n        'data-slate-content': true\n      }, text + '\\n'); // Otherwise, just return the content.\n\n      return React.createElement('span', {\n        'data-slate-content': true\n      }, text);\n    }\n  }]);\n  return Leaf;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nLeaf.propTypes = {\n  block: SlateTypes.block.isRequired,\n  editor: Types.object.isRequired,\n  index: Types.number.isRequired,\n  leaves: SlateTypes.leaves.isRequired,\n  marks: SlateTypes.marks.isRequired,\n  node: SlateTypes.node.isRequired,\n  offset: Types.number.isRequired,\n  parent: SlateTypes.node.isRequired,\n  text: Types.string.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    debug$3.apply(undefined, [message, _this2.props.node.key + '-' + _this2.props.index].concat(args));\n  };\n};\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$4 = Debug('slate:node');\n/**\n * Text.\n *\n * @type {Component}\n */\n\nvar Text = function (_React$Component) {\n  inherits(Text, _React$Component);\n\n  function Text() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Text);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Text.__proto__ || Object.getPrototypeOf(Text)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$1.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default prop types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n\n  createClass(Text, [{\n    key: 'render',\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _this2 = this;\n\n      this.debug('render', this);\n      var _props = this.props,\n          decorations = _props.decorations,\n          editor = _props.editor,\n          node = _props.node,\n          style = _props.style;\n      var value = editor.value;\n      var document = value.document;\n      var key = node.key;\n      var decs = decorations.filter(function (d) {\n        var start = d.start,\n            end = d.end; // If either of the decoration's keys match, include it.\n\n        if (start.key === key || end.key === key) return true; // Otherwise, if the decoration is in a single node, it's not ours.\n\n        if (start.key === end.key) return false;\n        var path = document.assertPath(key);\n        var startPath = start.path || document.assertPath(start.key);\n        var endPath = end.path || document.assertPath(end.key); // If the node's path is before the start path, ignore it.\n\n        if (PathUtils.compare(path, startPath) === -1) return false; // If the node's path is after the end path, ignore it.\n\n        if (PathUtils.compare(path, endPath) === 1) return false; // Otherwise, include it.\n\n        return true;\n      }); // PERF: Take advantage of cache by avoiding arguments\n\n      var leaves = decs.size === 0 ? node.getLeaves() : node.getLeaves(decs);\n      var offset = 0;\n      var children = leaves.map(function (leaf, i) {\n        var child = _this2.renderLeaf(leaves, leaf, i, offset);\n\n        offset += leaf.text.length;\n        return child;\n      });\n      return React.createElement('span', {\n        'data-key': key,\n        style: style\n      }, children);\n    }\n    /**\n     * Render a single leaf given a `leaf` and `offset`.\n     *\n     * @param {List<Leaf>} leaves\n     * @param {Leaf} leaf\n     * @param {Number} index\n     * @param {Number} offset\n     * @return {Element} leaf\n     */\n\n  }]);\n  return Text;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nText.propTypes = {\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  style: Types.object\n};\nText.defaultProps = {\n  style: null\n};\n\nvar _initialiseProps$1 = function _initialiseProps() {\n  var _this3 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this3.props.node;\n    var key = node.key;\n    debug$4.apply(undefined, [message, key + ' (text)'].concat(args));\n  };\n\n  this.shouldComponentUpdate = function (nextProps) {\n    var props = _this3.props;\n    var n = nextProps;\n    var p = props; // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n\n    if (n.node !== p.node) return true; // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n\n    if (n.parent.object === 'block') {\n      var pLast = p.parent.nodes.last();\n      var nLast = n.parent.nodes.last();\n      if (p.node === pLast && n.node !== nLast) return true;\n    } // Re-render if the current decorations have changed.\n\n\n    if (!n.decorations.equals(p.decorations)) return true; // Otherwise, don't update.\n\n    return false;\n  };\n\n  this.renderLeaf = function (leaves, leaf, index, offset) {\n    var _props2 = _this3.props,\n        block = _props2.block,\n        node = _props2.node,\n        parent = _props2.parent,\n        editor = _props2.editor;\n    var text = leaf.text,\n        marks = leaf.marks;\n    return React.createElement(Leaf, {\n      key: node.key + '-' + index,\n      block: block,\n      editor: editor,\n      index: index,\n      marks: marks,\n      node: node,\n      offset: offset,\n      parent: parent,\n      leaves: leaves,\n      text: text\n    });\n  };\n};\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$5 = Debug('slate:void');\n/**\n * Void.\n *\n * @type {Component}\n */\n\nvar Void = function (_React$Component) {\n  inherits(Void, _React$Component);\n\n  function Void() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Void);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$2.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Void, [{\n    key: 'render',\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var props = this.props;\n      var children = props.children,\n          node = props.node,\n          readOnly = props.readOnly;\n      var Tag = node.object === 'block' ? 'div' : 'span';\n      var style = {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      };\n      var spacer = React.createElement(Tag, {\n        'data-slate-spacer': true,\n        style: style\n      }, this.renderText());\n      var content = React.createElement(Tag, {\n        contentEditable: readOnly ? null : false\n      }, children);\n      this.debug('render', {\n        props: props\n      });\n      return React.createElement(Tag, {\n        'data-slate-void': true,\n        'data-key': node.key,\n        contentEditable: readOnly || node.object === 'block' ? null : false\n      }, readOnly ? null : spacer, content);\n    }\n    /**\n     * Render the void node's text node, which will catch the cursor when it the\n     * void node is navigated to with the arrow keys.\n     *\n     * Having this text node there means the browser continues to manage the\n     * selection natively, so it keeps track of the right offset when moving\n     * across the block.\n     *\n     * @return {Element}\n     */\n\n  }]);\n  return Void;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nVoid.propTypes = {\n  block: SlateTypes.block,\n  children: Types.any.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  readOnly: Types.bool.isRequired\n};\n\nvar _initialiseProps$2 = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        type = node.type;\n    var id = key + ' (' + type + ')';\n    debug$5.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.renderText = function () {\n    var _props = _this2.props,\n        block = _props.block,\n        decorations = _props.decorations,\n        node = _props.node,\n        readOnly = _props.readOnly,\n        editor = _props.editor;\n    var child = node.getFirstText();\n    return React.createElement(Text, {\n      block: node.object === 'block' ? node : block,\n      decorations: decorations,\n      editor: editor,\n      key: child.key,\n      node: child,\n      parent: node,\n      readOnly: readOnly\n    });\n  };\n};\n/**\n * Split the decorations in lists of relevant decorations for each child.\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<List<Decoration>>}\n */\n\n\nfunction getChildrenDecorations(node, decorations) {\n  var activeDecorations = Set().asMutable();\n  var childrenDecorations = [];\n  orderChildDecorations(node, decorations).forEach(function (item) {\n    if (item.isRangeStart) {\n      // Item is a decoration start\n      activeDecorations.add(item.decoration);\n    } else if (item.isRangeEnd) {\n      // item is a decoration end\n      activeDecorations.remove(item.decoration);\n    } else {\n      // Item is a child node\n      childrenDecorations.push(activeDecorations.toList());\n    }\n  });\n  return childrenDecorations;\n}\n/**\n * Orders the children of provided node and its decoration endpoints (start, end)\n * so that decorations can be passed only to relevant children (see use in Node.render())\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<Item>}\n *\n * where type Item =\n * {\n *   child: Node,\n *   // Index of the child in its parent\n *   index: number\n * }\n * or {\n *   // True if this represents the start of the given decoration\n *   isRangeStart: boolean,\n *   // True if this represents the end of the given decoration\n *   isRangeEnd: boolean,\n *   decoration: Range\n * }\n */\n\n\nfunction orderChildDecorations(node, decorations) {\n  if (decorations.isEmpty()) {\n    return node.nodes.toArray().map(function (child, index) {\n      return {\n        child: child,\n        index: index\n      };\n    });\n  } // Map each key to its global order\n\n\n  var keyOrders = defineProperty({}, node.key, 0);\n  var globalOrder = 1;\n  node.forEachDescendant(function (child) {\n    keyOrders[child.key] = globalOrder;\n    globalOrder = globalOrder + 1;\n  });\n  var childNodes = node.nodes.toArray();\n  var endPoints = childNodes.map(function (child, index) {\n    return {\n      child: child,\n      index: index,\n      order: keyOrders[child.key]\n    };\n  });\n  decorations.forEach(function (decoration) {\n    // Range start.\n    // A rangeStart should be before the child containing its startKey, in order\n    // to consider it active before going down the child.\n    var startKeyOrder = keyOrders[decoration.start.key];\n    var containingChildOrder = startKeyOrder === undefined ? 0 : getContainingChildOrder(childNodes, keyOrders, startKeyOrder);\n    endPoints.push({\n      isRangeStart: true,\n      order: containingChildOrder - 0.5,\n      decoration: decoration\n    }); // Range end.\n\n    var endKeyOrder = (keyOrders[decoration.end.key] || globalOrder) + 0.5;\n    endPoints.push({\n      isRangeEnd: true,\n      order: endKeyOrder,\n      decoration: decoration\n    });\n  });\n  return endPoints.sort(function (a, b) {\n    return a.order > b.order ? 1 : -1;\n  });\n}\n/*\n * Returns the key order of the child right before the given order.\n */\n\n\nfunction getContainingChildOrder(children, keyOrders, order) {\n  // Find the first child that is after the given key\n  var nextChildIndex = children.findIndex(function (child) {\n    return order < keyOrders[child.key];\n  });\n\n  if (nextChildIndex <= 0) {\n    return 0;\n  }\n\n  var containingChild = children[nextChildIndex - 1];\n  return keyOrders[containingChild.key];\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$6 = Debug('slate:node');\n/**\n * Node.\n *\n * @type {Component}\n */\n\nvar Node$1 = function (_React$Component) {\n  inherits(Node$$1, _React$Component);\n\n  function Node$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Node$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Node$$1.__proto__ || Object.getPrototypeOf(Node$$1)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$3.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Node$$1, [{\n    key: 'shouldComponentUpdate',\n\n    /**\n     * Should the node update?\n     *\n     * @param {Object} nextProps\n     * @param {Object} value\n     * @return {Boolean}\n     */\n    value: function shouldComponentUpdate(nextProps) {\n      var props = this.props;\n      var editor = props.editor;\n      var shouldUpdate = editor.run('shouldNodeComponentUpdate', props, nextProps);\n      var n = nextProps;\n      var p = props; // If the `Component` has a custom logic to determine whether the component\n      // needs to be updated or not, return true if it returns true. If it returns\n      // false, we need to ignore it, because it shouldn't be allowed it.\n\n      if (shouldUpdate != null) {\n        if (shouldUpdate) {\n          return true;\n        }\n\n        warning(shouldUpdate !== false, \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\");\n      } // If the `readOnly` status has changed, re-render in case there is any\n      // user-land logic that depends on it, like nested editable contents.\n\n\n      if (n.readOnly !== p.readOnly) return true; // If the node has changed, update. PERF: There are cases where it will have\n      // changed, but it's properties will be exactly the same (eg. copy-paste)\n      // which this won't catch. But that's rare and not a drag on performance, so\n      // for simplicity we just let them through.\n\n      if (n.node !== p.node) return true; // If the selection value of the node or of some of its children has changed,\n      // re-render in case there is any user-land logic depends on it to render.\n      // if the node is selected update it, even if it was already selected: the\n      // selection value of some of its children could have been changed and they\n      // need to be rendered again.\n\n      if (n.isSelected || p.isSelected) return true;\n      if (n.isFocused || p.isFocused) return true; // If the decorations have changed, update.\n\n      if (!n.decorations.equals(p.decorations)) return true; // Otherwise, don't update.\n\n      return false;\n    }\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      this.debug('render', this);\n      var _props = this.props,\n          editor = _props.editor,\n          isSelected = _props.isSelected,\n          isFocused = _props.isFocused,\n          node = _props.node,\n          decorations = _props.decorations,\n          parent = _props.parent,\n          readOnly = _props.readOnly;\n      var value = editor.value;\n      var selection = value.selection;\n      var indexes = node.getSelectionIndexes(selection, isSelected);\n      var decs = decorations.concat(node.getDecorations(editor));\n      var childrenDecorations = getChildrenDecorations(node, decs);\n      var children = [];\n      node.nodes.forEach(function (child, i) {\n        var isChildSelected = !!indexes && indexes.start <= i && i < indexes.end;\n        children.push(_this2.renderNode(child, isChildSelected, childrenDecorations[i]));\n      }); // Attributes that the developer must mix into the element in their\n      // custom node renderer component.\n\n      var attributes = {\n        'data-key': node.key // If it's a block node with inline children, add the proper `dir` attribute\n        // for text direction.\n\n      };\n\n      if (node.isLeafBlock()) {\n        var direction = node.getTextDirection();\n        if (direction === 'rtl') attributes.dir = 'rtl';\n      }\n\n      var props = {\n        key: node.key,\n        editor: editor,\n        isFocused: isFocused,\n        isSelected: isSelected,\n        node: node,\n        parent: parent,\n        readOnly: readOnly\n      };\n      var element = editor.run('renderNode', _extends({}, props, {\n        attributes: attributes,\n        children: children\n      }));\n      return editor.query('isVoid', node) ? React.createElement(Void, this.props, element) : element;\n    }\n    /**\n     * Render a `child` node.\n     *\n     * @param {Node} child\n     * @param {Boolean} isSelected\n     * @param {Array<Decoration>} decorations\n     * @return {Element}\n     */\n\n  }]);\n  return Node$$1;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nNode$1.propTypes = {\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  isFocused: Types.bool.isRequired,\n  isSelected: Types.bool.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  readOnly: Types.bool.isRequired\n};\n\nvar _initialiseProps$3 = function _initialiseProps() {\n  var _this3 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this3.props.node;\n    var key = node.key,\n        type = node.type;\n    debug$6.apply(undefined, [message, key + ' (' + type + ')'].concat(args));\n  };\n\n  this.renderNode = function (child, isSelected, decorations) {\n    var _props2 = _this3.props,\n        block = _props2.block,\n        editor = _props2.editor,\n        node = _props2.node,\n        readOnly = _props2.readOnly,\n        isFocused = _props2.isFocused;\n    var Component = child.object === 'text' ? Text : Node$1;\n    return React.createElement(Component, {\n      block: node.object === 'block' ? node : block,\n      decorations: decorations,\n      editor: editor,\n      isSelected: isSelected,\n      isFocused: isFocused && isSelected,\n      key: child.key,\n      node: child,\n      parent: node,\n      readOnly: readOnly\n    });\n  };\n};\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\n\nfunction findDOMPoint(point) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  var el = findDOMNode(point.key, win);\n  var start = 0; // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n\n  var texts = Array.from(el.querySelectorAll('[data-slate-content], [data-slate-zero-width]'));\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var text = _step.value;\n      var node = text.childNodes[0];\n      var domLength = node.textContent.length;\n      var slateLength = domLength;\n\n      if (text.hasAttribute('data-slate-length')) {\n        slateLength = parseInt(text.getAttribute('data-slate-length'), 10);\n      }\n\n      var end = start + slateLength;\n\n      if (point.offset <= end) {\n        var offset = Math.min(domLength, Math.max(0, point.offset - start));\n        return {\n          node: node,\n          offset: offset\n        };\n      }\n\n      start = end;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\n\nfunction findDOMRange(range) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  var anchor = range.anchor,\n      focus = range.focus,\n      isBackward$$1 = range.isBackward,\n      isCollapsed = range.isCollapsed;\n  var domAnchor = findDOMPoint(anchor, win);\n  var domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win);\n  if (!domAnchor || !domFocus) return null;\n  var r = win.document.createRange();\n  var start = isBackward$$1 ? domFocus : domAnchor;\n  var end = isBackward$$1 ? domAnchor : domFocus;\n  r.setStart(start.node, start.offset);\n  r.setEnd(end.node, end.offset);\n  return r;\n}\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\n\nvar OVERFLOWS = ['auto', 'overlay', 'scroll'];\n/**\n * Detect whether we are running IOS version 11\n */\n\nvar IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  var parent = el.parentNode;\n  var scroller = void 0;\n\n  while (!scroller) {\n    if (!parent.parentNode) break;\n    var style = window.getComputedStyle(parent);\n    var overflowY = style.overflowY;\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent;\n      break;\n    }\n\n    parent = parent.parentNode;\n  } // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n\n\n  if (!scroller) {\n    return window.document.body;\n  }\n\n  return scroller;\n}\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return;\n  if (!selection.anchorNode) return;\n  var window = getWindow(selection.anchorNode);\n  var scroller = findScrollContainer(selection.anchorNode, window);\n  var isWindow = scroller === window.document.body || scroller === window.document.documentElement;\n  var backward = isBackward(selection);\n  var range = selection.getRangeAt(0).cloneRange();\n  range.collapse(backward);\n  var cursorRect = range.getBoundingClientRect(); // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1);\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1);\n      }\n\n      cursorRect = range.getBoundingClientRect();\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0];\n        }\n      }\n    }\n  }\n\n  var width = void 0;\n  var height = void 0;\n  var yOffset = void 0;\n  var xOffset = void 0;\n  var scrollerTop = 0;\n  var scrollerLeft = 0;\n  var scrollerBordersY = 0;\n  var scrollerBordersX = 0;\n  var scrollerPaddingTop = 0;\n  var scrollerPaddingBottom = 0;\n  var scrollerPaddingLeft = 0;\n  var scrollerPaddingRight = 0;\n\n  if (isWindow) {\n    var innerWidth = window.innerWidth,\n        innerHeight = window.innerHeight,\n        pageYOffset = window.pageYOffset,\n        pageXOffset = window.pageXOffset;\n    width = innerWidth;\n    height = innerHeight;\n    yOffset = pageYOffset;\n    xOffset = pageXOffset;\n  } else {\n    var offsetWidth = scroller.offsetWidth,\n        offsetHeight = scroller.offsetHeight,\n        scrollTop = scroller.scrollTop,\n        scrollLeft = scroller.scrollLeft;\n\n    var _window$getComputedSt = window.getComputedStyle(scroller),\n        borderTopWidth = _window$getComputedSt.borderTopWidth,\n        borderBottomWidth = _window$getComputedSt.borderBottomWidth,\n        borderLeftWidth = _window$getComputedSt.borderLeftWidth,\n        borderRightWidth = _window$getComputedSt.borderRightWidth,\n        paddingTop = _window$getComputedSt.paddingTop,\n        paddingBottom = _window$getComputedSt.paddingBottom,\n        paddingLeft = _window$getComputedSt.paddingLeft,\n        paddingRight = _window$getComputedSt.paddingRight;\n\n    var scrollerRect = scroller.getBoundingClientRect();\n    width = offsetWidth;\n    height = offsetHeight;\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);\n    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);\n    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);\n    scrollerPaddingTop = parseInt(paddingTop, 10);\n    scrollerPaddingBottom = parseInt(paddingBottom, 10);\n    scrollerPaddingLeft = parseInt(paddingLeft, 10);\n    scrollerPaddingRight = parseInt(paddingRight, 10);\n    yOffset = scrollTop;\n    xOffset = scrollLeft;\n  }\n\n  var cursorTop = cursorRect.top + yOffset - scrollerTop;\n  var cursorLeft = cursorRect.left + xOffset - scrollerLeft;\n  var x = xOffset;\n  var y = yOffset;\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft;\n  } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop;\n  } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {\n    // selection below viewport\n    y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y);\n  } else {\n    scroller.scrollTop = y;\n    scroller.scrollLeft = x;\n  }\n}\n\nvar FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/;\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$7 = Debug('slate:content');\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug$7.update = Debug('slate:update');\n/**\n * Content.\n *\n * @type {Component}\n */\n\nvar Content = function (_React$Component) {\n  inherits(Content, _React$Component);\n\n  function Content() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Content);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Content.__proto__ || Object.getPrototypeOf(Content)).call.apply(_ref, [this].concat(args))), _this), _this.tmp = {\n      isUpdatingSelection: false\n      /**\n       * Create a set of bound event handlers.\n       *\n       * @type {Object}\n       */\n\n    }, _this.handlers = EVENT_HANDLERS.reduce(function (obj, handler) {\n      obj[handler] = function (event) {\n        return _this.onEvent(handler, event);\n      };\n\n      return obj;\n    }, {}), _this.updateSelection = function () {\n      var editor = _this.props.editor;\n      var value = editor.value;\n      var selection = value.selection;\n      var isBackward$$1 = selection.isBackward;\n      var window = getWindow(_this.element);\n      var native = window.getSelection();\n      var activeElement = window.document.activeElement;\n\n      if (debug$7.enabled) {\n        debug$7.update('updateSelection', {\n          selection: selection.toJSON()\n        });\n      } // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n\n\n      if (!native) {\n        return;\n      }\n\n      var rangeCount = native.rangeCount,\n          anchorNode = native.anchorNode;\n      var updated = false; // If the Slate selection is blurred, but the DOM's active element is still\n      // the editor, we need to blur it.\n\n      if (selection.isBlurred && activeElement === _this.element) {\n        _this.element.blur();\n\n        updated = true;\n      } // If the Slate selection is unset, but the DOM selection has a range\n      // selected in the editor, we need to remove the range.\n\n\n      if (selection.isUnset && rangeCount && _this.isInEditor(anchorNode)) {\n        removeAllRanges(native);\n        updated = true;\n      } // If the Slate selection is focused, but the DOM's active element is not\n      // the editor, we need to focus it. We prevent scrolling because we handle\n      // scrolling to the correct selection.\n\n\n      if (selection.isFocused && activeElement !== _this.element) {\n        _this.element.focus({\n          preventScroll: true\n        });\n\n        updated = true;\n      } // Otherwise, figure out which DOM nodes should be selected...\n\n\n      if (selection.isFocused && selection.isSet) {\n        var current = !!rangeCount && native.getRangeAt(0);\n        var range = findDOMRange(selection, window);\n\n        if (!range) {\n          warning(false, 'Unable to find a native DOM range from the current selection.');\n          return;\n        }\n\n        var startContainer = range.startContainer,\n            startOffset = range.startOffset,\n            endContainer = range.endContainer,\n            endOffset = range.endOffset; // If the new range matches the current selection, there is nothing to fix.\n        // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n        // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n        // to check both orientations here. (2017/10/31)\n\n        if (current) {\n          if (startContainer === current.startContainer && startOffset === current.startOffset && endContainer === current.endContainer && endOffset === current.endOffset || startContainer === current.endContainer && startOffset === current.endOffset && endContainer === current.startContainer && endOffset === current.startOffset) {\n            return;\n          }\n        } // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n\n\n        updated = true;\n        _this.tmp.isUpdatingSelection = true;\n        removeAllRanges(native); // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n\n        if (native.setBaseAndExtent) {\n          // COMPAT: Since the DOM range has no concept of backwards/forwards\n          // we need to check and do the right thing here.\n          if (isBackward$$1) {\n            native.setBaseAndExtent(range.endContainer, range.endOffset, range.startContainer, range.startOffset);\n          } else {\n            native.setBaseAndExtent(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n          }\n        } else {\n          native.addRange(range);\n        } // Scroll to the selection, in case it's out of view.\n\n\n        scrollToSelection(native); // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n        // it is still set when selection-related events from updating it fire.\n\n        setTimeout(function () {\n          // COMPAT: In Firefox, it's not enough to create a range, you also need\n          // to focus the contenteditable element too. (2016/11/16)\n          if (IS_FIREFOX && _this.element) {\n            _this.element.focus();\n          }\n\n          _this.tmp.isUpdatingSelection = false;\n        });\n      }\n\n      if (updated && debug$7.enabled) {\n        debug$7('updateSelection', {\n          selection: selection,\n          native: native,\n          activeElement: activeElement\n        });\n        debug$7.update('updateSelection-applied', {\n          selection: selection\n        });\n      }\n    }, _this.ref = function (element) {\n      _this.element = element;\n    }, _this.isInEditor = function (target) {\n      var _this2 = _this,\n          element = _this2.element;\n      var el = void 0;\n\n      try {\n        // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n        // have .closest and it crashes.\n        if (target.nodeType === 8) {\n          return false;\n        } // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n        // `target` is a text node use its parent node for check.\n\n\n        el = target.nodeType === 3 ? target.parentNode : target;\n      } catch (err) {\n        // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n        // originating from an internal \"restricted\" element (e.g. a stepper\n        // arrow on a number input)\n        // see github.com/ianstormtaylor/slate/issues/1819\n        if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n          return false;\n        }\n\n        throw err;\n      }\n\n      return el.isContentEditable && (el === element || el.closest('[data-slate-editor]') === element);\n    }, _this.onNativeSelectionChange = throttle(function (event) {\n      if (_this.props.readOnly) return;\n      var window = getWindow(event.target);\n      var activeElement = window.document.activeElement;\n      if (activeElement !== _this.element) return;\n\n      _this.props.onEvent('onSelect', event);\n    }, 100), _this.renderNode = function (child, isSelected, decorations) {\n      var _this$props = _this.props,\n          editor = _this$props.editor,\n          readOnly = _this$props.readOnly;\n      var value = editor.value;\n      var document = value.document,\n          selection = value.selection;\n      var isFocused = selection.isFocused;\n      return React.createElement(Node$1, {\n        block: null,\n        editor: editor,\n        decorations: decorations,\n        isSelected: isSelected,\n        isFocused: isFocused && isSelected,\n        key: child.key,\n        node: child,\n        parent: document,\n        readOnly: readOnly\n      });\n    }, _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n\n  createClass(Content, [{\n    key: 'componentDidMount',\n\n    /**\n     * When the editor first mounts in the DOM we need to:\n     *\n     *   - Add native DOM event listeners.\n     *   - Update the selection, in case it starts focused.\n     */\n    value: function componentDidMount() {\n      var window = getWindow(this.element);\n      window.document.addEventListener('selectionchange', this.onNativeSelectionChange); // COMPAT: Restrict scope of `beforeinput` to clients that support the\n      // Input Events Level 2 spec, since they are preventable events.\n\n      if (HAS_INPUT_EVENTS_LEVEL_2) {\n        this.element.addEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n\n      this.updateSelection();\n    }\n    /**\n     * When unmounting, remove DOM event listeners.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var window = getWindow(this.element);\n\n      if (window) {\n        window.document.removeEventListener('selectionchange', this.onNativeSelectionChange);\n      }\n\n      if (HAS_INPUT_EVENTS_LEVEL_2) {\n        this.element.removeEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n    }\n    /**\n     * On update, update the selection.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      debug$7.update('componentDidUpdate');\n      this.updateSelection();\n    }\n    /**\n     * Update the native DOM selection to reflect the internal model.\n     */\n\n    /**\n     * The React ref method to set the root content element locally.\n     *\n     * @param {Element} element\n     */\n\n    /**\n     * Check if an event `target` is fired from within the contenteditable\n     * element. This should be false for edits happening in non-contenteditable\n     * children, such as void nodes and other nested Slate editors.\n     *\n     * @param {Element} target\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'onEvent',\n\n    /**\n     * On `event` with `handler`.\n     *\n     * @param {String} handler\n     * @param {Event} event\n     */\n    value: function onEvent(handler, event) {\n      debug$7('onEvent', handler); // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n      // programmatically while updating selection.\n\n      if (this.tmp.isUpdatingSelection && (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')) {\n        return;\n      } // COMPAT: There are situations where a select event will fire with a new\n      // native selection that resolves to the same internal position. In those\n      // cases we don't need to trigger any changes, since our internal model is\n      // already up to date, but we do want to update the native selection again\n      // to make sure it is in sync. (2017/10/16)\n      //\n      // ANDROID: The updateSelection causes issues in Android when you are\n      // at the end of a block. The selection ends up to the left of the inserted\n      // character instead of to the right. This behavior continues even if\n      // you enter more than one character. (2019/01/03)\n\n\n      if (!IS_ANDROID && handler === 'onSelect') {\n        var editor = this.props.editor;\n        var value = editor.value;\n        var selection = value.selection;\n        var window = getWindow(event.target);\n        var native = window.getSelection();\n        var range = findRange(native, editor);\n\n        if (range && range.equals(selection.toRange())) {\n          this.updateSelection();\n          return;\n        }\n      } // Don't handle drag and drop events coming from embedded editors.\n\n\n      if (handler === 'onDragEnd' || handler === 'onDragEnter' || handler === 'onDragExit' || handler === 'onDragLeave' || handler === 'onDragOver' || handler === 'onDragStart' || handler === 'onDrop') {\n        var closest = event.target.closest('[data-slate-editor]');\n\n        if (closest !== this.element) {\n          return;\n        }\n      } // Some events require being in editable in the editor, so if the event\n      // target isn't, ignore them.\n\n\n      if (handler === 'onBeforeInput' || handler === 'onBlur' || handler === 'onCompositionEnd' || handler === 'onCompositionStart' || handler === 'onCopy' || handler === 'onCut' || handler === 'onFocus' || handler === 'onInput' || handler === 'onKeyDown' || handler === 'onKeyUp' || handler === 'onPaste' || handler === 'onSelect') {\n        if (!this.isInEditor(event.target)) {\n          return;\n        }\n      }\n\n      this.props.onEvent(handler, event);\n    }\n    /**\n     * On native `selectionchange` event, trigger the `onSelect` handler. This is\n     * needed to account for React's `onSelect` being non-standard and not firing\n     * until after a selection has been released. This causes issues in situations\n     * where another change happens while a selection is being made.\n     *\n     * @param {Event} event\n     */\n\n  }, {\n    key: 'render',\n\n    /**\n     * Render the editor content.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _this3 = this;\n\n      var props = this.props,\n          handlers = this.handlers;\n      var id = props.id,\n          className = props.className,\n          readOnly = props.readOnly,\n          editor = props.editor,\n          tabIndex = props.tabIndex,\n          role = props.role,\n          tagName = props.tagName,\n          spellCheck = props.spellCheck;\n      var value = editor.value;\n      var Container = tagName;\n      var document = value.document,\n          selection = value.selection,\n          decorations = value.decorations;\n      var indexes = document.getSelectionIndexes(selection);\n      var decs = document.getDecorations(editor).concat(decorations);\n      var childrenDecorations = getChildrenDecorations(document, decs);\n      var children = document.nodes.toArray().map(function (child, i) {\n        var isSelected = !!indexes && indexes.start <= i && i < indexes.end;\n        return _this3.renderNode(child, isSelected, childrenDecorations[i]);\n      });\n\n      var style = _extends({\n        // Prevent the default outline styles.\n        outline: 'none',\n        // Preserve adjacent whitespace and new lines.\n        whiteSpace: 'pre-wrap',\n        // Allow words to break if they are too long.\n        wordWrap: 'break-word'\n      }, readOnly ? {} : {\n        WebkitUserModify: 'read-write-plaintext-only'\n      }, props.style);\n\n      debug$7('render', {\n        props: props\n      });\n\n      if (debug$7.enabled) {\n        debug$7.update('render', {\n          text: value.document.text,\n          selection: value.selection.toJSON(),\n          value: value.toJSON()\n        });\n      }\n\n      return React.createElement(Container, _extends({}, handlers, {\n        'data-slate-editor': true,\n        ref: this.ref,\n        'data-key': document.key,\n        contentEditable: readOnly ? null : true,\n        suppressContentEditableWarning: true,\n        id: id,\n        className: className,\n        autoCorrect: props.autoCorrect ? 'on' : 'off',\n        spellCheck: spellCheck,\n        style: style,\n        role: readOnly ? null : role || 'textbox',\n        tabIndex: tabIndex // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        ,\n        'data-gramm': false\n      }), children);\n    }\n    /**\n     * Render a `child` node of the document.\n     *\n     * @param {Node} child\n     * @param {Boolean} isSelected\n     * @return {Element}\n     */\n\n  }]);\n  return Content;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nContent.propTypes = {\n  autoCorrect: Types.bool.isRequired,\n  className: Types.string,\n  editor: Types.object.isRequired,\n  id: Types.string,\n  readOnly: Types.bool.isRequired,\n  role: Types.string,\n  spellCheck: Types.bool.isRequired,\n  style: Types.object,\n  tabIndex: Types.number,\n  tagName: Types.string\n};\nContent.defaultProps = {\n  style: {},\n  tagName: 'div'\n};\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nvar PROPS = [].concat(toConsumableArray(EVENT_HANDLERS), ['commands', 'decorateNode', 'queries', 'renderEditor', 'renderMark', 'renderNode', 'schema']);\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction ReactPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var placeholder = options.placeholder,\n      _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n  /**\n   * Decorate node.\n   *\n   * @param {Object} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    return [];\n  }\n  /**\n   * Render editor.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n\n  function renderEditor(props, editor, next) {\n    return React.createElement(Content, {\n      autoCorrect: props.autoCorrect,\n      className: props.className,\n      editor: editor,\n      id: props.id,\n      onEvent: function onEvent(handler, event) {\n        return editor.run(handler, event);\n      },\n      readOnly: props.readOnly,\n      role: props.role,\n      spellCheck: props.spellCheck,\n      style: props.style,\n      tabIndex: props.tabIndex,\n      tagName: props.tagName\n    });\n  }\n  /**\n   * Render node.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n\n  function renderNode(props, editor, next) {\n    var attributes = props.attributes,\n        children = props.children,\n        node = props.node;\n    var object = node.object;\n    if (object !== 'block' && object !== 'inline') return null;\n    var Tag = object === 'block' ? 'div' : 'span';\n    var style = {\n      position: 'relative'\n    };\n    return React.createElement(Tag, _extends({}, attributes, {\n      style: style\n    }), children);\n  }\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n\n  var ret = [];\n  var editorPlugin = PROPS.reduce(function (memo, prop) {\n    if (prop in options) memo[prop] = options[prop];\n    return memo;\n  }, {});\n  ret.push(DOMPlugin({\n    plugins: [editorPlugin].concat(toConsumableArray(plugins))\n  }));\n\n  if (placeholder) {\n    ret.push(PlaceholderPlugin({\n      placeholder: placeholder,\n      when: function when(editor, node) {\n        return node.object === 'document' && node.text === '' && node.nodes.size === 1 && node.getTexts().size === 1;\n      }\n    }));\n  }\n\n  ret.push({\n    decorateNode: decorateNode,\n    renderEditor: renderEditor,\n    renderNode: renderNode\n  });\n  return ret;\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$8 = Debug('slate:editor');\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nvar Editor$1 = function (_React$Component) {\n  inherits(Editor$$1, _React$Component);\n\n  function Editor$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Editor$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Editor$$1.__proto__ || Object.getPrototypeOf(Editor$$1)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      value: _this.props.defaultValue\n      /**\n       * Temporary values.\n       *\n       * @type {Object}\n       */\n\n    }, _this.tmp = {\n      mounted: false,\n      change: null,\n      resolves: 0,\n      updates: 0\n      /**\n       * When the component first mounts, flush a queued change if one exists.\n       */\n\n    }, _this.resolveController = memoizeOne(function () {\n      warning(_this.tmp.resolves < 5 || _this.tmp.resolves !== _this.tmp.updates, 'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.');\n      _this.tmp.resolves++;\n      var react = ReactPlugin(_extends({}, _this.props, {\n        value: _this.props.value || _this.state.value\n      }));\n\n      var onChange = function onChange(change) {\n        if (_this.tmp.mounted) {\n          _this.handleChange(change);\n        } else {\n          _this.tmp.change = change;\n        }\n      };\n\n      _this.controller = new Editor({\n        plugins: [react],\n        onChange: onChange\n      }, {\n        controller: _this,\n        construct: false\n      });\n\n      _this.controller.run('onConstruct');\n    }), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n\n  createClass(Editor$$1, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.tmp.mounted = true;\n      this.tmp.updates++;\n\n      if (this.props.autoFocus) {\n        this.focus();\n      }\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n    /**\n     * When the component updates, flush a queued change if one exists.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.tmp.updates++;\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n    /**\n     * When the component unmounts, make sure async commands don't trigger react updates.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.tmp.mounted = false;\n    }\n    /**\n     * Render the editor.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      debug$8('render', this);\n\n      var props = _extends({}, this.props, {\n        editor: this // Re-resolve the controller if needed based on memoized props.\n\n      });\n\n      var commands = props.commands,\n          placeholder = props.placeholder,\n          plugins = props.plugins,\n          queries = props.queries,\n          schema = props.schema;\n      this.resolveController(plugins, schema, commands, queries, placeholder); // Set the current props on the controller.\n\n      var options = props.options,\n          readOnly = props.readOnly,\n          valueFromProps = props.value;\n      var valueFromState = this.state.value;\n      var value = valueFromProps || valueFromState;\n      this.controller.setReadOnly(readOnly);\n      this.controller.setValue(value, options); // Render the editor's children with the controller.\n\n      var children = this.controller.run('renderEditor', _extends({}, props, {\n        value: value\n      }));\n      return children;\n    }\n    /**\n     * Resolve an editor controller from the passed-in props. This method takes\n     * all of the props as individual arguments to be able to properly memoize\n     * against anything that could change and invalidate the old editor.\n     *\n     * @param {Array} plugins\n     * @param {Object} schema\n     * @param {Object} commands\n     * @param {Object} queries\n     * @param {String} placeholder\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'handleChange',\n    value: function handleChange(change) {\n      var onChange = this.props.onChange;\n      var value = this.state.value;\n\n      if (value) {\n        // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n        this.setState({\n          value: change.value\n        });\n      }\n\n      onChange(change);\n    }\n    /**\n     * Mimic the API of the `Editor` controller, so that this component instance\n     * can be passed in its place to plugins.\n     */\n\n  }, {\n    key: 'applyOperation',\n    value: function applyOperation() {\n      var _controller;\n\n      return (_controller = this.controller).applyOperation.apply(_controller, arguments);\n    }\n  }, {\n    key: 'command',\n    value: function command() {\n      var _controller2;\n\n      return (_controller2 = this.controller).command.apply(_controller2, arguments);\n    }\n  }, {\n    key: 'hasCommand',\n    value: function hasCommand() {\n      var _controller3;\n\n      return (_controller3 = this.controller).hasCommand.apply(_controller3, arguments);\n    }\n  }, {\n    key: 'hasQuery',\n    value: function hasQuery() {\n      var _controller4;\n\n      return (_controller4 = this.controller).hasQuery.apply(_controller4, arguments);\n    }\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var _controller5;\n\n      return (_controller5 = this.controller).normalize.apply(_controller5, arguments);\n    }\n  }, {\n    key: 'query',\n    value: function query() {\n      var _controller6;\n\n      return (_controller6 = this.controller).query.apply(_controller6, arguments);\n    }\n  }, {\n    key: 'registerCommand',\n    value: function registerCommand() {\n      var _controller7;\n\n      return (_controller7 = this.controller).registerCommand.apply(_controller7, arguments);\n    }\n  }, {\n    key: 'registerQuery',\n    value: function registerQuery() {\n      var _controller8;\n\n      return (_controller8 = this.controller).registerQuery.apply(_controller8, arguments);\n    }\n  }, {\n    key: 'run',\n    value: function run() {\n      var _controller9;\n\n      return (_controller9 = this.controller).run.apply(_controller9, arguments);\n    }\n  }, {\n    key: 'withoutNormalizing',\n    value: function withoutNormalizing() {\n      var _controller10;\n\n      return (_controller10 = this.controller).withoutNormalizing.apply(_controller10, arguments);\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'call',\n    value: function call() {\n      var _controller11;\n\n      return (_controller11 = this.controller).call.apply(_controller11, arguments);\n    }\n  }, {\n    key: 'change',\n    value: function change() {\n      var _controller12;\n\n      return (_controller12 = this.controller).change.apply(_controller12, arguments);\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange() {\n      var _controller13;\n\n      return (_controller13 = this.controller).onChange.apply(_controller13, arguments);\n    }\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations() {\n      var _controller14;\n\n      return (_controller14 = this.controller).applyOperations.apply(_controller14, arguments);\n    }\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag() {\n      var _controller15;\n\n      return (_controller15 = this.controller).setOperationFlag.apply(_controller15, arguments);\n    }\n  }, {\n    key: 'getFlag',\n    value: function getFlag() {\n      var _controller16;\n\n      return (_controller16 = this.controller).getFlag.apply(_controller16, arguments);\n    }\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag() {\n      var _controller17;\n\n      return (_controller17 = this.controller).unsetOperationFlag.apply(_controller17, arguments);\n    }\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization() {\n      var _controller18;\n\n      return (_controller18 = this.controller).withoutNormalization.apply(_controller18, arguments);\n    }\n  }, {\n    key: 'operations',\n    get: function get$$1() {\n      return this.controller.operations;\n    }\n  }, {\n    key: 'readOnly',\n    get: function get$$1() {\n      return this.controller.readOnly;\n    }\n  }, {\n    key: 'value',\n    get: function get$$1() {\n      return this.controller.value;\n    }\n  }, {\n    key: 'editor',\n    get: function get$$1() {\n      return this.controller.editor;\n    }\n  }, {\n    key: 'schema',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }, {\n    key: 'stack',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }]);\n  return Editor$$1;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nEditor$1.propTypes = _extends({\n  autoCorrect: Types.bool,\n  autoFocus: Types.bool,\n  className: Types.string,\n  defaultValue: SlateTypes.value,\n  id: Types.string,\n  onChange: Types.func,\n  options: Types.object,\n  placeholder: Types.any,\n  plugins: Types.array,\n  readOnly: Types.bool,\n  role: Types.string,\n  schema: Types.object,\n  spellCheck: Types.bool,\n  style: Types.object,\n  tabIndex: Types.number,\n  value: SlateTypes.value\n}, EVENT_HANDLERS.reduce(function (obj, handler) {\n  obj[handler] = Types.func;\n  return obj;\n}, {}));\nEditor$1.defaultProps = {\n  autoFocus: false,\n  autoCorrect: true,\n  onChange: function onChange() {},\n  options: {},\n  placeholder: '',\n  plugins: [],\n  readOnly: false,\n  schema: {},\n  spellCheck: true\n};\nvar index = {\n  Editor: Editor$1,\n  cloneFragment: cloneFragment,\n  findDOMNode: findDOMNode,\n  findDOMRange: findDOMRange,\n  findNode: findNode,\n  findRange: findRange,\n  getEventRange: getEventRange,\n  getEventTransfer: getEventTransfer,\n  setEventTransfer: setEventTransfer,\n  ReactPlugin: ReactPlugin\n};\nexport default index;\nexport { Editor$1 as Editor, cloneFragment, findDOMNode, findDOMRange, findNode, findRange, getEventRange, getEventTransfer, setEventTransfer, ReactPlugin };","map":{"version":3,"sources":["../src/constants/event-handlers.js","../src/utils/fix-selection-in-zero-width-block.js","../src/utils/offset-key.js","../src/utils/find-point.js","../src/utils/find-range.js","../src/utils/get-selection-from-dom.js","../src/utils/set-selection-from-dom.js","../src/utils/set-text-from-dom-node.js","../src/utils/is-input-data-enter.js","../src/utils/is-input-data-last-char.js","../src/utils/element-snapshot.js","../src/utils/dom-snapshot.js","../src/utils/executor.js","../src/plugins/android.js","../src/constants/transfer-types.js","../src/utils/find-dom-node.js","../src/utils/remove-all-ranges.js","../src/utils/clone-fragment.js","../src/utils/find-node.js","../src/utils/get-event-range.js","../src/utils/get-event-transfer.js","../src/utils/set-event-transfer.js","../src/plugins/after.js","../src/plugins/before.js","../src/plugins/dom.js","../src/components/leaf.js","../src/components/text.js","../src/components/void.js","../src/utils/get-children-decorations.js","../src/components/node.js","../src/utils/find-dom-point.js","../src/utils/find-dom-range.js","../src/utils/scroll-to-selection.js","../src/components/content.js","../src/plugins/react.js","../src/components/editor.js","../src/index.js"],"names":["EVENT_HANDLERS","domSelection","window","anchorNode","dataset","isZeroWidth","range","PARSER","matches","original","key","index","parseInt","object","ZERO_WIDTH_ATTRIBUTE","ZERO_WIDTH_SELECTOR","OFFSET_KEY_ATTRIBUTE","RANGE_SELECTOR","TEXT_SELECTOR","VOID_SELECTOR","Value","nearestNode","nearestOffset","normalizeNodeAndOffset","getWindow","parentNode","rangeNode","offset","node","textNode","voidNode","offsetKey","OffsetKey","value","editor","point","isLast","direction","getEditableChild","i","childNodes","parent","child","triedForward","triedBackward","el","native","endOffset","anchorOffset","focusNode","focusOffset","isCollapsed","anchor","findPoint","focus","document","findRange","anchorText","focusText","anchorInline","focusInline","focusBlock","anchorBlock","block","nextText","selection","getSelectionFromDOM","leaves","lastText","lastLeaf","start","end","leaf","r","text","textContent","domNode","isLastText","isLastLeaf","lastChar","entire","data","charCode","Array","chars","snapshot","isTextNode","getElementSnapshot","elements","lastElement","nextElementSibling","childSnapshot","snapLength","dups","dup","next","applyElementSnapshot","prevElement","element","ElementSnapshot","getSnapshot","win","DomSnapshot","before","subrootEl","closest","previousElementSibling","getSelectionFromDom","Executor","options","timeout","debug","Debug","ANDROID_API_VERSION","NONE","COMPOSING","status","nodes","compositionEndSnapshot","reconciler","keyDownSnapshot","deleter","preventNextBeforeInput","compositionEndAction","from","isNative","event","pick","isInputDataLastChar","isEnter","isInputDataEnter","nativeEvent","TRANSFER_TYPES","Node","doc","FRAGMENT","HTML","TEXT","callback","fragment","startVoid","endVoid","encoded","Base64","contents","attach","findDOMNode","isNewline","zw","span","valFromSelection","plainText","Plain","div","editorEl","x","y","target","findNode","rect","isPrevious","previousText","position","NODE","RICH","FRAGMENT_MATCHER","transfer","getType","html","rich","files","full","embeddedTypes","getEmbeddedTypes","item","getTransferType","prefix","JSON","type","types","mime","obj","string","isDraggingInternally","isMouseDown","isSynthetic","targetRange","hasVoidParent","marks","ancestors","isVoid","endBlock","endInline","isVoidBlock","isVoidInline","selectionIncludesNode","getEventRange","getEventTransfer","n","Hotkeys","startText","isPreviousInVoid","isNextInVoid","startBlock","defaultBlock","defaultMarks","frag","activeElement","compositionCount","isComposing","isCopying","isDragging","relatedTarget","ReactDOM","IS_FIREFOX","plugins","beforeBeforePlugins","IS_ANDROID","AndroidPlugin","beforePlugin","BeforePlugin","afterPlugin","AfterPlugin","Leaf","React","Component","propTypes","SlateTypes","Types","args","props","attributes","Text","ImmutableTypes","defaultProps","shouldComponentUpdate","p","pLast","nLast","decorations","style","decs","d","path","startPath","endPath","PathUtils","children","renderLeaf","Void","id","readOnly","Tag","spacer","content","renderText","activeDecorations","Set","childrenDecorations","keyOrders","globalOrder","endPoints","startKeyOrder","decoration","containingChildOrder","getContainingChildOrder","endKeyOrder","a","b","nextChildIndex","order","containingChild","nextProps","shouldUpdate","isSelected","isFocused","indexes","getChildrenDecorations","isChildSelected","renderNode","texts","domLength","slateLength","Math","isBackward","domAnchor","findDOMPoint","domFocus","OVERFLOWS","IS_IOS_11","IS_IOS","scroller","overflowY","findScrollContainer","isWindow","backward","cursorRect","width","height","yOffset","xOffset","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","innerWidth","innerHeight","pageYOffset","pageXOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","cursorTop","cursorLeft","FIREFOX_NODE_TYPE_ACCESS_ERROR","Content","tmp","handlers","updateSelection","rangeCount","updated","preventScroll","current","findDOMRange","startContainer","startOffset","endContainer","ref","isInEditor","err","handler","onNativeSelectionChange","className","tabIndex","role","tagName","spellCheck","Container","WebkitUserModify","PROPS","placeholder","ret","editorPlugin","prop","memo","Editor","bool","func","any","array","number","state","defaultValue","commands","queries","schema","valueFromProps","valueFromState","resolveController","react","ReactPlugin","onChange","controller","construct","change"],"mappings":"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","sourcesContent":["/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst EVENT_HANDLERS = [\n  'onBeforeInput',\n  'onBlur',\n  'onClick',\n  'onContextMenu',\n  'onCompositionEnd',\n  'onCompositionStart',\n  'onCopy',\n  'onCut',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n  'onInput',\n  'onFocus',\n  'onKeyDown',\n  'onKeyUp',\n  'onMouseDown',\n  'onMouseUp',\n  'onPaste',\n  'onSelect',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default EVENT_HANDLERS\n","/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\nexport default function fixSelectionInZeroWidthBlock(window) {\n  const domSelection = window.getSelection()\n  const { anchorNode } = domSelection\n  const { dataset } = anchorNode.parentElement\n  const isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false\n\n  // We are doing three checks to see if we need to move the cursor.\n  // Is this a zero-width slate span?\n  // Is the current cursor position not at the start of it?\n  // Is there more than one character (i.e. the zero-width space char) in here?\n  if (\n    isZeroWidth &&\n    anchorNode.textContent.length === 1 &&\n    domSelection.anchorOffset !== 0\n  ) {\n    const range = window.document.createRange()\n    range.setStart(anchorNode, 0)\n    range.setEnd(anchorNode, 0)\n    domSelection.removeAllRanges()\n    domSelection.addRange(range)\n  }\n}\n","/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nconst PARSER = /^([\\w-]+)(?::(\\d+))?$/\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  const matches = PARSER.exec(string)\n\n  if (!matches) {\n    throw new Error(`Invalid offset key string \"${string}\".`)\n  }\n\n  const [original, key, index] = matches // eslint-disable-line no-unused-vars\n  return {\n    key,\n    index: parseInt(index, 10),\n  }\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return `${object.key}:${object.index}`\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  parse,\n  stringify,\n}\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { Value } from 'slate'\n\nimport OffsetKey from './offset-key'\n\n/**\n * Constants.\n *\n * @type {String}\n */\n\nexport const ZERO_WIDTH_ATTRIBUTE = 'data-slate-zero-width'\nexport const ZERO_WIDTH_SELECTOR = `[${ZERO_WIDTH_ATTRIBUTE}]`\nconst OFFSET_KEY_ATTRIBUTE = 'data-offset-key'\nconst RANGE_SELECTOR = `[${OFFSET_KEY_ATTRIBUTE}]`\nconst TEXT_SELECTOR = `[data-key]`\nconst VOID_SELECTOR = '[data-slate-void]'\n\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.'\n  )\n\n  const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n    nativeNode,\n    nativeOffset\n  )\n\n  const window = getWindow(nativeNode)\n  const { parentNode } = nearestNode\n  let rangeNode = parentNode.closest(RANGE_SELECTOR)\n  let offset\n  let node\n\n  // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n  if (rangeNode) {\n    const range = window.document.createRange()\n    const textNode = rangeNode.closest(TEXT_SELECTOR)\n    range.setStart(textNode, 0)\n    range.setEnd(nearestNode, nearestOffset)\n    node = textNode\n\n    // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n    offset = range.cloneContents().textContent.length\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    const voidNode = parentNode.closest(VOID_SELECTOR)\n    if (!voidNode) return null\n    rangeNode = voidNode.querySelector(RANGE_SELECTOR)\n    if (!rangeNode) return null\n    node = rangeNode\n    offset = node.textContent.length\n  }\n\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n  if (\n    offset === node.textContent.length &&\n    parentNode.hasAttribute(ZERO_WIDTH_ATTRIBUTE)\n  ) {\n    offset--\n  }\n\n  // Get the string value of the offset key attribute.\n  const offsetKey = rangeNode.getAttribute(OFFSET_KEY_ATTRIBUTE)\n  if (!offsetKey) return null\n\n  const { key } = OffsetKey.parse(offsetKey)\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  const { value } = editor\n  if (!value.document.hasDescendant(key)) return null\n\n  const point = value.document.createPoint({ key, offset })\n  return point\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType === 8 ||\n    (child.nodeType === 1 && child.childNodes.length === 0) ||\n    (child.nodeType === 1 && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction === 'forward') i++\n    if (direction === 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPoint\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { Value } from 'slate'\n\nimport findPoint from './find-point'\n\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction findRange(native, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const el = native.anchorNode || native.startContainer\n  if (!el) return null\n\n  const window = getWindow(el)\n\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n  if (\n    native instanceof window.Range ||\n    (window.StaticRange && native instanceof window.StaticRange)\n  ) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset,\n    }\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n    isCollapsed,\n  } = native\n  const { value } = editor\n  const anchor = findPoint(anchorNode, anchorOffset, editor)\n  const focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor)\n  if (!anchor || !focus) return null\n\n  const { document } = value\n  const range = document.createRange({\n    anchor,\n    focus,\n  })\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findRange\n","import findRange from './find-range'\n\nexport default function getSelectionFromDOM(window, editor, domSelection) {\n  const { value } = editor\n  const { document } = value\n\n  // If there are no ranges, the editor was blurred natively.\n  if (!domSelection.rangeCount) {\n    editor.blur()\n    return\n  }\n\n  // Otherwise, determine the Slate selection from the native one.\n  let range = findRange(domSelection, editor)\n\n  if (!range) {\n    return\n  }\n\n  const { anchor, focus } = range\n  const anchorText = document.getNode(anchor.key)\n  const focusText = document.getNode(focus.key)\n  const anchorInline = document.getClosestInline(anchor.key)\n  const focusInline = document.getClosestInline(focus.key)\n  const focusBlock = document.getClosestBlock(focus.key)\n  const anchorBlock = document.getClosestBlock(anchor.key)\n\n  // COMPAT: If the anchor point is at the start of a non-void, and the\n  // focus point is inside a void node with an offset that isn't `0`, set\n  // the focus offset to `0`. This is due to void nodes <span>'s being\n  // positioned off screen, resulting in the offset always being greater\n  // than `0`. Since we can't know what it really should be, and since an\n  // offset of `0` is less destructive because it creates a hanging\n  // selection, go with `0`. (2017/09/07)\n  if (\n    anchorBlock &&\n    !editor.isVoid(anchorBlock) &&\n    anchor.offset === 0 &&\n    focusBlock &&\n    editor.isVoid(focusBlock) &&\n    focus.offset !== 0\n  ) {\n    range = range.setFocus(focus.setOffset(0))\n  }\n\n  // COMPAT: If the selection is at the end of a non-void inline node, and\n  // there is a node after it, put it in the node after instead. This\n  // standardizes the behavior, since it's indistinguishable to the user.\n  if (\n    anchorInline &&\n    !editor.isVoid(anchorInline) &&\n    anchor.offset === anchorText.text.length\n  ) {\n    const block = document.getClosestBlock(anchor.key)\n    const nextText = block.getNextText(anchor.key)\n    if (nextText) range = range.moveAnchorTo(nextText.key, 0)\n  }\n\n  if (\n    focusInline &&\n    !editor.isVoid(focusInline) &&\n    focus.offset === focusText.text.length\n  ) {\n    const block = document.getClosestBlock(focus.key)\n    const nextText = block.getNextText(focus.key)\n    if (nextText) range = range.moveFocusTo(nextText.key, 0)\n  }\n\n  let selection = document.createSelection(range)\n  selection = selection.setIsFocused(true)\n\n  // Preserve active marks from the current selection.\n  // They will be cleared by `editor.select` if the selection actually moved.\n  selection = selection.set('marks', value.selection.marks)\n\n  return selection\n}\n","import getSelectionFromDOM from './get-selection-from-dom'\n\n/**\n * Looks at the DOM and generates the equivalent Slate Selection.\n *\n * @param {Window} window\n * @param {Editor} editor\n * @param {Selection} domSelection - The DOM's selection Object\n */\n\nexport default function setSelectionFromDOM(window, editor, domSelection) {\n  const selection = getSelectionFromDOM(window, editor, domSelection)\n  editor.select(selection)\n}\n","import findPoint from './find-point'\n\n/**\n * setTextFromDomNode lets us take a domNode and reconcile the text in the\n * editor's Document such that it reflects the text in the DOM. This is the\n * opposite of what the Editor usually does which takes the Editor's Document\n * and React modifies the DOM to match. The purpose of this method is for\n * composition changes where we don't know what changes the user made by\n * looking at events. Instead we wait until the DOM is in a safe state, we\n * read from it, and update the Editor's Document.\n *\n * @param {Window} window\n * @param {Editor} editor\n * @param {Node} domNode\n */\n\nexport default function setTextFromDomNode(window, editor, domNode) {\n  const point = findPoint(domNode, 0, editor)\n  if (!point) return\n\n  // Get the text node and leaf in question.\n  const { value } = editor\n  const { document, selection } = value\n  const node = document.getDescendant(point.key)\n  const block = document.getClosestBlock(node.key)\n  const leaves = node.getLeaves()\n  const lastText = block.getLastText()\n  const lastLeaf = leaves.last()\n  let start = 0\n  let end = 0\n\n  const leaf =\n    leaves.find(r => {\n      start = end\n      end += r.text.length\n      if (end > point.offset) return true\n    }) || lastLeaf\n\n  // Get the text information.\n  const { text } = leaf\n  let { textContent } = domNode\n  const isLastText = node === lastText\n  const isLastLeaf = leaf === lastLeaf\n  const lastChar = textContent.charAt(textContent.length - 1)\n\n  // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n  // we will have added another new line in <Leaf>'s render method to account\n  // for browsers collapsing a single trailing new lines, so remove it.\n  if (isLastText && isLastLeaf && lastChar === '\\n') {\n    textContent = textContent.slice(0, -1)\n  }\n\n  // If the text is no different, abort.\n  if (textContent === text) return\n\n  // Determine what the selection should be after changing the text.\n  // const delta = textContent.length - text.length\n  // const corrected = selection.moveToEnd().moveForward(delta)\n  let entire = selection\n    .moveAnchorTo(point.key, start)\n    .moveFocusTo(point.key, end)\n\n  entire = document.resolveRange(entire)\n\n  // Change the current value to have the leaf's text replaced.\n  editor.insertTextAtRange(entire, textContent, leaf.marks)\n}\n","/**\n * In Android API 26 and 27 we can tell if the input key was pressed by\n * waiting for the `beforeInput` event and seeing that the last character\n * of its `data` property is char code `10`.\n *\n * Note that at this point it is too late to prevent the event from affecting\n * the DOM so we use other methods to clean the DOM up after we have detected\n * the input.\n *\n * @param  {String} data\n * @return {Boolean}\n */\n\nexport default function isInputDataEnter(data) {\n  if (data == null) return false\n  const lastChar = data[data.length - 1]\n  const charCode = lastChar.charCodeAt(0)\n  return charCode === 10\n}\n","/**\n * In Android sometimes the only way to tell what the user is trying to do\n * is to look at an event's `data` property and see if the last characters\n * matches a character. This method helps us make that determination.\n *\n * @param {String} data\n * @param {[String]} chars\n * @return {Boolean}\n */\n\nexport default function isInputDataLastChar(data, chars) {\n  if (!Array.isArray(chars))\n    throw new Error(`chars must be an array of one character strings`)\n  if (data == null) return false\n  const lastChar = data[data.length - 1]\n  return chars.includes(lastChar)\n}\n","import getWindow from 'get-window'\n\n/**\n * Is the given node a text node?\n *\n * @param {node} node\n * @param {Window} window\n * @return {Boolean}\n */\n\nfunction isTextNode(node, window) {\n  return node.nodeType === window.Node.TEXT_NODE\n}\n\n/**\n * Takes a node and returns a snapshot of the node.\n *\n * @param {node} node\n * @param {Window} window\n * @return {object} element snapshot\n */\n\nfunction getElementSnapshot(node, window) {\n  const snapshot = {}\n  snapshot.node = node\n\n  if (isTextNode(node, window)) {\n    snapshot.text = node.textContent\n  }\n\n  snapshot.children = Array.from(node.childNodes).map(childNode =>\n    getElementSnapshot(childNode, window)\n  )\n  return snapshot\n}\n\n/**\n * Takes an array of elements and returns a snapshot\n *\n * @param {elements[]} elements\n * @param {Window} window\n * @return {object} snapshot\n */\n\nfunction getSnapshot(elements, window) {\n  if (!elements.length) throw new Error(`elements must be an Array`)\n\n  const lastElement = elements[elements.length - 1]\n  const snapshot = {\n    elements: elements.map(element => getElementSnapshot(element, window)),\n    parent: lastElement.parentElement,\n    next: lastElement.nextElementSibling,\n  }\n  return snapshot\n}\n\n/**\n * Takes an element snapshot and applies it to the element in the DOM.\n * Basically, it fixes the DOM to the point in time that the snapshot was\n * taken. This will put the DOM back in sync with React.\n *\n * @param {Object} snapshot\n * @param {Window} window\n */\n\nfunction applyElementSnapshot(snapshot, window) {\n  const el = snapshot.node\n\n  if (isTextNode(el, window)) {\n    // Update text if it is different\n    if (el.textContent !== snapshot.text) {\n      el.textContent = snapshot.text\n    }\n  }\n\n  snapshot.children.forEach(childSnapshot => {\n    applyElementSnapshot(childSnapshot, window)\n    el.appendChild(childSnapshot.node)\n  })\n\n  // remove children that shouldn't be there\n  const snapLength = snapshot.children.length\n\n  while (el.childNodes.length > snapLength) {\n    el.removeChild(el.childNodes[0])\n  }\n\n  // remove any clones from the DOM. This can happen when a block is split.\n  const { dataset } = el\n  if (!dataset) return // if there's no dataset, don't remove it\n  const key = dataset.key\n  if (!key) return // if there's no `data-key`, don't remove it\n  const dups = new window.Set(\n    Array.from(window.document.querySelectorAll(`[data-key='${key}']`))\n  )\n  dups.delete(el)\n  dups.forEach(dup => dup.parentElement.removeChild(dup))\n}\n\n/**\n * Takes a snapshot and applies it to the DOM. Rearranges both the contents\n * of the elements in the snapshot as well as putting the elements back into\n * position relative to each other and also makes sure the last element is\n * before the same element as it was when the snapshot was taken.\n *\n * @param {snapshot} snapshot\n * @param {Window} window\n */\n\nfunction applySnapshot(snapshot, window) {\n  const { elements, next, parent } = snapshot\n  elements.forEach(element => applyElementSnapshot(element, window))\n  const lastElement = elements[elements.length - 1].node\n\n  if (snapshot.next) {\n    parent.insertBefore(lastElement, next)\n  } else {\n    parent.appendChild(lastElement)\n  }\n\n  let prevElement = lastElement\n\n  for (let i = elements.length - 2; i >= 0; i--) {\n    const element = elements[i].node\n    parent.insertBefore(element, prevElement)\n    prevElement = element\n  }\n}\n\n/**\n * A snapshot of one or more elements.\n */\n\nexport default class ElementSnapshot {\n  /**\n   * constructor\n   * @param {elements[]} elements - array of element to snapshot. Must be in order.\n   * @param {object} data - any arbitrary data you want to store with the snapshot\n   */\n\n  constructor(elements, data) {\n    this.window = getWindow(elements[0])\n    this.snapshot = getSnapshot(elements, this.window)\n    this.data = data\n  }\n\n  /**\n   * apply the current snapshot to the DOM.\n   */\n\n  apply() {\n    applySnapshot(this.snapshot, this.window)\n  }\n\n  /**\n   * get the data you passed into the constructor.\n   *\n   * @return {object} data\n   */\n\n  getData() {\n    return this.data\n  }\n}\n","import getSelectionFromDom from './get-selection-from-dom'\nimport ElementSnapshot from './element-snapshot'\n\n/**\n * Returns the closest element that matches the selector.\n * Unlike the native `Element.closest` method, this doesn't require the\n * starting node to be an Element.\n *\n * @param  {Node} node to start at\n * @param  {String} css selector to match\n * @return {Element} the closest matching element\n */\n\nfunction closest(node, selector, win = window) {\n  if (node.nodeType === win.Node.TEXT_NODE) {\n    node = node.parentNode\n  }\n  return node.closest(selector)\n}\n\n/**\n * A DomSnapshot remembers the state of elements at a given point in time\n * and also remembers the state of the Editor at that time as well.\n * The state can be applied to the DOM at a time in the future.\n */\n\nexport default class DomSnapshot {\n  /**\n   * Constructor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {Boolean} options.before - should we remember the element before the one passed in\n   */\n\n  constructor(window, editor, { before = false } = {}) {\n    const domSelection = window.getSelection()\n    const { anchorNode } = domSelection\n    const subrootEl = closest(anchorNode, '[data-slate-editor] > *')\n    const elements = [subrootEl]\n\n    // The before option is for when we need to take a snapshot of the current\n    // subroot and the element before when the user hits the backspace key.\n    if (before) {\n      const { previousElementSibling } = subrootEl\n\n      if (previousElementSibling) {\n        elements.unshift(previousElementSibling)\n      }\n    }\n\n    this.snapshot = new ElementSnapshot(elements)\n    this.selection = getSelectionFromDom(window, editor, domSelection)\n  }\n\n  /**\n   * Apply the snapshot to the DOM and set the selection in the Editor.\n   *\n   * @param {Editor} editor\n   */\n\n  apply(editor) {\n    const { snapshot, selection } = this\n    snapshot.apply()\n    editor.moveTo(selection.anchor.key, selection.anchor.offset)\n  }\n}\n","/**\n * A function that does nothing\n * @return {Function}\n */\n\nfunction noop() {}\n\n/**\n * Creates an executor like a `resolver` or a `deleter` that handles\n * delayed execution of a method using a `requestAnimationFrame` or `setTimeout`.\n *\n * Unlike a `requestAnimationFrame`, after a method is cancelled, it can be\n * resumed. You can also optionally add a `timeout` after which time the\n * executor is automatically cancelled.\n */\n\nexport default class Executor {\n  /**\n   * Executor\n   * @param {window} window\n   * @param {Function} fn - the function to execute when done\n   * @param {Object} options\n   */\n\n  constructor(window, fn, options = {}) {\n    this.fn = fn\n    this.window = window\n    this.resume()\n    this.onCancel = options.onCancel\n    this.__setTimeout__(options.timeout)\n  }\n\n  __call__ = () => {\n    // I don't clear the timeout since it will be noop'ed anyways. Less code.\n    this.fn()\n    this.preventFurtherCalls() // Ensure you can only call the function once\n  }\n\n  /**\n   * Make sure that the function cannot be executed any more, even if other\n   * methods attempt to call `__call__`.\n   */\n\n  preventFurtherCalls = () => {\n    this.fn = noop\n  }\n\n  /**\n   * Resume the executor's timer, usually after it has been cancelled.\n   *\n   * @param {Number} [ms] - how long to wait by default it is until next frame\n   */\n\n  resume = ms => {\n    // in case resume is called more than once, we don't want old timers\n    // from executing because the `timeoutId` or `callbackId` is overwritten.\n    this.cancel()\n\n    if (ms) {\n      this.mode = 'timeout'\n      this.timeoutId = this.window.setTimeout(this.__call__, ms)\n    } else {\n      this.mode = 'animationFrame'\n      this.callbackId = this.window.requestAnimationFrame(this.__call__)\n    }\n  }\n\n  /**\n   * Cancel the executor from executing after the wait. This can be resumed\n   * with the `resume` method.\n   */\n\n  cancel = () => {\n    if (this.mode === 'timeout') {\n      this.window.clearTimeout(this.timeoutId)\n    } else {\n      this.window.cancelAnimationFrame(this.callbackId)\n    }\n\n    if (this.onCancel) this.onCancel()\n  }\n\n  /**\n   * Sets a timeout after which this executor is automatically cancelled.\n   * @param {Number} ms\n   */\n\n  __setTimeout__ = timeout => {\n    if (timeout == null) return\n\n    this.window.setTimeout(() => {\n      this.cancel()\n      this.preventFurtherCalls()\n    }, timeout)\n  }\n}\n","import Debug from 'debug'\nimport getWindow from 'get-window'\nimport pick from 'lodash/pick'\n\nimport { ANDROID_API_VERSION } from 'slate-dev-environment'\nimport fixSelectionInZeroWidthBlock from '../utils/fix-selection-in-zero-width-block'\nimport getSelectionFromDom from '../utils/get-selection-from-dom'\nimport setSelectionFromDom from '../utils/set-selection-from-dom'\nimport setTextFromDomNode from '../utils/set-text-from-dom-node'\nimport isInputDataEnter from '../utils/is-input-data-enter'\nimport isInputDataLastChar from '../utils/is-input-data-last-char'\nimport DomSnapshot from '../utils/dom-snapshot'\nimport Executor from '../utils/executor'\n\nconst debug = Debug('slate:android')\ndebug.reconcile = Debug('slate:reconcile')\n\ndebug('ANDROID_API_VERSION', { ANDROID_API_VERSION })\n\n/**\n * Define variables related to composition state.\n */\n\nconst NONE = 0\nconst COMPOSING = 1\n\nfunction AndroidPlugin() {\n  /**\n   * The current state of composition.\n   *\n   * @type {NONE|COMPOSING|WAITING}\n   */\n\n  let status = NONE\n\n  /**\n   * The set of nodes that we need to process when we next reconcile.\n   * Usually this is soon after the `onCompositionEnd` event.\n   *\n   * @type {Set} set containing Node objects\n   */\n\n  const nodes = new window.Set()\n\n  /**\n   * Keep a snapshot after a composition end for API 26/27. If a `beforeInput`\n   * gets called with data that ends in an ENTER then we need to use this\n   * snapshot to revert the DOM so that React doesn't get out of sync with the\n   * DOM. We also need to cancel the `reconcile` operation as it interferes in\n   * certain scenarios like hitting 'enter' at the end of a word.\n   *\n   * @type {DomSnapshot} [compositionEndSnapshot]\n   \n   */\n\n  let compositionEndSnapshot = null\n\n  /**\n   * When there is a `compositionEnd` we ened to reconcile Slate's Document\n   * with the DOM. The `reconciler` is an instance of `Executor` that does\n   * this for us. It is created on every `compositionEnd` and executes on the\n   * next `requestAnimationFrame`. The `Executor` can be cancelled and resumed\n   * which some methods do.\n   *\n   * @type {Executor}\n   */\n\n  let reconciler = null\n\n  /**\n   * A snapshot that gets taken when there is a `keydown` event in API26/27.\n   * If an `input` gets called with `inputType` of `deleteContentBackward`\n   * we need to undo the delete that Android does to keep React in sync with\n   * the DOM.\n   *\n   * @type {DomSnapshot}\n   */\n\n  let keyDownSnapshot = null\n\n  /**\n   * The deleter is an instace of `Executor` that will execute a delete\n   * operation on the next `requestAnimationFrame`. It has to wait because\n   * we need Android to finish all of its DOM operations to do with deletion\n   * before we revert them to a Snapshot. After reverting, we then execute\n   * Slate's version of delete.\n   *\n   * @type {Executor}\n   */\n\n  let deleter = null\n\n  /**\n   * Because Slate implements its own event handler for `beforeInput` in\n   * addition to React's version, we actually get two. If we cancel the\n   * first native version, the React one will still fire. We set this to\n   * `true` if we don't want that to happen. Remember that when we prevent it,\n   * we need to tell React to `preventDefault` so the event doesn't continue\n   * through React's event system.\n   *\n   * type {Boolean}\n   */\n\n  let preventNextBeforeInput = false\n\n  /**\n   * When a composition ends, in some API versions we may need to know what we\n   * have learned so far about the composition and what we want to do because of\n   * some actions that may come later.\n   *\n   * For example in API 26/27, if we get a `beforeInput` that tells us that the\n   * input was a `.`, then we want the reconcile to happen even if there are\n   * `onInput:delete` events that follow. In this case, we would set\n   * `compositionEndAction` to `period`. During the `onInput` we would check if\n   * the `compositionEndAction` says `period` and if so we would not start the\n   * `delete` action.\n   *\n   * @type {(String|null)}\n   */\n\n  let compositionEndAction = null\n\n  /**\n   * Looks at the `nodes` we have collected, usually the things we have edited\n   * during the course of a composition, and then updates Slate's internal\n   * Document based on the text values in these DOM nodes and also updates\n   * Slate's Selection based on the current cursor position in the Editor.\n   *\n   * @param {Window} window\n   * @param {Editor} editor\n   * @param {String} options.from - where reconcile was called from for debug\n   */\n\n  function reconcile(window, editor, { from }) {\n    debug.reconcile({ from })\n    const domSelection = window.getSelection()\n\n    nodes.forEach(node => {\n      setTextFromDomNode(window, editor, node)\n    })\n\n    setSelectionFromDom(window, editor, domSelection)\n    nodes.clear()\n  }\n\n  /**\n   * On before input.\n   *\n   * Check `components/content` because some versions of Android attach a\n   * native `beforeinput` event on the Editor. In this case, you might need\n   * to distinguish whether the event coming through is the native or React\n   * version of the event. Also, if you cancel the native version that does\n   * not necessarily mean that the React version is cancelled.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const isNative = !event.nativeEvent\n\n    debug('onBeforeInput', {\n      isNative,\n      event,\n      status,\n      e: pick(event, ['data', 'inputType', 'isComposing', 'nativeEvent']),\n    })\n\n    const window = getWindow(event.target)\n\n    if (preventNextBeforeInput) {\n      event.preventDefault()\n      preventNextBeforeInput = false\n      return\n    }\n\n    switch (ANDROID_API_VERSION) {\n      case 25:\n        // prevent onBeforeInput to allow selecting an alternate suggest to\n        // work.\n        break\n      case 26:\n      case 27:\n        if (deleter) {\n          deleter.cancel()\n          reconciler.resume()\n        }\n\n        // This analyses Android's native `beforeInput` which Slate adds\n        // on in the `Content` component. It only fires if the cursor is at\n        // the end of a block. Otherwise, the code below checks.\n        if (isNative) {\n          if (\n            event.inputType === 'insertParagraph' ||\n            event.inputType === 'insertLineBreak'\n          ) {\n            debug('onBeforeInput:enter:native', {})\n            const domSelection = window.getSelection()\n            const selection = getSelectionFromDom(window, editor, domSelection)\n            preventNextBeforeInput = true\n            event.preventDefault()\n            editor.moveTo(selection.anchor.key, selection.anchor.offset)\n            editor.splitBlock()\n          }\n        } else {\n          if (isInputDataLastChar(event.data, ['.'])) {\n            debug('onBeforeInput:period')\n            reconciler.cancel()\n            compositionEndAction = 'period'\n            return\n          }\n\n          // This looks at the beforeInput event's data property and sees if it\n          // ends in a linefeed which is character code 10. This appears to be\n          // the only way to detect that enter has been pressed except at end\n          // of line where it doesn't work.\n          const isEnter = isInputDataEnter(event.data)\n\n          if (isEnter) {\n            if (reconciler) reconciler.cancel()\n\n            window.requestAnimationFrame(() => {\n              debug('onBeforeInput:enter:react', {})\n              compositionEndSnapshot.apply(editor)\n              editor.splitBlock()\n            })\n          }\n        }\n\n        break\n      case 28:\n        // If a `beforeInput` event fires after an `input:deleteContentBackward`\n        // event, it appears to be a good indicator that it is some sort of\n        // special combined Android event. If this is the case, then we don't\n        // want to have a deletion to happen, we just want to wait until Android\n        // has done its thing and then at the end we just want to reconcile.\n        if (deleter) {\n          deleter.cancel()\n          reconciler.resume()\n        }\n\n        break\n      default:\n        if (status !== COMPOSING) next()\n    }\n  }\n\n  /**\n   * On Composition end. By default, when a `compositionEnd` event happens,\n   * we start a reconciler. The reconciler will update Slate's Document using\n   * the DOM as the source of truth. In some cases, the reconciler needs to\n   * be cancelled and can also be resumed. For example, when a delete\n   * immediately followed a `compositionEnd`, we don't want to reconcile.\n   * Instead, we want the `delete` to take precedence.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    debug('onCompositionEnd', { event })\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const { anchorNode } = domSelection\n\n    switch (ANDROID_API_VERSION) {\n      case 26:\n      case 27:\n        compositionEndSnapshot = new DomSnapshot(window, editor)\n        // fixes a bug in Android API 26 & 27 where a `compositionEnd` is triggered\n        // without the corresponding `compositionStart` event when clicking a\n        // suggestion.\n        //\n        // If we don't add this, the `onBeforeInput` is triggered and passes\n        // through to the `before` plugin.\n        status = COMPOSING\n        break\n    }\n\n    compositionEndAction = 'reconcile'\n    nodes.add(anchorNode)\n\n    reconciler = new Executor(window, () => {\n      status = NONE\n      reconcile(window, editor, { from: 'onCompositionEnd:reconciler' })\n      compositionEndAction = null\n    })\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    debug('onCompositionStart', { event })\n    status = COMPOSING\n    nodes.clear()\n  }\n\n  /**\n   * On composition update.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onCompositionUpdate(event, editor, next) {\n    debug('onCompositionUpdate', { event })\n  }\n\n  /**\n   * On input.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    debug('onInput', {\n      event,\n      status,\n      e: pick(event, ['data', 'nativeEvent', 'inputType', 'isComposing']),\n    })\n\n    switch (ANDROID_API_VERSION) {\n      case 24:\n      case 25:\n        break\n      case 26:\n      case 27:\n      case 28:\n        const { nativeEvent } = event\n\n        if (ANDROID_API_VERSION === 28) {\n          // NOTE API 28:\n          // When a user hits space and then backspace in `middle` we end up\n          // with `midle`.\n          //\n          // This is because when the user hits space, the composition is not\n          // ended because `compositionEnd` is not called yet. When backspace is\n          // hit, the `compositionEnd` is called. We need to revert the DOM but\n          // the reconciler has not had a chance to run from the\n          // `compositionEnd` because it is set to run on the next\n          // `requestAnimationFrame`. When the backspace is carried out on the\n          // Slate Value, Slate doesn't know about the space yet so the\n          // backspace is carried out without the space cuasing us to lose a\n          // character.\n          //\n          // This fix forces Android to reconcile immediately after hitting\n          // the space.\n          //\n          // NOTE API 27:\n          // It is confirmed that this bug does not present itself on API27.\n          // A space fires a `compositionEnd` (as well as other events including\n          // an input that is a delete) so the reconciliation happens.\n          //\n          if (\n            nativeEvent.inputType === 'insertText' &&\n            nativeEvent.data === ' '\n          ) {\n            if (reconciler) reconciler.cancel()\n            if (deleter) deleter.cancel()\n            reconcile(window, editor, { from: 'onInput:space' })\n            return\n          }\n        }\n\n        if (ANDROID_API_VERSION === 26 || ANDROID_API_VERSION === 27) {\n          if (compositionEndAction === 'period') {\n            debug('onInput:period:abort')\n            // This means that there was a `beforeInput` that indicated the\n            // period was pressed. When a period is pressed, you get a bunch\n            // of delete actions mixed in. We want to ignore those. At this\n            // point, we add the current node to the list of things we need to\n            // resolve at the next compositionEnd. We know that a new\n            // composition will start right after this event so it is safe to\n            // do this.\n            const { anchorNode } = window.getSelection()\n            nodes.add(anchorNode)\n            return\n          }\n        }\n\n        if (nativeEvent.inputType === 'deleteContentBackward') {\n          debug('onInput:delete', { keyDownSnapshot })\n          const window = getWindow(event.target)\n          if (reconciler) reconciler.cancel()\n          if (deleter) deleter.cancel()\n\n          deleter = new Executor(\n            window,\n            () => {\n              debug('onInput:delete:callback', { keyDownSnapshot })\n              keyDownSnapshot.apply(editor)\n              editor.deleteBackward()\n              deleter = null\n            },\n            {\n              onCancel() {\n                deleter = null\n              },\n            }\n          )\n          return\n        }\n\n        if (status === COMPOSING) {\n          const { anchorNode } = window.getSelection()\n          nodes.add(anchorNode)\n          return\n        }\n\n        // Some keys like '.' are input without compositions. This happens\n        // in API28. It might be happening in API 27 as well. Check by typing\n        // `It me. No.` On a blank line.\n        if (ANDROID_API_VERSION === 28) {\n          debug('onInput:fallback')\n          const { anchorNode } = window.getSelection()\n          nodes.add(anchorNode)\n\n          window.requestAnimationFrame(() => {\n            debug('onInput:fallback:callback')\n            reconcile(window, editor, { from: 'onInput:fallback' })\n          })\n          return\n        }\n\n        break\n      default:\n        if (status === COMPOSING) return\n        next()\n    }\n  }\n\n  /**\n   * On key down.\n   *\n   * @param  {Event} event\n   * @param  {Editor} editor\n   * @param  {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', {\n      event,\n      status,\n      e: pick(event, [\n        'char',\n        'charCode',\n        'code',\n        'key',\n        'keyCode',\n        'keyIdentifier',\n        'keyLocation',\n        'location',\n        'nativeEvent',\n        'which',\n      ]),\n    })\n\n    const window = getWindow(event.target)\n\n    switch (ANDROID_API_VERSION) {\n      // 1. We want to allow enter keydown to allows go through\n      // 2. We want to deny keydown, I think, when it fires before the composition\n      //    or something. Need to remember what it was.\n\n      case 25:\n        // in API25 prevent other keys to fix clicking a word and then\n        // selecting an alternate suggestion.\n        //\n        // NOTE:\n        // The `setSelectionFromDom` is to allow hitting `Enter` to work\n        // because the selection needs to be in the right place; however,\n        // for now we've removed the cancelling of `onSelect` and everything\n        // appears to be working. Not sure why we removed `onSelect` though\n        // in API25.\n        if (event.key === 'Enter') {\n          // const window = getWindow(event.target)\n          // const selection = window.getSelection()\n          // setSelectionFromDom(window, editor, selection)\n          next()\n        }\n\n        break\n      case 26:\n      case 27:\n        if (event.key === 'Enter') {\n          debug('onKeyDown:enter', {})\n\n          if (deleter) {\n            // If a `deleter` exists which means there was an onInput with\n            // `deleteContentBackward` that hasn't fired yet, then we know\n            // this is one of the cases where we have to revert to before\n            // the split.\n            deleter.cancel()\n            event.preventDefault()\n\n            window.requestAnimationFrame(() => {\n              debug('onKeyDown:enter:callback')\n              compositionEndSnapshot.apply(editor)\n              editor.splitBlock()\n            })\n          } else {\n            event.preventDefault()\n            // If there is no deleter, all we have to do is prevent the\n            // action before applying or splitBlock. In this scenario, we\n            // have to grab the selection from the DOM.\n            const domSelection = window.getSelection()\n            const selection = getSelectionFromDom(window, editor, domSelection)\n            editor.moveTo(selection.anchor.key, selection.anchor.offset)\n            editor.splitBlock()\n          }\n          return\n        }\n\n        // We need to take a snapshot of the current selection and the\n        // element before when the user hits the backspace key. This is because\n        // we only know if the user hit backspace if the `onInput` event that\n        // follows has an `inputType` of `deleteContentBackward`. At that time\n        // it's too late to stop the event.\n        keyDownSnapshot = new DomSnapshot(window, editor, {\n          before: true,\n        })\n\n        // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n        break\n      case 28:\n        {\n          if (event.key === 'Enter') {\n            debug('onKeyDown:enter')\n            event.preventDefault()\n            if (reconciler) reconciler.cancel()\n            if (deleter) deleter.cancel()\n\n            window.requestAnimationFrame(() => {\n              reconcile(window, editor, { from: 'onKeyDown:enter' })\n              editor.splitBlock()\n            })\n            return\n          }\n\n          // We need to take a snapshot of the current selection and the\n          // element before when the user hits the backspace key. This is because\n          // we only know if the user hit backspace if the `onInput` event that\n          // follows has an `inputType` of `deleteContentBackward`. At that time\n          // it's too late to stop the event.\n          keyDownSnapshot = new DomSnapshot(window, editor, {\n            before: true,\n          })\n\n          debug('onKeyDown:snapshot', { keyDownSnapshot })\n        }\n\n        // If we let 'Enter' through it breaks handling of hitting\n        // enter at the beginning of a word so we need to stop it.\n        break\n\n      default:\n        if (status !== COMPOSING) {\n          next()\n        }\n    }\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', { event, status })\n\n    switch (ANDROID_API_VERSION) {\n      // We don't want to have the selection move around in an onSelect because\n      // it happens after we press `enter` in the same transaction. This\n      // causes the cursor position to not be properly placed.\n      case 26:\n      case 27:\n      case 28:\n        const window = getWindow(event.target)\n        fixSelectionInZeroWidthBlock(window)\n        break\n      default:\n        break\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onCompositionEnd,\n    onCompositionStart,\n    onCompositionUpdate,\n    onInput,\n    onKeyDown,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AndroidPlugin\n","/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nconst TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain',\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default TRANSFER_TYPES\n","import { Node } from 'slate'\n\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key, win = window) {\n  if (Node.isNode(key)) {\n    key = key.key\n  }\n\n  const el = win.document.querySelector(`[data-key=\"${key}\"]`)\n\n  if (!el) {\n    throw new Error(\n      `Unable to find a DOM node for \"${key}\". This is often because of forgetting to add \\`props.attributes\\` to a custom component.`\n    )\n  }\n\n  return el\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMNode\n","/**\n * COMPAT: if we are in <= IE11 and the selection contains\n * tables, `removeAllRanges()` will throw\n * \"unable to complete the operation due to error 800a025e\"\n *\n * @param {Selection} selection document selection\n */\n\nfunction removeAllRanges(selection) {\n  const doc = window.document\n\n  if (doc && doc.body.createTextRange) {\n    // All IE but Edge\n    const range = doc.body.createTextRange()\n    range.collapse()\n    range.select()\n  } else {\n    selection.removeAllRanges()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default removeAllRanges\n","import Base64 from 'slate-base64-serializer'\nimport Plain from 'slate-plain-serializer'\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport findDOMNode from './find-dom-node'\nimport getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport removeAllRanges from './remove-all-ranges'\nimport { IS_IE } from 'slate-dev-environment'\nimport { Value } from 'slate'\nimport { ZERO_WIDTH_SELECTOR, ZERO_WIDTH_ATTRIBUTE } from './find-point'\n\nconst { FRAGMENT, HTML, TEXT } = TRANSFER_TYPES\n\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor, callback = () => undefined) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.'\n  )\n\n  const window = getWindow(event.target)\n  const native = window.getSelection()\n  const { value } = editor\n  const { document, fragment, selection } = value\n  const { start, end } = selection\n  const startVoid = document.getClosestVoid(start.key, editor)\n  const endVoid = document.getClosestVoid(end.key, editor)\n\n  // If the selection is collapsed, and it isn't inside a void node, abort.\n  if (native.isCollapsed && !startVoid) return\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  const encoded = Base64.serializeNode(fragment)\n  const range = native.getRangeAt(0)\n  let contents = range.cloneContents()\n  let attach = contents.childNodes[0]\n\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\n  contents.childNodes.forEach(node => {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node\n    }\n  })\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    const r = range.cloneRange()\n    const node = findDOMNode(endVoid, window)\n    r.setEndAfter(node)\n    contents = r.cloneContents()\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  ;[].slice.call(contents.querySelectorAll(ZERO_WIDTH_SELECTOR)).forEach(zw => {\n    const isNewline = zw.getAttribute(ZERO_WIDTH_ATTRIBUTE) === 'n'\n    zw.textContent = isNewline ? '\\n' : ''\n  })\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (attach.nodeType === 3) {\n    const span = window.document.createElement('span')\n\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre'\n\n    span.appendChild(attach)\n    contents.appendChild(span)\n    attach = span\n  }\n\n  attach.setAttribute('data-slate-fragment', encoded)\n\n  //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n  const valFromSelection = Value.create({ document: fragment })\n  const plainText = Plain.serialize(valFromSelection)\n\n  // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n  const div = window.document.createElement('div')\n  div.appendChild(contents)\n\n  // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault()\n    event.clipboardData.setData(TEXT, plainText)\n    event.clipboardData.setData(FRAGMENT, encoded)\n    event.clipboardData.setData(HTML, div.innerHTML)\n    callback()\n    return\n  }\n\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n  const editorEl = event.target.closest('[data-slate-editor]')\n  div.setAttribute('contenteditable', true)\n  div.style.position = 'absolute'\n  div.style.left = '-9999px'\n  editorEl.appendChild(div)\n  native.selectAllChildren(div)\n\n  // Revert to the previous selection right after copying.\n  window.requestAnimationFrame(() => {\n    editorEl.removeChild(div)\n    removeAllRanges(native)\n    native.addRange(range)\n    callback()\n  })\n}\n\nexport default cloneFragment\n","import invariant from 'tiny-invariant'\nimport { Value } from 'slate'\n\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\nfunction findNode(element, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const closest = element.closest('[data-key]')\n  if (!closest) return null\n\n  const key = closest.getAttribute('data-key')\n  if (!key) return null\n\n  const { value } = editor\n  const { document } = value\n  const node = document.getNode(key)\n  return node || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findNode\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { Value } from 'slate'\n\nimport findNode from './find-node'\nimport findRange from './find-range'\n\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction getEventRange(event, editor) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const { clientX: x, clientY: y, target } = event\n  if (x == null || y == null) return null\n\n  const { value } = editor\n  const { document } = value\n  const node = findNode(target, editor)\n  if (!node) return null\n\n  // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n  if (editor.query('isVoid', node)) {\n    const rect = target.getBoundingClientRect()\n    const isPrevious =\n      node.object === 'inline'\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n    const text = node.getFirstText()\n    const range = document.createRange()\n\n    if (isPrevious) {\n      const previousText = document.getPreviousText(text.key)\n\n      if (previousText) {\n        return range.moveToEndOfNode(previousText)\n      }\n    }\n\n    const nextText = document.getNextText(text.key)\n    return nextText ? range.moveToStartOfNode(nextText) : null\n  }\n\n  // Else resolve a range from the caret position where the drop occured.\n  const window = getWindow(target)\n  let native\n\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y)\n  } else if (window.document.caretPositionFromPoint) {\n    const position = window.document.caretPositionFromPoint(x, y)\n    native = window.document.createRange()\n    native.setStart(position.offsetNode, position.offset)\n    native.setEnd(position.offsetNode, position.offset)\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange()\n\n    try {\n      native.moveToPoint(x, y)\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null\n    }\n  }\n\n  // Resolve a Slate range from the DOM range.\n  const range = findRange(native, editor)\n  if (!range) return null\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventRange\n","import Base64 from 'slate-base64-serializer'\nimport { IS_IE } from 'slate-dev-environment'\nimport TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nconst { FRAGMENT, HTML, NODE, RICH, TEXT } = TRANSFER_TYPES\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nconst FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n  let fragment = getType(transfer, FRAGMENT)\n  let node = getType(transfer, NODE)\n  const html = getType(transfer, HTML)\n  const rich = getType(transfer, RICH)\n  let text = getType(transfer, TEXT)\n  let files\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(' data-slate-fragment=\"')) {\n    const matches = FRAGMENT_MATCHER.exec(html)\n    const [full, encoded] = matches // eslint-disable-line no-unused-vars\n    if (encoded) fragment = encoded\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    const embeddedTypes = getEmbeddedTypes(text)\n\n    if (embeddedTypes[FRAGMENT]) fragment = embeddedTypes[FRAGMENT]\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE]\n    if (embeddedTypes[TEXT]) text = embeddedTypes[TEXT]\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = Base64.deserializeNode(fragment)\n  if (node) node = Base64.deserializeNode(node)\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items)\n        .map(item => (item.kind === 'file' ? item.getAsFile() : null))\n        .filter(exists => exists)\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  }\n\n  // Determine the type of the data.\n  const data = { files, fragment, html, node, rich, text }\n  data.type = getTransferType(data)\n  return data\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  const prefix = 'SLATE-DATA-EMBED::'\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return { TEXT: text }\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length))\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.')\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment'\n  if (data.node) return 'node'\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html'\n  if (data.rich && data.text) return 'text'\n\n  if (data.files && data.files.length) return 'files'\n  if (data.html) return 'html'\n  if (data.text) return 'text'\n  return 'unknown'\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT ? transfer.getData('Text') || null : null\n  }\n\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n  const types = Array.from(transfer.types)\n\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventTransfer\n","import TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nconst { TEXT } = TRANSFER_TYPES\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  const mime = TRANSFER_TYPES[type.toUpperCase()]\n\n  if (!mime) {\n    throw new Error(`Cannot set unknown transfer type \"${mime}\".`)\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n\n  try {\n    transfer.setData(mime, content)\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n    transfer.setData('text', transfer.getData('text'))\n  } catch (err) {\n    const prefix = 'SLATE-DATA-EMBED::'\n    const text = transfer.getData(TEXT)\n    let obj = {}\n\n    // If the existing plain text data is prefixed, it's Slate JSON data.\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length))\n      } catch (e) {\n        throw new Error(\n          'Failed to parse Slate data from `DataTransfer` object.'\n        )\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT] = text\n    }\n\n    obj[mime] = content\n    const string = `${prefix}${JSON.stringify(obj)}`\n    transfer.setData(TEXT, string)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default setEventTransfer\n","import Base64 from 'slate-base64-serializer'\nimport Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport { IS_IOS, IS_IE, IS_EDGE } from 'slate-dev-environment'\n\nimport cloneFragment from '../utils/clone-fragment'\nimport findDOMNode from '../utils/find-dom-node'\nimport findNode from '../utils/find-node'\nimport findRange from '../utils/find-range'\nimport getEventRange from '../utils/get-event-range'\nimport getEventTransfer from '../utils/get-event-transfer'\nimport setEventTransfer from '../utils/set-event-transfer'\nimport setSelectionFromDom from '../utils/set-selection-from-dom'\nimport setTextFromDomNode from '../utils/set-text-from-dom-node'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:after')\n\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin(options = {}) {\n  let isDraggingInternally = null\n  let isMouseDown = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const { value } = editor\n    const isSynthetic = !!event.nativeEvent\n\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n    if (isSynthetic) {\n      event.preventDefault()\n      editor.insertText(event.data)\n      return next()\n    }\n\n    // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n    const [targetRange] = event.getTargetRanges()\n    if (!targetRange) return next()\n\n    debug('onBeforeInput', { event })\n\n    event.preventDefault()\n\n    const { document, selection } = value\n    const range = findRange(targetRange, editor)\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward': {\n        editor.deleteAtRange(range)\n        break\n      }\n\n      case 'deleteWordBackward': {\n        editor.deleteWordBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteWordForward': {\n        editor.deleteWordForwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward': {\n        editor.deleteLineBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward': {\n        editor.deleteLineForwardAtRange(range)\n        break\n      }\n\n      case 'insertLineBreak':\n      case 'insertParagraph': {\n        const hasVoidParent = document.hasVoidParent(\n          selection.start.path,\n          editor\n        )\n\n        if (hasVoidParent) {\n          editor.moveToStartOfNextText()\n        } else {\n          editor.splitBlockAtRange(range)\n        }\n\n        break\n      }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText': {\n        // COMPAT: `data` should have the text for the `insertText` input type\n        // and `dataTransfer` should have the text for the\n        // `insertReplacementText` input type, but Safari uses `insertText` for\n        // spell check replacements and sets `data` to `null`. (2018/08/09)\n        const text =\n          event.data == null\n            ? event.dataTransfer.getData('text/plain')\n            : event.data\n\n        if (text == null) break\n\n        editor.insertTextAtRange(range, text, selection.marks)\n\n        // If the text was successfully inserted, and the selection had marks\n        // on it, unset the selection's marks.\n        if (selection.marks && value.document !== editor.value.document) {\n          editor.select({ marks: null })\n        }\n\n        break\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    debug('onBlur', { event })\n    editor.blur()\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next()\n\n    const { value } = editor\n    const { document } = value\n    const node = findNode(event.target, editor)\n    if (!node) return next()\n\n    debug('onClick', { event })\n\n    const ancestors = document.getAncestors(node.key)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node)\n    }\n\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    debug('onCopy', { event })\n    cloneFragment(event, editor)\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    debug('onCut', { event })\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    cloneFragment(event, editor, () => {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      const { value } = editor\n      const { endBlock, endInline, selection } = value\n      const { isCollapsed } = selection\n      const isVoidBlock = endBlock && editor.isVoid(endBlock) && isCollapsed\n      const isVoidInline = endInline && editor.isVoid(endInline) && isCollapsed\n\n      if (isVoidBlock) {\n        editor.removeNodeByKey(endBlock.key)\n      } else if (isVoidInline) {\n        editor.removeNodeByKey(endInline.key)\n      } else {\n        editor.delete()\n      }\n    })\n\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    debug('onDragEnd', { event })\n    isDraggingInternally = null\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    debug('onDragStart', { event })\n\n    isDraggingInternally = true\n\n    const { value } = editor\n    const { document } = value\n    const node = findNode(event.target, editor)\n    const ancestors = document.getAncestors(node.key)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n    const selectionIncludesNode = value.blocks.some(\n      block => block.key === node.key\n    )\n\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node)\n    }\n\n    const fragment = editor.value.fragment\n    const encoded = Base64.serializeNode(fragment)\n    setEventTransfer(event, 'fragment', encoded)\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    const { value } = editor\n    const { document, selection } = value\n    const window = getWindow(event.target)\n    let target = getEventRange(event, editor)\n    if (!target) return next()\n\n    debug('onDrop', { event })\n\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    editor.focus()\n\n    // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n    if (\n      isDraggingInternally &&\n      selection.end.key === target.end.key &&\n      selection.end.offset < target.end.offset\n    ) {\n      target = target.moveForward(\n        selection.start.key === selection.end.key\n          ? 0 - selection.end.offset + selection.start.offset\n          : 0 - selection.end.offset\n      )\n    }\n\n    if (isDraggingInternally) {\n      editor.delete()\n    }\n\n    editor.select(target)\n\n    if (type === 'text' || type === 'html') {\n      const { anchor } = target\n      let hasVoidParent = document.hasVoidParent(anchor.key, editor)\n\n      if (hasVoidParent) {\n        let n = document.getNode(anchor.key)\n\n        while (hasVoidParent) {\n          n = document.getNextText(n.key)\n          if (!n) break\n          hasVoidParent = document.hasVoidParent(n.key, editor)\n        }\n\n        if (n) editor.moveToStartOfNode(n)\n      }\n\n      if (text) {\n        text.split('\\n').forEach((line, i) => {\n          if (i > 0) editor.splitBlock()\n          editor.insertText(line)\n        })\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n    const focusNode = document.getNode(target.focus.key)\n    const el = findDOMNode(focusNode, window)\n\n    if (el) {\n      el.dispatchEvent(\n        new MouseEvent('mouseup', {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n        })\n      )\n    }\n\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    debug('onFocus', { event })\n\n    // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n    if (isMouseDown && !IS_IE && !IS_EDGE) {\n      editor.deselect().focus()\n    } else {\n      editor.focus()\n    }\n\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    debug('onInput')\n    const window = getWindow(event.target)\n\n    // Get the selection point.\n    const selection = window.getSelection()\n    const { anchorNode } = selection\n\n    setTextFromDomNode(window, editor, anchorNode)\n    setSelectionFromDom(window, editor, selection)\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', { event })\n\n    const { value } = editor\n    const { document, selection } = value\n    const hasVoidParent = document.hasVoidParent(selection.start.path, editor)\n\n    // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent\n        ? editor.moveToStartOfNextText()\n        : editor.splitBlock()\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward()\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward()\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward()\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward()\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward()\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward()\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo()\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo()\n    }\n\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveToStartOfBlock()\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault()\n      return editor.moveToEndOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToStartOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToEndOfBlock()\n    }\n\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart()\n      }\n\n      return editor.moveBackward()\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd()\n      }\n\n      return editor.moveForward()\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n      return editor.moveWordBackward()\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n      return editor.moveWordForward()\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      const { previousText, startText } = value\n      const isPreviousInVoid =\n        previousText && document.hasVoidParent(previousText.key, editor)\n\n      if (hasVoidParent || isPreviousInVoid || startText.text === '') {\n        event.preventDefault()\n        return editor.moveFocusBackward()\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      const { nextText, startText } = value\n      const isNextInVoid =\n        nextText && document.hasVoidParent(nextText.key, editor)\n\n      if (hasVoidParent || isNextInVoid || startText.text === '') {\n        event.preventDefault()\n        return editor.moveFocusForward()\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseDown(event, editor, next) {\n    debug('onMouseDown', { event })\n    isMouseDown = true\n    next()\n  }\n\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseUp(event, editor, next) {\n    debug('onMouseUp', { event })\n    isMouseDown = false\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    debug('onPaste', { event })\n\n    const { value } = editor\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next()\n      const { document, selection, startBlock } = value\n      if (editor.isVoid(startBlock)) return next()\n\n      const defaultBlock = startBlock\n      const defaultMarks = document.getInsertMarksAtRange(selection)\n      const frag = Plain.deserialize(text, { defaultBlock, defaultMarks })\n        .document\n      editor.insertFragment(frag)\n    }\n\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', { event })\n    const window = getWindow(event.target)\n    const selection = window.getSelection()\n    setSelectionFromDom(window, editor, selection)\n\n    // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n    isMouseDown = false\n\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onMouseDown,\n    onMouseUp,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AfterPlugin\n","import Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport ReactDOM from 'react-dom'\nimport getWindow from 'get-window'\nimport {\n  IS_FIREFOX,\n  IS_IE,\n  IS_IOS,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport findNode from '../utils/find-node'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:before')\n\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  let activeElement = null\n  let compositionCount = 0\n  let isComposing = false\n  let isCopying = false\n  let isDragging = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const isSynthetic = !!event.nativeEvent\n    if (editor.readOnly) return\n\n    // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return\n\n    debug('onBeforeInput', { event })\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const { relatedTarget, target } = event\n    const window = getWindow(target)\n\n    // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n    if (activeElement === window.document.activeElement) return\n\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n    if (relatedTarget) {\n      const el = ReactDOM.findDOMNode(editor)\n\n      // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n      if (relatedTarget === el) return\n\n      // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n      if (relatedTarget.hasAttribute('data-slate-spacer')) return\n\n      // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n      const node = findNode(relatedTarget, editor)\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) return\n    }\n\n    debug('onBlur', { event })\n    next()\n  }\n\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    const n = compositionCount\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n    window.requestAnimationFrame(() => {\n      if (compositionCount > n) return\n      isComposing = false\n    })\n\n    debug('onCompositionEnd', { event })\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    debug('onClick', { event })\n    next()\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true\n    compositionCount++\n\n    const { value } = editor\n    const { selection } = value\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete()\n    }\n\n    debug('onCompositionStart', { event })\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCopy', { event })\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return\n\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCut', { event })\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false\n    debug('onDragEnd', { event })\n    next()\n  }\n\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnter(event, editor, next) {\n    debug('onDragEnter', { event })\n    next()\n  }\n\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragExit(event, editor, next) {\n    debug('onDragExit', { event })\n    next()\n  }\n\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragLeave(event, editor, next) {\n    debug('onDragLeave', { event })\n    next()\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    const node = findNode(event.target, editor)\n    if (editor.isVoid(node)) event.preventDefault()\n\n    // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n    if (IS_IE) {\n      event.preventDefault()\n    }\n\n    // If a drag is already in progress, don't do this again.\n    if (!isDragging) {\n      isDragging = true\n\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move'\n      }\n    }\n\n    debug('onDragOver', { event })\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    isDragging = true\n    debug('onDragStart', { event })\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return\n\n    // Prevent default so the DOM's value isn't corrupted.\n    event.preventDefault()\n\n    debug('onDrop', { event })\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const el = ReactDOM.findDOMNode(editor)\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (IS_FIREFOX && event.target !== el) {\n      el.focus()\n      return\n    }\n\n    debug('onFocus', { event })\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    if (isComposing) return\n    if (editor.value.selection.isBlurred) return\n    debug('onInput', { event })\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return\n\n    // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault()\n      return\n    }\n\n    // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n    if (\n      !IS_IOS &&\n      (Hotkeys.isBold(event) ||\n        Hotkeys.isDeleteBackward(event) ||\n        Hotkeys.isDeleteForward(event) ||\n        Hotkeys.isDeleteLineBackward(event) ||\n        Hotkeys.isDeleteLineForward(event) ||\n        Hotkeys.isDeleteWordBackward(event) ||\n        Hotkeys.isDeleteWordForward(event) ||\n        Hotkeys.isItalic(event) ||\n        Hotkeys.isRedo(event) ||\n        Hotkeys.isSplitBlock(event) ||\n        Hotkeys.isTransposeCharacter(event) ||\n        Hotkeys.isUndo(event))\n    ) {\n      event.preventDefault()\n    }\n\n    debug('onKeyDown', { event })\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return\n\n    // Prevent defaults so the DOM state isn't corrupted.\n    event.preventDefault()\n\n    debug('onPaste', { event })\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return\n    if (isComposing) return\n\n    if (editor.readOnly) return\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    debug('onSelect', { event })\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCompositionEnd,\n    onCompositionStart,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragEnter,\n    onDragExit,\n    onDragLeave,\n    onDragOver,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default BeforePlugin\n","import { IS_ANDROID } from 'slate-dev-environment'\nimport AndroidPlugin from './android'\nimport AfterPlugin from './after'\nimport BeforePlugin from './before'\n\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction DOMPlugin(options = {}) {\n  const { plugins = [] } = options\n  // Add Android specific handling separately before it gets to the other\n  // plugins because it is specific (other browser don't need it) and finicky\n  // (it has to come before other plugins to work).\n  const beforeBeforePlugins = IS_ANDROID ? [AndroidPlugin()] : []\n  const beforePlugin = BeforePlugin()\n  const afterPlugin = AfterPlugin()\n  return [...beforeBeforePlugins, beforePlugin, ...plugins, afterPlugin]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DOMPlugin\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport SlateTypes from 'slate-prop-types'\n\nimport OffsetKey from '../utils/offset-key'\n\n/**\n * Debugger.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:leaves')\n\n/**\n * Leaf.\n *\n * @type {Component}\n */\n\nclass Leaf extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block.isRequired,\n    editor: Types.object.isRequired,\n    index: Types.number.isRequired,\n    leaves: SlateTypes.leaves.isRequired,\n    marks: SlateTypes.marks.isRequired,\n    node: SlateTypes.node.isRequired,\n    offset: Types.number.isRequired,\n    parent: SlateTypes.node.isRequired,\n    text: Types.string.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    debug(message, `${this.props.node.key}-${this.props.index}`, ...args)\n  }\n\n  /**\n   * Should component update?\n   *\n   * @param {Object} props\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(props) {\n    // If any of the regular properties have changed, re-render.\n    if (\n      props.index !== this.props.index ||\n      props.marks !== this.props.marks ||\n      props.text !== this.props.text ||\n      props.parent !== this.props.parent\n    ) {\n      return true\n    }\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render the leaf.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n\n    const { node, index } = this.props\n    const offsetKey = OffsetKey.stringify({\n      key: node.key,\n      index,\n    })\n\n    return (\n      <span data-slate-leaf data-offset-key={offsetKey}>\n        {this.renderMarks()}\n      </span>\n    )\n  }\n\n  /**\n   * Render all of the leaf's mark components.\n   *\n   * @return {Element}\n   */\n\n  renderMarks() {\n    const { marks, node, offset, text, editor } = this.props\n    const leaf = this.renderText()\n    const attributes = {\n      'data-slate-mark': true,\n    }\n\n    return marks.reduce((children, mark) => {\n      const props = {\n        editor,\n        mark,\n        marks,\n        node,\n        offset,\n        text,\n        children,\n        attributes,\n      }\n      const element = editor.run('renderMark', props)\n      return element || children\n    }, leaf)\n  }\n\n  /**\n   * Render the text content of the leaf, accounting for browsers.\n   *\n   * @return {Element}\n   */\n\n  renderText() {\n    const { block, node, editor, parent, text, index, leaves } = this.props\n\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    if (editor.query('isVoid', parent)) {\n      return (\n        <span data-slate-zero-width=\"z\" data-slate-length={parent.text.length}>\n          {'\\uFEFF'}\n        </span>\n      )\n    }\n\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    if (\n      text === '' &&\n      parent.object === 'block' &&\n      parent.text === '' &&\n      parent.nodes.last() === node\n    ) {\n      return (\n        <span data-slate-zero-width=\"n\" data-slate-length={0}>\n          {'\\uFEFF'}\n          <br />\n        </span>\n      )\n    }\n\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    if (text === '') {\n      return (\n        <span data-slate-zero-width=\"z\" data-slate-length={0}>\n          {'\\uFEFF'}\n        </span>\n      )\n    }\n\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    const lastText = block.getLastText()\n    const lastChar = text.charAt(text.length - 1)\n    const isLastText = node === lastText\n    const isLastLeaf = index === leaves.size - 1\n    if (isLastText && isLastLeaf && lastChar === '\\n')\n      return <span data-slate-content>{`${text}\\n`}</span>\n\n    // Otherwise, just return the content.\n    return <span data-slate-content>{text}</span>\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Leaf\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport Leaf from './leaf'\nimport { PathUtils } from 'slate'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Text.\n *\n * @type {Component}\n */\n\nclass Text extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    style: Types.object,\n  }\n\n  /**\n   * Default prop types.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: null,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key } = node\n    debug(message, `${key} (text)`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate = nextProps => {\n    const { props } = this\n    const n = nextProps\n    const p = props\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node !== p.node) return true\n\n    // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    if (n.parent.object === 'block') {\n      const pLast = p.parent.nodes.last()\n      const nLast = n.parent.nodes.last()\n      if (p.node === pLast && n.node !== nLast) return true\n    }\n\n    // Re-render if the current decorations have changed.\n    if (!n.decorations.equals(p.decorations)) return true\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n\n    const { decorations, editor, node, style } = this.props\n    const { value } = editor\n    const { document } = value\n    const { key } = node\n\n    const decs = decorations.filter(d => {\n      const { start, end } = d\n\n      // If either of the decoration's keys match, include it.\n      if (start.key === key || end.key === key) return true\n\n      // Otherwise, if the decoration is in a single node, it's not ours.\n      if (start.key === end.key) return false\n\n      const path = document.assertPath(key)\n      const startPath = start.path || document.assertPath(start.key)\n      const endPath = end.path || document.assertPath(end.key)\n\n      // If the node's path is before the start path, ignore it.\n      if (PathUtils.compare(path, startPath) === -1) return false\n\n      // If the node's path is after the end path, ignore it.\n      if (PathUtils.compare(path, endPath) === 1) return false\n\n      // Otherwise, include it.\n      return true\n    })\n\n    // PERF: Take advantage of cache by avoiding arguments\n    const leaves = decs.size === 0 ? node.getLeaves() : node.getLeaves(decs)\n    let offset = 0\n\n    const children = leaves.map((leaf, i) => {\n      const child = this.renderLeaf(leaves, leaf, i, offset)\n      offset += leaf.text.length\n      return child\n    })\n\n    return (\n      <span data-key={key} style={style}>\n        {children}\n      </span>\n    )\n  }\n\n  /**\n   * Render a single leaf given a `leaf` and `offset`.\n   *\n   * @param {List<Leaf>} leaves\n   * @param {Leaf} leaf\n   * @param {Number} index\n   * @param {Number} offset\n   * @return {Element} leaf\n   */\n\n  renderLeaf = (leaves, leaf, index, offset) => {\n    const { block, node, parent, editor } = this.props\n    const { text, marks } = leaf\n\n    return (\n      <Leaf\n        key={`${node.key}-${index}`}\n        block={block}\n        editor={editor}\n        index={index}\n        marks={marks}\n        node={node}\n        offset={offset}\n        parent={parent}\n        leaves={leaves}\n        text={text}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Text\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\nimport Text from './text'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:void')\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nclass Void extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    children: Types.any.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    const id = `${key} (${type})`\n    debug(message, `${id}`, ...args)\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props } = this\n    const { children, node, readOnly } = props\n    const Tag = node.object === 'block' ? 'div' : 'span'\n    const style = {\n      height: '0',\n      color: 'transparent',\n      outline: 'none',\n      position: 'absolute',\n    }\n\n    const spacer = (\n      <Tag data-slate-spacer style={style}>\n        {this.renderText()}\n      </Tag>\n    )\n\n    const content = (\n      <Tag contentEditable={readOnly ? null : false}>{children}</Tag>\n    )\n\n    this.debug('render', { props })\n\n    return (\n      <Tag\n        data-slate-void\n        data-key={node.key}\n        contentEditable={readOnly || node.object === 'block' ? null : false}\n      >\n        {readOnly ? null : spacer}\n        {content}\n      </Tag>\n    )\n  }\n\n  /**\n   * Render the void node's text node, which will catch the cursor when it the\n   * void node is navigated to with the arrow keys.\n   *\n   * Having this text node there means the browser continues to manage the\n   * selection natively, so it keeps track of the right offset when moving\n   * across the block.\n   *\n   * @return {Element}\n   */\n\n  renderText = () => {\n    const { block, decorations, node, readOnly, editor } = this.props\n    const child = node.getFirstText()\n    return (\n      <Text\n        block={node.object === 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Void\n","import { Set } from 'immutable'\n\n/**\n * Split the decorations in lists of relevant decorations for each child.\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<List<Decoration>>}\n */\n\nfunction getChildrenDecorations(node, decorations) {\n  const activeDecorations = Set().asMutable()\n  const childrenDecorations = []\n\n  orderChildDecorations(node, decorations).forEach(item => {\n    if (item.isRangeStart) {\n      // Item is a decoration start\n      activeDecorations.add(item.decoration)\n    } else if (item.isRangeEnd) {\n      // item is a decoration end\n      activeDecorations.remove(item.decoration)\n    } else {\n      // Item is a child node\n      childrenDecorations.push(activeDecorations.toList())\n    }\n  })\n\n  return childrenDecorations\n}\n\n/**\n * Orders the children of provided node and its decoration endpoints (start, end)\n * so that decorations can be passed only to relevant children (see use in Node.render())\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<Item>}\n *\n * where type Item =\n * {\n *   child: Node,\n *   // Index of the child in its parent\n *   index: number\n * }\n * or {\n *   // True if this represents the start of the given decoration\n *   isRangeStart: boolean,\n *   // True if this represents the end of the given decoration\n *   isRangeEnd: boolean,\n *   decoration: Range\n * }\n */\n\nfunction orderChildDecorations(node, decorations) {\n  if (decorations.isEmpty()) {\n    return node.nodes.toArray().map((child, index) => ({\n      child,\n      index,\n    }))\n  }\n\n  // Map each key to its global order\n  const keyOrders = { [node.key]: 0 }\n  let globalOrder = 1\n\n  node.forEachDescendant(child => {\n    keyOrders[child.key] = globalOrder\n    globalOrder = globalOrder + 1\n  })\n\n  const childNodes = node.nodes.toArray()\n\n  const endPoints = childNodes.map((child, index) => ({\n    child,\n    index,\n    order: keyOrders[child.key],\n  }))\n\n  decorations.forEach(decoration => {\n    // Range start.\n    // A rangeStart should be before the child containing its startKey, in order\n    // to consider it active before going down the child.\n    const startKeyOrder = keyOrders[decoration.start.key]\n    const containingChildOrder =\n      startKeyOrder === undefined\n        ? 0\n        : getContainingChildOrder(childNodes, keyOrders, startKeyOrder)\n\n    endPoints.push({\n      isRangeStart: true,\n      order: containingChildOrder - 0.5,\n      decoration,\n    })\n\n    // Range end.\n    const endKeyOrder = (keyOrders[decoration.end.key] || globalOrder) + 0.5\n\n    endPoints.push({\n      isRangeEnd: true,\n      order: endKeyOrder,\n      decoration,\n    })\n  })\n\n  return endPoints.sort((a, b) => (a.order > b.order ? 1 : -1))\n}\n\n/*\n * Returns the key order of the child right before the given order.\n */\n\nfunction getContainingChildOrder(children, keyOrders, order) {\n  // Find the first child that is after the given key\n  const nextChildIndex = children.findIndex(\n    child => order < keyOrders[child.key]\n  )\n\n  if (nextChildIndex <= 0) {\n    return 0\n  }\n\n  const containingChild = children[nextChildIndex - 1]\n  return keyOrders[containingChild.key]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getChildrenDecorations\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport warning from 'tiny-warning'\nimport Types from 'prop-types'\n\nimport Void from './void'\nimport Text from './text'\nimport getChildrenDecorations from '../utils/get-children-decorations'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nclass Node extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    isFocused: Types.bool.isRequired,\n    isSelected: Types.bool.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    debug(message, `${key} (${type})`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(nextProps) {\n    const { props } = this\n    const { editor } = props\n    const shouldUpdate = editor.run(\n      'shouldNodeComponentUpdate',\n      props,\n      nextProps\n    )\n    const n = nextProps\n    const p = props\n\n    // If the `Component` has a custom logic to determine whether the component\n    // needs to be updated or not, return true if it returns true. If it returns\n    // false, we need to ignore it, because it shouldn't be allowed it.\n    if (shouldUpdate != null) {\n      if (shouldUpdate) {\n        return true\n      }\n\n      warning(\n        shouldUpdate !== false,\n        \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\"\n      )\n    }\n\n    // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n    if (n.readOnly !== p.readOnly) return true\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node !== p.node) return true\n\n    // If the selection value of the node or of some of its children has changed,\n    // re-render in case there is any user-land logic depends on it to render.\n    // if the node is selected update it, even if it was already selected: the\n    // selection value of some of its children could have been changed and they\n    // need to be rendered again.\n    if (n.isSelected || p.isSelected) return true\n    if (n.isFocused || p.isFocused) return true\n\n    // If the decorations have changed, update.\n    if (!n.decorations.equals(p.decorations)) return true\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n    const {\n      editor,\n      isSelected,\n      isFocused,\n      node,\n      decorations,\n      parent,\n      readOnly,\n    } = this.props\n    const { value } = editor\n    const { selection } = value\n    const indexes = node.getSelectionIndexes(selection, isSelected)\n    const decs = decorations.concat(node.getDecorations(editor))\n    const childrenDecorations = getChildrenDecorations(node, decs)\n    const children = []\n\n    node.nodes.forEach((child, i) => {\n      const isChildSelected = !!indexes && indexes.start <= i && i < indexes.end\n\n      children.push(\n        this.renderNode(child, isChildSelected, childrenDecorations[i])\n      )\n    })\n\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    const attributes = { 'data-key': node.key }\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.isLeafBlock()) {\n      const direction = node.getTextDirection()\n      if (direction === 'rtl') attributes.dir = 'rtl'\n    }\n\n    const props = {\n      key: node.key,\n      editor,\n      isFocused,\n      isSelected,\n      node,\n      parent,\n      readOnly,\n    }\n\n    const element = editor.run('renderNode', {\n      ...props,\n      attributes,\n      children,\n    })\n\n    return editor.query('isVoid', node) ? (\n      <Void {...this.props}>{element}</Void>\n    ) : (\n      element\n    )\n  }\n\n  /**\n   * Render a `child` node.\n   *\n   * @param {Node} child\n   * @param {Boolean} isSelected\n   * @param {Array<Decoration>} decorations\n   * @return {Element}\n   */\n\n  renderNode = (child, isSelected, decorations) => {\n    const { block, editor, node, readOnly, isFocused } = this.props\n    const Component = child.object === 'text' ? Text : Node\n\n    return (\n      <Component\n        block={node.object === 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        isSelected={isSelected}\n        isFocused={isFocused && isSelected}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Node\n","import findDOMNode from './find-dom-node'\n\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point, win = window) {\n  const el = findDOMNode(point.key, win)\n  let start = 0\n\n  // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n  const texts = Array.from(\n    el.querySelectorAll('[data-slate-content], [data-slate-zero-width]')\n  )\n\n  for (const text of texts) {\n    const node = text.childNodes[0]\n    const domLength = node.textContent.length\n    let slateLength = domLength\n\n    if (text.hasAttribute('data-slate-length')) {\n      slateLength = parseInt(text.getAttribute('data-slate-length'), 10)\n    }\n\n    const end = start + slateLength\n\n    if (point.offset <= end) {\n      const offset = Math.min(domLength, Math.max(0, point.offset - start))\n      return { node, offset }\n    }\n\n    start = end\n  }\n\n  return null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMPoint\n","import findDOMPoint from './find-dom-point'\n\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMRange(range, win = window) {\n  const { anchor, focus, isBackward, isCollapsed } = range\n  const domAnchor = findDOMPoint(anchor, win)\n  const domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win)\n\n  if (!domAnchor || !domFocus) return null\n\n  const r = win.document.createRange()\n  const start = isBackward ? domFocus : domAnchor\n  const end = isBackward ? domAnchor : domFocus\n  r.setStart(start.node, start.offset)\n  r.setEnd(end.node, end.offset)\n  return r\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMRange\n","import getWindow from 'get-window'\nimport isBackward from 'selection-is-backward'\nimport { IS_SAFARI, IS_IOS } from 'slate-dev-environment'\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nconst OVERFLOWS = ['auto', 'overlay', 'scroll']\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nconst IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i)\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  let parent = el.parentNode\n  let scroller\n\n  while (!scroller) {\n    if (!parent.parentNode) break\n\n    const style = window.getComputedStyle(parent)\n    const { overflowY } = style\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent\n      break\n    }\n\n    parent = parent.parentNode\n  }\n\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n  if (!scroller) {\n    return window.document.body\n  }\n\n  return scroller\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return\n  if (!selection.anchorNode) return\n\n  const window = getWindow(selection.anchorNode)\n  const scroller = findScrollContainer(selection.anchorNode, window)\n  const isWindow =\n    scroller === window.document.body ||\n    scroller === window.document.documentElement\n  const backward = isBackward(selection)\n\n  const range = selection.getRangeAt(0).cloneRange()\n  range.collapse(backward)\n  let cursorRect = range.getBoundingClientRect()\n\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1)\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1)\n      }\n\n      cursorRect = range.getBoundingClientRect()\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0]\n        }\n      }\n    }\n  }\n\n  let width\n  let height\n  let yOffset\n  let xOffset\n  let scrollerTop = 0\n  let scrollerLeft = 0\n  let scrollerBordersY = 0\n  let scrollerBordersX = 0\n  let scrollerPaddingTop = 0\n  let scrollerPaddingBottom = 0\n  let scrollerPaddingLeft = 0\n  let scrollerPaddingRight = 0\n\n  if (isWindow) {\n    const { innerWidth, innerHeight, pageYOffset, pageXOffset } = window\n    width = innerWidth\n    height = innerHeight\n    yOffset = pageYOffset\n    xOffset = pageXOffset\n  } else {\n    const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = scroller\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth,\n      paddingTop,\n      paddingBottom,\n      paddingLeft,\n      paddingRight,\n    } = window.getComputedStyle(scroller)\n\n    const scrollerRect = scroller.getBoundingClientRect()\n    width = offsetWidth\n    height = offsetHeight\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10)\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10)\n\n    scrollerBordersY =\n      parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10)\n\n    scrollerBordersX =\n      parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10)\n\n    scrollerPaddingTop = parseInt(paddingTop, 10)\n    scrollerPaddingBottom = parseInt(paddingBottom, 10)\n    scrollerPaddingLeft = parseInt(paddingLeft, 10)\n    scrollerPaddingRight = parseInt(paddingRight, 10)\n    yOffset = scrollTop\n    xOffset = scrollLeft\n  }\n\n  const cursorTop = cursorRect.top + yOffset - scrollerTop\n  const cursorLeft = cursorRect.left + xOffset - scrollerLeft\n\n  let x = xOffset\n  let y = yOffset\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft\n  } else if (\n    cursorLeft + cursorRect.width + scrollerBordersX >\n    xOffset + width\n  ) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop\n  } else if (\n    cursorTop + cursorRect.height + scrollerBordersY >\n    yOffset + height\n  ) {\n    // selection below viewport\n    y =\n      cursorTop +\n      scrollerBordersY +\n      scrollerPaddingBottom +\n      cursorRect.height -\n      height\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y)\n  } else {\n    scroller.scrollTop = y\n    scroller.scrollLeft = x\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default scrollToSelection\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport getWindow from 'get-window'\nimport warning from 'tiny-warning'\nimport throttle from 'lodash/throttle'\nimport {\n  IS_ANDROID,\n  IS_FIREFOX,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport Node from './node'\nimport findDOMRange from '../utils/find-dom-range'\nimport findRange from '../utils/find-range'\nimport getChildrenDecorations from '../utils/get-children-decorations'\nimport scrollToSelection from '../utils/scroll-to-selection'\nimport removeAllRanges from '../utils/remove-all-ranges'\n\nconst FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:content')\n\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug.update = Debug('slate:update')\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nclass Content extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool.isRequired,\n    className: Types.string,\n    editor: Types.object.isRequired,\n    id: Types.string,\n    readOnly: Types.bool.isRequired,\n    role: Types.string,\n    spellCheck: Types.bool.isRequired,\n    style: Types.object,\n    tabIndex: Types.number,\n    tagName: Types.string,\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: {},\n    tagName: 'div',\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    isUpdatingSelection: false,\n  }\n\n  /**\n   * Create a set of bound event handlers.\n   *\n   * @type {Object}\n   */\n\n  handlers = EVENT_HANDLERS.reduce((obj, handler) => {\n    obj[handler] = event => this.onEvent(handler, event)\n    return obj\n  }, {})\n\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Add native DOM event listeners.\n   *   - Update the selection, in case it starts focused.\n   */\n\n  componentDidMount() {\n    const window = getWindow(this.element)\n\n    window.document.addEventListener(\n      'selectionchange',\n      this.onNativeSelectionChange\n    )\n\n    // COMPAT: Restrict scope of `beforeinput` to clients that support the\n    // Input Events Level 2 spec, since they are preventable events.\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.element.addEventListener('beforeinput', this.handlers.onBeforeInput)\n    }\n\n    this.updateSelection()\n  }\n\n  /**\n   * When unmounting, remove DOM event listeners.\n   */\n\n  componentWillUnmount() {\n    const window = getWindow(this.element)\n\n    if (window) {\n      window.document.removeEventListener(\n        'selectionchange',\n        this.onNativeSelectionChange\n      )\n    }\n\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.element.removeEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n  }\n\n  /**\n   * On update, update the selection.\n   */\n\n  componentDidUpdate() {\n    debug.update('componentDidUpdate')\n    this.updateSelection()\n  }\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  updateSelection = () => {\n    const { editor } = this.props\n    const { value } = editor\n    const { selection } = value\n    const { isBackward } = selection\n    const window = getWindow(this.element)\n    const native = window.getSelection()\n    const { activeElement } = window.document\n\n    if (debug.enabled) {\n      debug.update('updateSelection', { selection: selection.toJSON() })\n    }\n\n    // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n    if (!native) {\n      return\n    }\n\n    const { rangeCount, anchorNode } = native\n    let updated = false\n\n    // If the Slate selection is blurred, but the DOM's active element is still\n    // the editor, we need to blur it.\n    if (selection.isBlurred && activeElement === this.element) {\n      this.element.blur()\n      updated = true\n    }\n\n    // If the Slate selection is unset, but the DOM selection has a range\n    // selected in the editor, we need to remove the range.\n    if (selection.isUnset && rangeCount && this.isInEditor(anchorNode)) {\n      removeAllRanges(native)\n      updated = true\n    }\n\n    // If the Slate selection is focused, but the DOM's active element is not\n    // the editor, we need to focus it. We prevent scrolling because we handle\n    // scrolling to the correct selection.\n    if (selection.isFocused && activeElement !== this.element) {\n      this.element.focus({ preventScroll: true })\n      updated = true\n    }\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    if (selection.isFocused && selection.isSet) {\n      const current = !!rangeCount && native.getRangeAt(0)\n      const range = findDOMRange(selection, window)\n\n      if (!range) {\n        warning(\n          false,\n          'Unable to find a native DOM range from the current selection.'\n        )\n\n        return\n      }\n\n      const { startContainer, startOffset, endContainer, endOffset } = range\n\n      // If the new range matches the current selection, there is nothing to fix.\n      // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n      // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n      // to check both orientations here. (2017/10/31)\n      if (current) {\n        if (\n          (startContainer === current.startContainer &&\n            startOffset === current.startOffset &&\n            endContainer === current.endContainer &&\n            endOffset === current.endOffset) ||\n          (startContainer === current.endContainer &&\n            startOffset === current.endOffset &&\n            endContainer === current.startContainer &&\n            endOffset === current.startOffset)\n        ) {\n          return\n        }\n      }\n\n      // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n      updated = true\n      this.tmp.isUpdatingSelection = true\n      removeAllRanges(native)\n\n      // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n      if (native.setBaseAndExtent) {\n        // COMPAT: Since the DOM range has no concept of backwards/forwards\n        // we need to check and do the right thing here.\n        if (isBackward) {\n          native.setBaseAndExtent(\n            range.endContainer,\n            range.endOffset,\n            range.startContainer,\n            range.startOffset\n          )\n        } else {\n          native.setBaseAndExtent(\n            range.startContainer,\n            range.startOffset,\n            range.endContainer,\n            range.endOffset\n          )\n        }\n      } else {\n        native.addRange(range)\n      }\n\n      // Scroll to the selection, in case it's out of view.\n      scrollToSelection(native)\n\n      // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n      // it is still set when selection-related events from updating it fire.\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (IS_FIREFOX && this.element) {\n          this.element.focus()\n        }\n\n        this.tmp.isUpdatingSelection = false\n      })\n    }\n\n    if (updated && debug.enabled) {\n      debug('updateSelection', { selection, native, activeElement })\n      debug.update('updateSelection-applied', { selection })\n    }\n  }\n\n  /**\n   * The React ref method to set the root content element locally.\n   *\n   * @param {Element} element\n   */\n\n  ref = element => {\n    this.element = element\n  }\n\n  /**\n   * Check if an event `target` is fired from within the contenteditable\n   * element. This should be false for edits happening in non-contenteditable\n   * children, such as void nodes and other nested Slate editors.\n   *\n   * @param {Element} target\n   * @return {Boolean}\n   */\n\n  isInEditor = target => {\n    const { element } = this\n\n    let el\n\n    try {\n      // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n      // have .closest and it crashes.\n      if (target.nodeType === 8) {\n        return false\n      }\n\n      // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n      // `target` is a text node use its parent node for check.\n      el = target.nodeType === 3 ? target.parentNode : target\n    } catch (err) {\n      // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n      // originating from an internal \"restricted\" element (e.g. a stepper\n      // arrow on a number input)\n      // see github.com/ianstormtaylor/slate/issues/1819\n      if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n        return false\n      }\n\n      throw err\n    }\n\n    return (\n      el.isContentEditable &&\n      (el === element || el.closest('[data-slate-editor]') === element)\n    )\n  }\n\n  /**\n   * On `event` with `handler`.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  onEvent(handler, event) {\n    debug('onEvent', handler)\n\n    // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n    // programmatically while updating selection.\n    if (\n      this.tmp.isUpdatingSelection &&\n      (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')\n    ) {\n      return\n    }\n\n    // COMPAT: There are situations where a select event will fire with a new\n    // native selection that resolves to the same internal position. In those\n    // cases we don't need to trigger any changes, since our internal model is\n    // already up to date, but we do want to update the native selection again\n    // to make sure it is in sync. (2017/10/16)\n    //\n    // ANDROID: The updateSelection causes issues in Android when you are\n    // at the end of a block. The selection ends up to the left of the inserted\n    // character instead of to the right. This behavior continues even if\n    // you enter more than one character. (2019/01/03)\n    if (!IS_ANDROID && handler === 'onSelect') {\n      const { editor } = this.props\n      const { value } = editor\n      const { selection } = value\n      const window = getWindow(event.target)\n      const native = window.getSelection()\n      const range = findRange(native, editor)\n\n      if (range && range.equals(selection.toRange())) {\n        this.updateSelection()\n        return\n      }\n    }\n\n    // Don't handle drag and drop events coming from embedded editors.\n    if (\n      handler === 'onDragEnd' ||\n      handler === 'onDragEnter' ||\n      handler === 'onDragExit' ||\n      handler === 'onDragLeave' ||\n      handler === 'onDragOver' ||\n      handler === 'onDragStart' ||\n      handler === 'onDrop'\n    ) {\n      const closest = event.target.closest('[data-slate-editor]')\n\n      if (closest !== this.element) {\n        return\n      }\n    }\n\n    // Some events require being in editable in the editor, so if the event\n    // target isn't, ignore them.\n    if (\n      handler === 'onBeforeInput' ||\n      handler === 'onBlur' ||\n      handler === 'onCompositionEnd' ||\n      handler === 'onCompositionStart' ||\n      handler === 'onCopy' ||\n      handler === 'onCut' ||\n      handler === 'onFocus' ||\n      handler === 'onInput' ||\n      handler === 'onKeyDown' ||\n      handler === 'onKeyUp' ||\n      handler === 'onPaste' ||\n      handler === 'onSelect'\n    ) {\n      if (!this.isInEditor(event.target)) {\n        return\n      }\n    }\n\n    this.props.onEvent(handler, event)\n  }\n\n  /**\n   * On native `selectionchange` event, trigger the `onSelect` handler. This is\n   * needed to account for React's `onSelect` being non-standard and not firing\n   * until after a selection has been released. This causes issues in situations\n   * where another change happens while a selection is being made.\n   *\n   * @param {Event} event\n   */\n\n  onNativeSelectionChange = throttle(event => {\n    if (this.props.readOnly) return\n\n    const window = getWindow(event.target)\n    const { activeElement } = window.document\n    if (activeElement !== this.element) return\n\n    this.props.onEvent('onSelect', event)\n  }, 100)\n\n  /**\n   * Render the editor content.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props, handlers } = this\n    const {\n      id,\n      className,\n      readOnly,\n      editor,\n      tabIndex,\n      role,\n      tagName,\n      spellCheck,\n    } = props\n    const { value } = editor\n    const Container = tagName\n    const { document, selection, decorations } = value\n    const indexes = document.getSelectionIndexes(selection)\n    const decs = document.getDecorations(editor).concat(decorations)\n    const childrenDecorations = getChildrenDecorations(document, decs)\n\n    const children = document.nodes.toArray().map((child, i) => {\n      const isSelected = !!indexes && indexes.start <= i && i < indexes.end\n\n      return this.renderNode(child, isSelected, childrenDecorations[i])\n    })\n\n    const style = {\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word',\n      // COMPAT: In iOS, a formatting menu with bold, italic and underline\n      // buttons is shown which causes our internal value to get out of sync in\n      // weird ways. This hides that. (2016/06/21)\n      ...(readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }),\n      // Allow for passed-in styles to override anything.\n      ...props.style,\n    }\n\n    debug('render', { props })\n\n    if (debug.enabled) {\n      debug.update('render', {\n        text: value.document.text,\n        selection: value.selection.toJSON(),\n        value: value.toJSON(),\n      })\n    }\n\n    return (\n      <Container\n        {...handlers}\n        data-slate-editor\n        ref={this.ref}\n        data-key={document.key}\n        contentEditable={readOnly ? null : true}\n        suppressContentEditableWarning\n        id={id}\n        className={className}\n        autoCorrect={props.autoCorrect ? 'on' : 'off'}\n        spellCheck={spellCheck}\n        style={style}\n        role={readOnly ? null : role || 'textbox'}\n        tabIndex={tabIndex}\n        // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        data-gramm={false}\n      >\n        {children}\n      </Container>\n    )\n  }\n\n  /**\n   * Render a `child` node of the document.\n   *\n   * @param {Node} child\n   * @param {Boolean} isSelected\n   * @return {Element}\n   */\n\n  renderNode = (child, isSelected, decorations) => {\n    const { editor, readOnly } = this.props\n    const { value } = editor\n    const { document, selection } = value\n    const { isFocused } = selection\n\n    return (\n      <Node\n        block={null}\n        editor={editor}\n        decorations={decorations}\n        isSelected={isSelected}\n        isFocused={isFocused && isSelected}\n        key={child.key}\n        node={child}\n        parent={document}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Content\n","import PlaceholderPlugin from 'slate-react-placeholder'\nimport React from 'react'\n\nimport DOMPlugin from './dom'\nimport Content from '../components/content'\nimport EVENT_HANDLERS from '../constants/event-handlers'\n\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nconst PROPS = [\n  ...EVENT_HANDLERS,\n  'commands',\n  'decorateNode',\n  'queries',\n  'renderEditor',\n  'renderMark',\n  'renderNode',\n  'schema',\n]\n\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction ReactPlugin(options = {}) {\n  const { placeholder, plugins = [] } = options\n\n  /**\n   * Decorate node.\n   *\n   * @param {Object} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    return []\n  }\n\n  /**\n   * Render editor.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n  function renderEditor(props, editor, next) {\n    return (\n      <Content\n        autoCorrect={props.autoCorrect}\n        className={props.className}\n        editor={editor}\n        id={props.id}\n        onEvent={(handler, event) => editor.run(handler, event)}\n        readOnly={props.readOnly}\n        role={props.role}\n        spellCheck={props.spellCheck}\n        style={props.style}\n        tabIndex={props.tabIndex}\n        tagName={props.tagName}\n      />\n    )\n  }\n\n  /**\n   * Render node.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n  function renderNode(props, editor, next) {\n    const { attributes, children, node } = props\n    const { object } = node\n    if (object !== 'block' && object !== 'inline') return null\n\n    const Tag = object === 'block' ? 'div' : 'span'\n    const style = { position: 'relative' }\n    return (\n      <Tag {...attributes} style={style}>\n        {children}\n      </Tag>\n    )\n  }\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  const ret = []\n  const editorPlugin = PROPS.reduce((memo, prop) => {\n    if (prop in options) memo[prop] = options[prop]\n    return memo\n  }, {})\n\n  ret.push(\n    DOMPlugin({\n      plugins: [editorPlugin, ...plugins],\n    })\n  )\n\n  if (placeholder) {\n    ret.push(\n      PlaceholderPlugin({\n        placeholder,\n        when: (editor, node) =>\n          node.object === 'document' &&\n          node.text === '' &&\n          node.nodes.size === 1 &&\n          node.getTexts().size === 1,\n      })\n    )\n  }\n\n  ret.push({\n    decorateNode,\n    renderEditor,\n    renderNode,\n  })\n\n  return ret\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default ReactPlugin\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport invariant from 'tiny-invariant'\nimport memoizeOne from 'memoize-one'\nimport warning from 'tiny-warning'\nimport { Editor as Controller } from 'slate'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport ReactPlugin from '../plugins/react'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nclass Editor extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool,\n    autoFocus: Types.bool,\n    className: Types.string,\n    defaultValue: SlateTypes.value,\n    id: Types.string,\n    onChange: Types.func,\n    options: Types.object,\n    placeholder: Types.any,\n    plugins: Types.array,\n    readOnly: Types.bool,\n    role: Types.string,\n    schema: Types.object,\n    spellCheck: Types.bool,\n    style: Types.object,\n    tabIndex: Types.number,\n    value: SlateTypes.value,\n    ...EVENT_HANDLERS.reduce((obj, handler) => {\n      obj[handler] = Types.func\n      return obj\n    }, {}),\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    autoFocus: false,\n    autoCorrect: true,\n    onChange: () => {},\n    options: {},\n    placeholder: '',\n    plugins: [],\n    readOnly: false,\n    schema: {},\n    spellCheck: true,\n  }\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n  state = { value: this.props.defaultValue }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    mounted: false,\n    change: null,\n    resolves: 0,\n    updates: 0,\n  }\n\n  /**\n   * When the component first mounts, flush a queued change if one exists.\n   */\n\n  componentDidMount() {\n    this.tmp.mounted = true\n    this.tmp.updates++\n\n    if (this.props.autoFocus) {\n      this.focus()\n    }\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component updates, flush a queued change if one exists.\n   */\n\n  componentDidUpdate() {\n    this.tmp.updates++\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component unmounts, make sure async commands don't trigger react updates.\n   */\n\n  componentWillUnmount() {\n    this.tmp.mounted = false\n  }\n\n  /**\n   * Render the editor.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    debug('render', this)\n    const props = { ...this.props, editor: this }\n\n    // Re-resolve the controller if needed based on memoized props.\n    const { commands, placeholder, plugins, queries, schema } = props\n    this.resolveController(plugins, schema, commands, queries, placeholder)\n\n    // Set the current props on the controller.\n    const { options, readOnly, value: valueFromProps } = props\n    const { value: valueFromState } = this.state\n    const value = valueFromProps || valueFromState\n    this.controller.setReadOnly(readOnly)\n    this.controller.setValue(value, options)\n\n    // Render the editor's children with the controller.\n    const children = this.controller.run('renderEditor', {\n      ...props,\n      value,\n    })\n    return children\n  }\n\n  /**\n   * Resolve an editor controller from the passed-in props. This method takes\n   * all of the props as individual arguments to be able to properly memoize\n   * against anything that could change and invalidate the old editor.\n   *\n   * @param {Array} plugins\n   * @param {Object} schema\n   * @param {Object} commands\n   * @param {Object} queries\n   * @param {String} placeholder\n   * @return {Editor}\n   */\n\n  resolveController = memoizeOne(\n    (plugins = [], schema, commands, queries, placeholder) => {\n      // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n      warning(\n        this.tmp.resolves < 5 || this.tmp.resolves !== this.tmp.updates,\n        'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.'\n      )\n\n      this.tmp.resolves++\n      const react = ReactPlugin({\n        ...this.props,\n        value: this.props.value || this.state.value,\n      })\n\n      const onChange = change => {\n        if (this.tmp.mounted) {\n          this.handleChange(change)\n        } else {\n          this.tmp.change = change\n        }\n      }\n\n      this.controller = new Controller(\n        { plugins: [react], onChange },\n        { controller: this, construct: false }\n      )\n\n      this.controller.run('onConstruct')\n    }\n  )\n\n  handleChange(change) {\n    const { onChange } = this.props\n    const { value } = this.state\n\n    if (value) {\n      // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n      this.setState({ value: change.value })\n    }\n\n    onChange(change)\n  }\n\n  /**\n   * Mimic the API of the `Editor` controller, so that this component instance\n   * can be passed in its place to plugins.\n   */\n\n  get operations() {\n    return this.controller.operations\n  }\n\n  get readOnly() {\n    return this.controller.readOnly\n  }\n\n  get value() {\n    return this.controller.value\n  }\n\n  applyOperation(...args) {\n    return this.controller.applyOperation(...args)\n  }\n\n  command(...args) {\n    return this.controller.command(...args)\n  }\n\n  hasCommand(...args) {\n    return this.controller.hasCommand(...args)\n  }\n\n  hasQuery(...args) {\n    return this.controller.hasQuery(...args)\n  }\n\n  normalize(...args) {\n    return this.controller.normalize(...args)\n  }\n\n  query(...args) {\n    return this.controller.query(...args)\n  }\n\n  registerCommand(...args) {\n    return this.controller.registerCommand(...args)\n  }\n\n  registerQuery(...args) {\n    return this.controller.registerQuery(...args)\n  }\n\n  run(...args) {\n    return this.controller.run(...args)\n  }\n\n  withoutNormalizing(...args) {\n    return this.controller.withoutNormalizing(...args)\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    return this.controller.editor\n  }\n\n  get schema() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  get stack() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  call(...args) {\n    return this.controller.call(...args)\n  }\n\n  change(...args) {\n    return this.controller.change(...args)\n  }\n\n  onChange(...args) {\n    return this.controller.onChange(...args)\n  }\n\n  applyOperations(...args) {\n    return this.controller.applyOperations(...args)\n  }\n\n  setOperationFlag(...args) {\n    return this.controller.setOperationFlag(...args)\n  }\n\n  getFlag(...args) {\n    return this.controller.getFlag(...args)\n  }\n\n  unsetOperationFlag(...args) {\n    return this.controller.unsetOperationFlag(...args)\n  }\n\n  withoutNormalization(...args) {\n    return this.controller.withoutNormalization(...args)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Editor\n","import Editor from './components/editor'\nimport cloneFragment from './utils/clone-fragment'\nimport findDOMNode from './utils/find-dom-node'\nimport findDOMRange from './utils/find-dom-range'\nimport findNode from './utils/find-node'\nimport findRange from './utils/find-range'\nimport getEventRange from './utils/get-event-range'\nimport getEventTransfer from './utils/get-event-transfer'\nimport setEventTransfer from './utils/set-event-transfer'\nimport ReactPlugin from './plugins/react'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMRange,\n  findNode,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n\nexport default {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMRange,\n  findNode,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n"]},"metadata":{},"sourceType":"module"}