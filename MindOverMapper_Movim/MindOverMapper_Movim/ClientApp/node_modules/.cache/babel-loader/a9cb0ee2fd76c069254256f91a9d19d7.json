{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire('slate');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Create a schema definition with rules to normalize lists\n */\n\n\nfunction schema(opts) {\n  var constructedSchema = {\n    blocks: _defineProperty({}, opts.typeItem, {\n      parent: opts.types.map(function (t) {\n        return {\n          type: t\n        };\n      }),\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }],\n      normalize: normalize({\n        parent_type_invalid: function parent_type_invalid(change, context) {\n          return change.unwrapBlockByKey(context.node.key, {\n            normalize: false\n          });\n        },\n        child_object_invalid: function child_object_invalid(change, context) {\n          return wrapChildrenInDefaultBlock(opts, change, context.node);\n        }\n      })\n    })\n  }; // validate all list types, ensure they only have list item children\n\n  opts.types.forEach(function (type) {\n    constructedSchema.blocks[type] = {\n      nodes: [{\n        match: {\n          type: opts.typeItem\n        }\n      }],\n      normalize: normalize({\n        child_type_invalid: function child_type_invalid(change, context) {\n          return change.wrapBlockByKey(context.child.key, opts.typeItem, {\n            normalize: false\n          });\n        }\n      })\n    };\n  });\n  return constructedSchema;\n}\n/*\n * Allows to define a normalize function through a keyed collection of functions\n */\n\n\nfunction normalize(reasons) {\n  return function (change, error) {\n    var reasonFn = reasons[error.code];\n\n    if (reasonFn) {\n      reasonFn(change, error);\n    }\n  };\n}\n/**\n * Wraps all child of a node in the default block type.\n * Returns a change, for chaining purposes\n */\n\n\nfunction wrapChildrenInDefaultBlock(opts, change, node) {\n  change.wrapBlockByKey(node.nodes.first().key, opts.typeDefault, {\n    normalize: false\n  });\n  var wrapper = change.value.document.getDescendant(node.key).nodes.first(); // Add in the remaining items\n\n  node.nodes.rest().forEach(function (child, index) {\n    return change.moveNodeByKey(child.key, wrapper.key, index + 1, {\n      normalize: false\n    });\n  });\n  return change;\n}\n\nexports.default = schema;","map":{"version":3,"sources":["C:/Users/ayomi/Source/Repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/@tommoor/slate-edit-list/dist/validation/schema.js"],"names":["Object","defineProperty","exports","value","require","_defineProperty","obj","key","enumerable","configurable","writable","schema","opts","constructedSchema","blocks","typeItem","parent","types","map","t","type","nodes","match","object","normalize","parent_type_invalid","change","context","unwrapBlockByKey","node","child_object_invalid","wrapChildrenInDefaultBlock","forEach","child_type_invalid","wrapBlockByKey","child","reasons","error","reasonFn","code","first","typeDefault","wrapper","document","getDescendant","rest","index","moveNodeByKey","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nrequire('slate');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Create a schema definition with rules to normalize lists\n */\nfunction schema(opts) {\n    var constructedSchema = {\n        blocks: _defineProperty({}, opts.typeItem, {\n            parent: opts.types.map(function (t) {\n                return { type: t };\n            }),\n            nodes: [{ match: { object: 'block' } }],\n\n            normalize: normalize({\n                parent_type_invalid: function parent_type_invalid(change, context) {\n                    return change.unwrapBlockByKey(context.node.key, {\n                        normalize: false\n                    });\n                },\n                child_object_invalid: function child_object_invalid(change, context) {\n                    return wrapChildrenInDefaultBlock(opts, change, context.node);\n                }\n            })\n        })\n    };\n\n    // validate all list types, ensure they only have list item children\n    opts.types.forEach(function (type) {\n        constructedSchema.blocks[type] = {\n            nodes: [{ match: { type: opts.typeItem } }],\n            normalize: normalize({\n                child_type_invalid: function child_type_invalid(change, context) {\n                    return change.wrapBlockByKey(context.child.key, opts.typeItem, {\n                        normalize: false\n                    });\n                }\n            })\n        };\n    });\n\n    return constructedSchema;\n}\n\n/*\n * Allows to define a normalize function through a keyed collection of functions\n */\nfunction normalize(reasons) {\n    return function (change, error) {\n        var reasonFn = reasons[error.code];\n        if (reasonFn) {\n            reasonFn(change, error);\n        }\n    };\n}\n\n/**\n * Wraps all child of a node in the default block type.\n * Returns a change, for chaining purposes\n */\nfunction wrapChildrenInDefaultBlock(opts, change, node) {\n    change.wrapBlockByKey(node.nodes.first().key, opts.typeDefault, {\n        normalize: false\n    });\n\n    var wrapper = change.value.document.getDescendant(node.key).nodes.first();\n\n    // Add in the remaining items\n    node.nodes.rest().forEach(function (child, index) {\n        return change.moveNodeByKey(child.key, wrapper.key, index + 1, {\n            normalize: false\n        });\n    });\n\n    return change;\n}\n\nexports.default = schema;"]},"metadata":{},"sourceType":"script"}