{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _slateSchemaViolations = require('slate-schema-violations');\n\nvar _immutable = require('immutable');\n\nvar _utils = require('../utils');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Create a schema definition with rules to normalize code blocks\n */\n\n\nfunction schema(opts) {\n  var _blocks;\n\n  var baseSchema = {\n    blocks: (_blocks = {}, _defineProperty(_blocks, opts.containerType, {\n      nodes: [{\n        match: {\n          type: opts.lineType\n        }\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code;\n\n        switch (code) {\n          case _slateSchemaViolations.CHILD_INVALID:\n          case _slateSchemaViolations.CHILD_TYPE_INVALID:\n            return onlyLine(opts, editor, error);\n\n          default:\n            return undefined;\n        }\n      }\n    }), _defineProperty(_blocks, opts.lineType, {\n      nodes: [{\n        match: {\n          object: 'text',\n          min: 1\n        }\n      }],\n      parent: {\n        type: opts.containerType\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code;\n\n        switch (code) {\n          // This constant does not exist yet in\n          // official Slate, but exists in GitBook's\n          // fork. Until the PR is merged, we accept both\n          // https://github.com/ianstormtaylor/slate/pull/1842\n          case _slateSchemaViolations.PARENT_INVALID:\n          case _slateSchemaViolations.PARENT_TYPE_INVALID:\n            return noOrphanLine(opts, editor, error);\n\n          case _slateSchemaViolations.CHILD_INVALID:\n          case _slateSchemaViolations.CHILD_OBJECT_INVALID:\n            return onlyTextInCode(opts, editor, error);\n\n          default:\n            return undefined;\n        }\n      }\n    }), _blocks)\n  };\n\n  if (!opts.allowMarks) {\n    baseSchema.blocks[opts.lineType].marks = [];\n  }\n\n  return baseSchema;\n}\n/**\n * Return a list of group of nodes matching the given filter.\n */\n\n\nfunction getSuccessiveNodes(nodes, match) {\n  var nonLines = nodes.takeUntil(match);\n  var afterNonLines = nodes.skip(nonLines.size);\n\n  if (afterNonLines.isEmpty()) {\n    return (0, _immutable.List)();\n  }\n\n  var firstGroup = afterNonLines.takeWhile(match);\n  var restOfNodes = afterNonLines.skip(firstGroup.size);\n  return (0, _immutable.List)([firstGroup]).concat(getSuccessiveNodes(restOfNodes, match));\n}\n/**\n * A rule that ensure code blocks only contain lines of code, and no marks\n */\n\n\nfunction onlyLine(opts, editor, error) {\n  var isNotLine = function isNotLine(n) {\n    return n.type !== opts.lineType;\n  };\n\n  var nonLineGroups = getSuccessiveNodes(error.node.nodes, isNotLine);\n  nonLineGroups.filter(function (group) {\n    return !group.isEmpty();\n  }).forEach(function (nonLineGroup) {\n    // Convert text to code lines\n    var text = nonLineGroup.map(function (n) {\n      return n.text;\n    }).join('');\n    var codeLines = (0, _utils.deserializeCode)(opts, text).nodes; // Insert them in place of the invalid node\n\n    var first = nonLineGroup.first();\n    var parent = editor.value.document.getParent(first.key);\n    var invalidNodeIndex = parent.nodes.indexOf(first);\n    editor.withoutNormalizing(function () {\n      codeLines.forEach(function (codeLine, index) {\n        editor.insertNodeByKey(parent.key, invalidNodeIndex + index, codeLine);\n      });\n    }); // Remove the block\n\n    editor.withoutNormalizing(function () {\n      nonLineGroup.forEach(function (n) {\n        return editor.removeNodeByKey(n.key);\n      });\n    });\n  });\n  return editor;\n}\n/**\n * A rule that ensure code lines only contain text\n */\n\n\nfunction onlyTextInCode(opts, editor, error) {\n  var node = error.node;\n\n  if (node.object === 'inline' || node.object === 'block') {\n    editor.withoutNormalizing(function () {\n      node.nodes.forEach(function (child) {\n        editor.unwrapNodeByKey(child.key);\n      });\n    });\n    return editor;\n  }\n\n  return undefined;\n}\n/**\n * A rule that ensure code lines are always children\n * of a code block.\n */\n\n\nfunction noOrphanLine(opts, editor, error) {\n  var parent = error.parent;\n\n  var isLine = function isLine(n) {\n    return n.type === opts.lineType;\n  };\n\n  var linesGroup = getSuccessiveNodes(parent.nodes, isLine);\n  linesGroup.forEach(function (group) {\n    var container = _slate.Block.create({\n      type: opts.containerType,\n      nodes: []\n    });\n\n    var firstLineIndex = parent.nodes.indexOf(group.first());\n    editor.withoutNormalizing(function () {\n      editor.insertNodeByKey(parent.key, firstLineIndex, container);\n      group.forEach(function (line, index) {\n        return editor.moveNodeByKey(line.key, container.key, index);\n      });\n    });\n  });\n}\n\nexports.default = schema;","map":{"version":3,"sources":["C:/Users/ayomi/source/repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/@wikifactory/slate-edit-code/dist/validation/schema.js"],"names":["Object","defineProperty","exports","value","_slate","require","_slateSchemaViolations","_immutable","_utils","_defineProperty","obj","key","enumerable","configurable","writable","schema","opts","_blocks","baseSchema","blocks","containerType","nodes","match","type","lineType","normalize","editor","error","code","CHILD_INVALID","CHILD_TYPE_INVALID","onlyLine","undefined","object","min","parent","PARENT_INVALID","PARENT_TYPE_INVALID","noOrphanLine","CHILD_OBJECT_INVALID","onlyTextInCode","allowMarks","marks","getSuccessiveNodes","nonLines","takeUntil","afterNonLines","skip","size","isEmpty","List","firstGroup","takeWhile","restOfNodes","concat","isNotLine","n","nonLineGroups","node","filter","group","forEach","nonLineGroup","text","map","join","codeLines","deserializeCode","first","document","getParent","invalidNodeIndex","indexOf","withoutNormalizing","codeLine","index","insertNodeByKey","removeNodeByKey","child","unwrapNodeByKey","isLine","linesGroup","container","Block","create","firstLineIndex","line","moveNodeByKey","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slate = require('slate');\n\nvar _slateSchemaViolations = require('slate-schema-violations');\n\nvar _immutable = require('immutable');\n\nvar _utils = require('../utils');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Create a schema definition with rules to normalize code blocks\n */\nfunction schema(opts) {\n    var _blocks;\n\n    var baseSchema = {\n        blocks: (_blocks = {}, _defineProperty(_blocks, opts.containerType, {\n            nodes: [{ match: { type: opts.lineType } }],\n            normalize: function normalize(editor, error) {\n                var code = error.code;\n\n                switch (code) {\n                    case _slateSchemaViolations.CHILD_INVALID:\n                    case _slateSchemaViolations.CHILD_TYPE_INVALID:\n                        return onlyLine(opts, editor, error);\n                    default:\n                        return undefined;\n                }\n            }\n        }), _defineProperty(_blocks, opts.lineType, {\n            nodes: [{ match: { object: 'text', min: 1 } }],\n            parent: { type: opts.containerType },\n            normalize: function normalize(editor, error) {\n                var code = error.code;\n\n                switch (code) {\n                    // This constant does not exist yet in\n                    // official Slate, but exists in GitBook's\n                    // fork. Until the PR is merged, we accept both\n                    // https://github.com/ianstormtaylor/slate/pull/1842\n                    case _slateSchemaViolations.PARENT_INVALID:\n                    case _slateSchemaViolations.PARENT_TYPE_INVALID:\n                        return noOrphanLine(opts, editor, error);\n                    case _slateSchemaViolations.CHILD_INVALID:\n                    case _slateSchemaViolations.CHILD_OBJECT_INVALID:\n                        return onlyTextInCode(opts, editor, error);\n                    default:\n                        return undefined;\n                }\n            }\n        }), _blocks)\n    };\n\n    if (!opts.allowMarks) {\n        baseSchema.blocks[opts.lineType].marks = [];\n    }\n\n    return baseSchema;\n}\n\n/**\n * Return a list of group of nodes matching the given filter.\n */\nfunction getSuccessiveNodes(nodes, match) {\n    var nonLines = nodes.takeUntil(match);\n    var afterNonLines = nodes.skip(nonLines.size);\n    if (afterNonLines.isEmpty()) {\n        return (0, _immutable.List)();\n    }\n\n    var firstGroup = afterNonLines.takeWhile(match);\n    var restOfNodes = afterNonLines.skip(firstGroup.size);\n\n    return (0, _immutable.List)([firstGroup]).concat(getSuccessiveNodes(restOfNodes, match));\n}\n\n/**\n * A rule that ensure code blocks only contain lines of code, and no marks\n */\nfunction onlyLine(opts, editor, error) {\n    var isNotLine = function isNotLine(n) {\n        return n.type !== opts.lineType;\n    };\n    var nonLineGroups = getSuccessiveNodes(error.node.nodes, isNotLine);\n\n    nonLineGroups.filter(function (group) {\n        return !group.isEmpty();\n    }).forEach(function (nonLineGroup) {\n        // Convert text to code lines\n        var text = nonLineGroup.map(function (n) {\n            return n.text;\n        }).join('');\n        var codeLines = (0, _utils.deserializeCode)(opts, text).nodes;\n\n        // Insert them in place of the invalid node\n        var first = nonLineGroup.first();\n        var parent = editor.value.document.getParent(first.key);\n        var invalidNodeIndex = parent.nodes.indexOf(first);\n\n        editor.withoutNormalizing(function () {\n            codeLines.forEach(function (codeLine, index) {\n                editor.insertNodeByKey(parent.key, invalidNodeIndex + index, codeLine);\n            });\n        });\n\n        // Remove the block\n        editor.withoutNormalizing(function () {\n            nonLineGroup.forEach(function (n) {\n                return editor.removeNodeByKey(n.key);\n            });\n        });\n    });\n\n    return editor;\n}\n\n/**\n * A rule that ensure code lines only contain text\n */\nfunction onlyTextInCode(opts, editor, error) {\n    var node = error.node;\n\n\n    if (node.object === 'inline' || node.object === 'block') {\n        editor.withoutNormalizing(function () {\n            node.nodes.forEach(function (child) {\n                editor.unwrapNodeByKey(child.key);\n            });\n        });\n\n        return editor;\n    }\n\n    return undefined;\n}\n\n/**\n * A rule that ensure code lines are always children\n * of a code block.\n */\nfunction noOrphanLine(opts, editor, error) {\n    var parent = error.parent;\n\n\n    var isLine = function isLine(n) {\n        return n.type === opts.lineType;\n    };\n\n    var linesGroup = getSuccessiveNodes(parent.nodes, isLine);\n\n    linesGroup.forEach(function (group) {\n        var container = _slate.Block.create({ type: opts.containerType, nodes: [] });\n        var firstLineIndex = parent.nodes.indexOf(group.first());\n\n        editor.withoutNormalizing(function () {\n            editor.insertNodeByKey(parent.key, firstLineIndex, container);\n            group.forEach(function (line, index) {\n                return editor.moveNodeByKey(line.key, container.key, index);\n            });\n        });\n    });\n}\n\nexports.default = schema;"]},"metadata":{},"sourceType":"script"}