{"ast":null,"code":"import { Record, Range } from 'immutable';\nimport { Block, Text, Editor, Value } from 'slate';\nimport { cloneFragment } from 'slate-react';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n/**\n * The plugin options\n */\n\n\nvar Options =\n/*#__PURE__*/\nfunction (_Record) {\n  _inherits(Options, _Record);\n\n  function Options() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, Options);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Options)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _this.isCell = function (node) {\n      return node.object == 'block' && node.type == _this.typeCell;\n    };\n\n    return _this;\n  }\n\n  return Options;\n}(Record({\n  typeTable: 'table',\n  typeRow: 'table_row',\n  typeCell: 'table_cell',\n  typeContent: 'paragraph',\n  exitBlockType: 'paragraph',\n  insertRowOnEnter: true,\n  edgeRowExitOnDirection: false\n}));\n/**\n * Create a new cell\n */\n\n\nfunction createCell(opts, nodes) {\n  return Block.create({\n    type: opts.typeCell,\n    nodes: nodes || [createEmptyContent(opts)]\n  });\n}\n/**\n * Create a new default content block\n */\n\n\nfunction createEmptyContent(opts) {\n  return Block.create({\n    type: opts.typeContent,\n    nodes: [Text.create()]\n  });\n}\n/**\n * Create a new row block\n */\n\n\nfunction createRow(opts, columns, getCellContent) {\n  var cellNodes = Range(0, columns).map(function (i) {\n    return createCell(opts, getCellContent ? getCellContent(i) : undefined);\n  }).toJS();\n  return Block.create({\n    type: opts.typeRow,\n    nodes: Block.createList(cellNodes)\n  });\n}\n/**\n * Create a table\n */\n\n\nfunction createTable(opts, columns, rows, getCellContent) {\n  var rowNodes = Range(0, rows).map(function (i) {\n    return createRow(opts, columns, getCellContent ? getCellContent.bind(null, i) : undefined);\n  }).toJS();\n  return Block.create({\n    type: opts.typeTable,\n    nodes: Block.createList(rowNodes)\n  });\n}\n\nvar TablePosition =\n/*#__PURE__*/\nfunction (_Record) {\n  _inherits(TablePosition, _Record);\n\n  function TablePosition() {\n    _classCallCheck(this, TablePosition);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TablePosition).apply(this, arguments));\n  }\n\n  _createClass(TablePosition, [{\n    key: \"isInCell\",\n\n    /**\n     * Check to see if this position is within a cell\n     */\n    value: function isInCell() {\n      return Boolean(this.cellBlock);\n    }\n    /**\n     * Check to see if this position is within a row\n     */\n\n  }, {\n    key: \"isInRow\",\n    value: function isInRow() {\n      return Boolean(this.rowBlock);\n    }\n    /**\n     * Check to see if this position is within a table\n     */\n\n  }, {\n    key: \"isInTable\",\n    value: function isInTable() {\n      return Boolean(this.tableBlock);\n    }\n    /**\n     * Check to see if this position is at the top of the cell.\n     */\n\n  }, {\n    key: \"isTopOfCell\",\n    value: function isTopOfCell() {\n      var cellBlock = this.cellBlock,\n          node = this.node;\n\n      if (!cellBlock || !node) {\n        return false;\n      }\n\n      return cellBlock.getPath(node.key).every(function (index) {\n        return index === 0;\n      });\n    }\n    /**\n     * Check to see if this position is at the bottom of the cell.\n     */\n\n  }, {\n    key: \"isBottomOfCell\",\n    value: function isBottomOfCell() {\n      var node = this.node,\n          cellBlock = this.cellBlock;\n\n      if (!node || !cellBlock) {\n        return false;\n      }\n\n      var ancestors = cellBlock.getAncestors(node.key);\n      return ancestors.every(function (node, index) {\n        var next = ancestors.get(index + 1);\n        if (!next) return true;\n        return node.nodes.indexOf(next) === node.nodes.size - 1;\n      });\n    }\n    /**\n     * Get count of columns\n     */\n\n  }, {\n    key: \"getWidth\",\n    value: function getWidth() {\n      var table = this.table;\n      var rows = table.nodes;\n      var cells = rows.first().nodes;\n      return cells.size;\n    }\n    /**\n     * Get count of rows\n     */\n\n  }, {\n    key: \"getHeight\",\n    value: function getHeight() {\n      var table = this.table;\n      var rows = table.nodes;\n      return rows.size;\n    }\n    /**\n     * Get index of current row in the table.\n     */\n\n  }, {\n    key: \"getRowIndex\",\n    value: function getRowIndex() {\n      var table = this.table,\n          row = this.row;\n      var rows = table.nodes;\n      return rows.findIndex(function (x) {\n        return x === row;\n      });\n    }\n    /**\n     * Get index of current column in the row.\n     */\n\n  }, {\n    key: \"getColumnIndex\",\n    value: function getColumnIndex() {\n      var row = this.row,\n          cell = this.cell;\n      var cells = row.nodes;\n      return cells.findIndex(function (x) {\n        return x === cell;\n      });\n    }\n    /**\n     * True if on first cell of the table\n     */\n\n  }, {\n    key: \"isFirstCell\",\n    value: function isFirstCell() {\n      return this.isFirstRow() && this.isFirstColumn();\n    }\n    /**\n     * True if on last cell of the table\n     */\n\n  }, {\n    key: \"isLastCell\",\n    value: function isLastCell() {\n      return this.isLastRow() && this.isLastColumn();\n    }\n    /**\n     * True if on first row\n     */\n\n  }, {\n    key: \"isFirstRow\",\n    value: function isFirstRow() {\n      return this.getRowIndex() === 0;\n    }\n    /**\n     * True if on last row\n     */\n\n  }, {\n    key: \"isLastRow\",\n    value: function isLastRow() {\n      return this.getRowIndex() === this.getHeight() - 1;\n    }\n    /**\n     * True if on first column\n     */\n\n  }, {\n    key: \"isFirstColumn\",\n    value: function isFirstColumn() {\n      return this.getColumnIndex() === 0;\n    }\n    /**\n     * True if on last column\n     */\n\n  }, {\n    key: \"isLastColumn\",\n    value: function isLastColumn() {\n      return this.getColumnIndex() === this.getWidth() - 1;\n    }\n  }, {\n    key: \"table\",\n    get: function get() {\n      if (!this.tableBlock) {\n        throw new Error('Not in a table');\n      }\n\n      return this.tableBlock;\n    }\n  }, {\n    key: \"row\",\n    get: function get() {\n      if (!this.rowBlock) {\n        throw new Error('Not in a row');\n      }\n\n      return this.rowBlock;\n    }\n  }, {\n    key: \"cell\",\n    get: function get() {\n      if (!this.cellBlock) {\n        throw new Error('Not in a cell');\n      }\n\n      return this.cellBlock;\n    }\n  }], [{\n    key: \"create\",\n    // Block container for the table\n\n    /*::tableBlock: ?Block;*/\n    // Block for current row\n\n    /*::rowBlock: ?Block;*/\n    // Block for current cell\n\n    /*::cellBlock: ?Block;*/\n    // Current content block in the cell\n\n    /*::contentBlock: ?Block;*/\n\n    /**\n     * Create a new instance of a TablePosition from a Slate document\n     * and a node key.\n     */\n    value: function create(opts, containerNode, key) {\n      var node = containerNode.getDescendant(key);\n      var ancestors = containerNode.getAncestors(key).push(node);\n      var tableBlock = ancestors.findLast(function (p) {\n        return p.type === opts.typeTable;\n      });\n      var rowBlock = ancestors.findLast(function (p) {\n        return p.type === opts.typeRow;\n      });\n      var cellBlock = ancestors.findLast(function (p) {\n        return p.type === opts.typeCell;\n      });\n      var contentBlock = ancestors.skipUntil(function (ancestor) {\n        return ancestor === cellBlock;\n      }).skip(1).first();\n      return new TablePosition({\n        tableBlock: tableBlock,\n        rowBlock: rowBlock,\n        cellBlock: cellBlock,\n        contentBlock: contentBlock,\n        node: node\n      });\n    }\n  }]);\n\n  return TablePosition;\n}(Record({\n  tableBlock: null,\n  rowBlock: null,\n  cellBlock: null,\n  contentBlock: null,\n  node: null\n}));\n/**\n * The position of the selection start block, in the current table\n */\n\n\nfunction getPosition(opts, editor) {\n  var value = editor.value;\n  if (!value.selection.start || !value.selection.start.key) return new TablePosition();\n  return TablePosition.create(opts, value.document, value.selection.start.key);\n}\n/*\n * The position of a particular node, in the current table\n */\n\n\nfunction getPositionByKey(opts, editor, containerNode, // Key of the node in desired position\nkey) {\n  return TablePosition.create(opts, containerNode, key);\n}\n/**\n * True if the given range is inside one table\n */\n\n\nfunction isRangeInTable(opts, node, range) {\n  var start = range.start,\n      end = range.end;\n  var startPosition = TablePosition.create(opts, node, start.key);\n  var endPosition = TablePosition.create(opts, node, end.key); // Only handle events in tables\n\n  if (!startPosition.isInTable() || !endPosition.isInTable()) {\n    return false;\n  } // Inside the same table\n\n\n  return startPosition.table === endPosition.table;\n}\n/**\n * Is the selection in a table\n */\n\n\nfunction isSelectionInTable(opts, editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  if (!selection.start.key) return false;\n  return isRangeInTable(opts, value.document, value.selection);\n}\n/**\n * Are the selection start and end outside a table.\n */\n\n\nfunction isSelectionOutOfTable(opts, editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  if (!selection.start.key) return false;\n  var startPosition = TablePosition.create(opts, value.document, selection.start.key);\n  var endPosition = TablePosition.create(opts, value.document, selection.end.key); // Only handle events in tables\n\n  return !startPosition.isInTable() && !endPosition.isInTable();\n}\n/**\n * Run the given function against each cells of the table\n */\n\n\nfunction forEachCells(opts, // The table\ntable, fn) {\n  return table.nodes.forEach(function (row, rowIndex) {\n    return row.nodes.forEach(function (cell, columnIndex) {\n      return fn(cell, rowIndex, columnIndex);\n    });\n  });\n}\n/**\n * Returns the list of cells at the given row index\n */\n\n\nfunction getCellsAtRow(opts, editor, table, rowIndex) {\n  return table.nodes.get(rowIndex).nodes;\n}\n/**\n * Returns the list of cells at the given column index\n */\n\n\nfunction getCellsAtColumn(opts, editor, table, columnIndex) {\n  return table.nodes.map(function (row) {\n    return row.nodes.get(columnIndex);\n  });\n}\n\nfunction getCopiedFragment(opts, value) {\n  var selection = value.selection,\n      document = value.document;\n  var startPosition = TablePosition.create(opts, document, selection.start.key);\n  var endPosition = TablePosition.create(opts, document, selection.end.key); // Fragment as it would be copied by Slate\n\n  var baseFragment = value.fragment;\n\n  if (endPosition.cell === startPosition.cell) {\n    // The selection is inside a single cell. Only copy the content of that cell\n    var copiedCell = baseFragment.getAncestors(baseFragment.getFirstText().key).findLast(function (n) {\n      return n.type === opts.typeCell;\n    });\n    return baseFragment.merge({\n      nodes: copiedCell.nodes\n    });\n  }\n}\n/**\n * Insert a new table\n */\n\n\nfunction insertTable(opts, change) {\n  var columns = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  var rows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n  var getCellContent = arguments.length > 4 ? arguments[4] : undefined;\n  var value = change.value;\n  if (!value.selection.start.key) return change; // Create the table node\n\n  var table = createTable(opts, columns, rows, getCellContent);\n  return change.insertBlock(table);\n}\n/**\n * Insert a new row in current table\n */\n\n\nfunction insertRow(opts, change, at, // row index\ngetRow) // Generate the row yourself\n{\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var table = pos.table; // Create a new row with the right count of cells\n\n  var columns = table.nodes.get(0).nodes.size;\n  var newRow = getRow ? getRow(columns) : createRow(opts, columns);\n\n  if (typeof at === 'undefined') {\n    at = pos.getRowIndex() + 1;\n  }\n\n  return change.insertNodeByKey(table.key, at, newRow).moveToEndOfNode(newRow.nodes.get(pos.getColumnIndex()));\n}\n/**\n * Move selection to {x,y}\n */\n\n\nfunction moveSelection(opts, change, x, y) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n\n  if (!pos.isInCell()) {\n    throw new Error('moveSelection can only be applied from within a cell');\n  }\n\n  var table = pos.table;\n  var row = table.nodes.get(y);\n  var cell = row.nodes.get(x);\n  return change.moveToStartOfNode(cell);\n}\n/**\n * Insert a new column in current table\n */\n\n\nfunction insertColumn(opts, change, at, // Column index\ngetCell) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var table = pos.table;\n  var columnIndex = typeof at === 'undefined' ? pos.getColumnIndex() + 1 : at; // Insert the new cell\n\n  change.withoutNormalizing(function () {\n    table.nodes.forEach(function (row, rowIndex) {\n      var newCell = getCell ? getCell(columnIndex, rowIndex) : createCell(opts);\n      change.insertNodeByKey(row.key, columnIndex, newCell);\n    });\n  }); // Update the selection (not doing can break the undo)\n\n  return moveSelection(opts, change, pos.getColumnIndex() + 1, pos.getRowIndex());\n}\n/**\n * Used when pasting a fragment of table into another one\n */\n\n\nfunction insertTableFragmentAtRange(opts, change, range, // This fragment should contain only one table,\nfragment) {\n  var insertedTable = fragment.nodes.first();\n\n  if (!(fragment.nodes.size === 1 && insertedTable && insertedTable.type === opts.typeTable)) {\n    throw new Error('Expected to insert a fragment containing one table');\n  }\n\n  var value = change.value;\n  var targetPosition = TablePosition.create(opts, value.document, value.selection.start.key);\n  var fragmentRows = insertedTable.nodes;\n  var fragmentHeight = fragmentRows.size;\n  var fragmentWidth = fragmentRows.first().nodes.size; // Insert columns and rows to accomodate the incoming pasted cells\n\n  var missingWidth = fragmentWidth + targetPosition.getColumnIndex() - targetPosition.getWidth();\n  var missingHeight = fragmentHeight + targetPosition.getRowIndex() - targetPosition.getHeight();\n\n  if (missingWidth > 0) {\n    // Add columns\n    Array(missingWidth).fill().forEach(function () {\n      insertColumn(opts, change, targetPosition.getWidth());\n    });\n  }\n\n  if (missingHeight > 0) {\n    // Add rows\n    Array(missingHeight).fill().forEach(function () {\n      insertRow(opts, change, targetPosition.getHeight());\n    });\n  } // Patch the inserted table over the target table, overwritting the cells\n\n\n  var existingTable = change.value.document.getDescendant(targetPosition.table.key);\n  change.withoutNormalizing(function () {\n    fragmentRows.forEach(function (fragmentRow, fragmentRowIndex) {\n      fragmentRow.nodes.forEach(function (newCell, fragmentColumnIndex) {\n        var existingCell = existingTable.nodes.get(targetPosition.getRowIndex() + fragmentRowIndex).nodes.get(targetPosition.getColumnIndex() + fragmentColumnIndex);\n        change.replaceNodeByKey(existingCell.key, newCell);\n      });\n    });\n  });\n  var lastPastedCell = fragmentRows.last().nodes.last();\n  return change.moveToEndOfNode(lastPastedCell);\n}\n/**\n * Clear the content of the given cell\n */\n\n\nfunction clearCell(opts, change, cell) {\n  var newBlock = Block.create({\n    type: opts.typeContent\n  });\n  var nodes = cell.nodes; // Insert a new empty node\n\n  change.withoutNormalizing(function () {\n    change.insertNodeByKey(cell.key, 0, newBlock);\n  }); // Remove all previous nodes\n\n  nodes.forEach(function (node) {\n    change.removeNodeByKey(node.key);\n  });\n  return change;\n}\n/**\n * Remove the row associated to a given key in a table.\n * Clear thw row if last remaining row\n */\n\n\nfunction removeRowByKey(opts, change, key) {\n  var value = change.value;\n  var pos = TablePosition.create(opts, value.document, key); // Update table by removing the row\n\n  if (pos.getHeight() > 1) {\n    change.removeNodeByKey(key);\n  } else {\n    // If last remaining row, clear it instead\n    pos.row.nodes.forEach(function (cell) {\n      cell.nodes.forEach(function () {\n        return clearCell(opts, change, cell);\n      });\n    });\n  } // this will also invalidate the selection - move it to the first cell\n  // change.moveToRangeOfNode(pos.row.nodes.first());\n\n\n  return change;\n}\n/**\n * Remove current row in a table. Clear it if last remaining row\n */\n\n\nfunction removeRow(opts, change, at) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var rowKey;\n\n  if (typeof at === 'undefined') {\n    rowKey = pos.row.key;\n  } else {\n    rowKey = pos.table.nodes.get(at).key;\n  }\n\n  return removeRowByKey(opts, change, rowKey);\n}\n/**\n * Delete the column associated with the given cell key in a table\n */\n\n\nfunction removeColumnByKey(opts, change, key) {\n  var value = change.value;\n  var pos = TablePosition.create(opts, value.document, key);\n  var table = pos.table;\n  var colIndex = pos.getColumnIndex();\n  var rows = table.nodes; // Remove the cell from every row\n\n  if (pos.getWidth() > 1) {\n    change.withoutNormalizing(function () {\n      rows.forEach(function (row) {\n        var cell = row.nodes.get(colIndex);\n        change.removeNodeByKey(cell.key);\n      });\n    });\n  } else {\n    // If last column, clear text in cells instead\n    rows.forEach(function (row) {\n      row.nodes.forEach(function (cell) {\n        cell.nodes.forEach(function () {\n          return clearCell(opts, change, cell);\n        });\n      });\n    });\n  } // this will also invalidate the selection - move it to the first cell\n  // change.moveToRangeOfNode(rows.first().nodes.first());\n  // Replace the table\n\n\n  return change;\n}\n/**\n * Delete current column in a table\n */\n\n\nfunction removeColumn(opts, change, at) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n  var columnKey;\n\n  if (typeof at === 'undefined') {\n    columnKey = pos.cell.key;\n  } else {\n    columnKey = pos.row.nodes.get(at).key;\n  }\n\n  return removeColumnByKey(opts, change, columnKey);\n}\n/**\n * Delete the whole table at the given node key\n */\n\n\nfunction removeTableByKey(opts, editor, key) {\n  var value = editor.value;\n  var pos = TablePosition.create(opts, value.document, key);\n  var table = pos.table;\n  var document = editor.value.document;\n  var nextFocusBlock = null;\n  var shouldCollapseToEnd = false;\n  var nextBlock = editor.value.document.getNextBlock(table.key);\n\n  if (nextBlock) {\n    nextFocusBlock = nextBlock;\n  } else {\n    var prevBlock = editor.value.document.getPreviousBlock(table.key);\n\n    if (prevBlock) {\n      nextFocusBlock = prevBlock;\n      shouldCollapseToEnd = true;\n    } else if (opts.exitBlockType) {\n      nextFocusBlock = Block.create({\n        type: opts.exitBlockType,\n        nodes: [Text.create('')]\n      });\n      var tableParent = document.getParent(table.key);\n      var insertionIndex = tableParent.nodes.indexOf(table) + 1;\n      editor.insertNodeByKey(tableParent.key, insertionIndex, nextFocusBlock);\n    }\n  }\n\n  editor.removeNodeByKey(table.key);\n\n  if (!nextFocusBlock) {\n    return editor;\n  }\n\n  if (shouldCollapseToEnd) {\n    editor.moveToEndOfNode(nextFocusBlock).focus();\n  } else {\n    editor.moveToStartOfNode(nextFocusBlock).focus();\n  }\n\n  return editor;\n}\n/**\n * Delete the whole table at position\n */\n\n\nfunction removeTable(opts, editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  return removeTableByKey(opts, editor, selection.start.key);\n}\n/**\n * Move selection by a {x,y} relative movement\n */\n\n\nfunction moveSelectionBy(opts, change, x, //  Move horizontally by x\ny // Move vertically by y\n) {\n  var value = change.value;\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n\n  if (!pos.isInCell()) {\n    throw new Error('moveSelectionBy can only be applied in a cell');\n  }\n\n  var rowIndex = pos.getRowIndex();\n  var colIndex = pos.getColumnIndex();\n  var width = pos.getWidth();\n  var height = pos.getHeight();\n\n  var _normPos = normPos(x + colIndex, y + rowIndex, width, height),\n      _normPos2 = _slicedToArray(_normPos, 2),\n      absX = _normPos2[0],\n      absY = _normPos2[1];\n\n  var isGoingUp = y < 0;\n\n  if (absX === -1) {\n    // Out of table\n    return change;\n  }\n\n  var table = pos.table;\n  var row = table.nodes.get(absY);\n  var cell = row.nodes.get(absX);\n\n  if (isGoingUp) {\n    change.moveToEndOfNode(cell);\n  } else {\n    change.moveToStartOfNode(cell);\n  }\n\n  return change;\n}\n/**\n * Normalize position in a table. If x is out of the row, update y accordingly.\n * Returns [-1, -1] if the new selection is out of table\n */\n\n\nfunction normPos(x, y, width, height) {\n  if (x < 0) {\n    x = width - 1;\n    y -= 1;\n  }\n\n  if (y < 0) {\n    return [-1, -1];\n  }\n\n  if (x >= width) {\n    x = 0;\n    y += 1;\n  }\n\n  if (y >= height) {\n    return [-1, -1];\n  }\n\n  return [x, y];\n}\n/**\n * Move selection by a {x,y} relative movement\n */\n\n\nfunction moveSelectionOutOfTable(opts, editor) {\n  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var value = editor.value;\n  var selection = value.selection,\n      document = value.document;\n  var pos = TablePosition.create(opts, document, selection.start.key);\n\n  if (!pos.isInCell()) {\n    throw new Error('moveSelectionOutOfTable can only be applied in a cell');\n  }\n\n  var table = pos.table;\n  var isGoingUp = direction < 0;\n\n  if (isGoingUp) {\n    var previousNode = document.getPreviousBlock(table.key);\n    previousNode && editor.moveToEndOfNode(previousNode);\n  } else {\n    var nextNode = document.getNextBlock(table.key);\n    nextNode && editor.moveToStartOfNode(nextNode);\n  }\n\n  return editor;\n}\n\nvar CHILD_OBJECT_INVALID = 'child_object_invalid';\nvar CHILD_TYPE_INVALID = 'child_type_invalid';\nvar PARENT_TYPE_INVALID = 'parent_type_invalid';\n/*\n * Returns a schema definition for the plugin\n */\n\nfunction schema(opts) {\n  var _blocks;\n\n  return {\n    blocks: (_blocks = {}, _defineProperty(_blocks, opts.typeTable, {\n      nodes: [{\n        match: {\n          type: opts.typeRow\n        }\n      }],\n      parent: [{\n        object: 'document'\n      }],\n      normalize: function normalize(editor, _ref) {\n        var code = _ref.code,\n            node = _ref.node;\n\n        if (code === 'parent_object_invalid') {\n          editor.insertText(node.text);\n          editor.removeNodeByKey(node.key);\n        }\n      }\n    }), _defineProperty(_blocks, opts.typeRow, {\n      nodes: [{\n        match: {\n          type: opts.typeCell\n        }\n      }],\n      parent: {\n        type: opts.typeTable\n      },\n      normalize: function normalize(change, error) {\n        switch (error.code) {\n          case CHILD_TYPE_INVALID:\n            return onlyCellsInRow(opts, change, error);\n\n          case PARENT_TYPE_INVALID:\n            return rowOnlyInTable(opts, change, error);\n        }\n      }\n    }), _defineProperty(_blocks, opts.typeCell, {\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }],\n      parent: {\n        type: opts.typeRow\n      },\n      normalize: function normalize(change, error) {\n        switch (error.code) {\n          case CHILD_OBJECT_INVALID:\n            return onlyBlocksInCell(opts, change, error.node);\n\n          case PARENT_TYPE_INVALID:\n            return cellOnlyInRow(opts, change, error);\n        }\n      }\n    }), _blocks)\n  };\n}\n/*\n * A row's children must be cells.\n * If they're not then we wrap them within a cell.\n */\n\n\nfunction onlyCellsInRow(opts, change, error) {\n  var cell = createCell(opts, []);\n  var index = error.node.nodes.findIndex(function (child) {\n    return child.key === error.child.key;\n  });\n  change.withoutNormalizing(function () {\n    change.insertNodeByKey(error.node.key, index, cell);\n    change.moveNodeByKey(error.child.key, cell.key, 0);\n  });\n}\n/*\n * Rows can't live outside a table, if one is found then we wrap it within a table.\n */\n\n\nfunction rowOnlyInTable(opts, change, error) {\n  return change.wrapBlockByKey(error.node.key, opts.typeTable);\n}\n/*\n * A cell's children must be \"block\"s.\n * If they're not then we wrap them within a block with a type of opts.typeContent\n */\n\n\nfunction onlyBlocksInCell(opts, change, node) {\n  change.wrapBlockByKey(node.nodes.first().key, opts.typeContent);\n  var wrapper = change.value.document.getDescendant(node.key).nodes.first(); // Add in the remaining items\n\n  node.nodes.rest().forEach(function (child, index) {\n    return change.moveNodeByKey(child.key, wrapper.key, index + 1);\n  });\n  return change;\n  /*     const block = Block.create({\n      type: opts.typeContent,\n  });\n  change.withoutNormalizing(() => {\n      change.insertNodeByKey(error.node.key, 0, block);\n      const inlines = error.node.nodes.filter(\n          node => node.object !== 'block',\n      );\n      inlines.forEach((inline, index) => {\n          change.moveNodeByKey(inline.key, block.key, index);\n      });\n  }); */\n}\n/*\n * Cells can't live outside a row, if one is found then we wrap it within a row.\n */\n\n\nfunction cellOnlyInRow(opts, change, error) {\n  return change.wrapBlockByKey(error.node.key, opts.typeRow);\n}\n/*\n * Ensure each row has the same number of columns.\n */\n\n\nfunction normalizeNode(opts) {\n  var isRow = function isRow(node) {\n    return node.type === opts.typeRow;\n  };\n\n  var countNodes = function countNodes(row) {\n    return row.nodes.size;\n  };\n\n  return function (node, editor, next) {\n    if (node.type !== opts.typeTable) {\n      return next();\n    }\n\n    var rows = node.nodes.filter(isRow);\n    var maxColumns = Math.max( // Minimum 1 column\n    1, rows.map(countNodes).max());\n    var rowsMissingColumns = rows.filter(function (row) {\n      return countNodes(row) < maxColumns;\n    });\n\n    if (rowsMissingColumns.isEmpty()) {\n      return next();\n    }\n\n    return function (change) {\n      change.withoutNormalizing(function () {\n        rowsMissingColumns.forEach(function (row) {\n          var numberOfCellsToAdd = maxColumns - row.nodes.size;\n          var cells = Array.from({\n            length: numberOfCellsToAdd\n          }).map(function () {\n            return createCell(opts);\n          });\n          cells.forEach(function (cell) {\n            return change.insertNodeByKey(row.key, row.nodes.size, cell);\n          });\n        });\n      });\n    };\n  };\n}\n/**\n * Returns the core of the plugin, limited to the validation and normalization\n * part of `slate-edit-table`, and utils.\n *\n * Import this directly: `import EditTable from 'slate-edit-table/lib/core'`\n * if you don't care about behavior/rendering and you\n * are only manipulating `Slate.Values` without rendering them.\n * That way you do not depend on `slate-react`.\n */\n\n\nfunction core(optionsParam) {\n  var opts = new Options(optionsParam);\n  return {\n    schema: schema(opts),\n    normalizeNode: normalizeNode(opts),\n    queries: {\n      isSelectionInTable: isSelectionInTable.bind(null, opts),\n      isSelectionOutOfTable: isSelectionOutOfTable.bind(null, opts),\n      getPosition: getPosition.bind(null, opts),\n      getPositionByKey: getPositionByKey.bind(null, opts),\n      createCell: createCell.bind(null, opts),\n      createRow: createRow.bind(null, opts),\n      createTable: createTable.bind(null, opts),\n      forEachCells: forEachCells.bind(null, opts),\n      getCellsAtRow: getCellsAtRow.bind(null, opts),\n      getCellsAtColumn: getCellsAtColumn.bind(null, opts),\n      getCopiedFragment: getCopiedFragment.bind(null, opts)\n    },\n    commands: {\n      insertTable: insertTable.bind(null, opts),\n      insertTableFragmentAtRange: insertTableFragmentAtRange.bind(null, opts),\n      clearCell: clearCell.bind(null, opts),\n      removeRowByKey: removeRowByKey.bind(null, opts),\n      removeColumnByKey: removeColumnByKey.bind(null, opts),\n      removeTableByKey: removeTableByKey.bind(null, opts),\n      insertRow: bindAndScopeChange(opts, insertRow),\n      removeRow: bindAndScopeChange(opts, removeRow),\n      insertColumn: bindAndScopeChange(opts, insertColumn),\n      removeColumn: bindAndScopeChange(opts, removeColumn),\n      removeTable: bindAndScopeChange(opts, removeTable),\n      moveSelection: bindAndScopeChange(opts, moveSelection),\n      moveSelectionBy: bindAndScopeChange(opts, moveSelectionBy),\n      moveSelectionOutOfTable: bindAndScopeChange(opts, moveSelectionOutOfTable)\n    }\n  };\n}\n/**\n * Bind a change to given options, and scope it to act only inside a table\n */\n\n\nfunction bindAndScopeChange(opts, fn) {\n  return function (editor) {\n    if (!editor.isSelectionInTable()) {\n      return editor;\n    } // $FlowFixMe\n\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    return fn.apply(void 0, _toConsumableArray([opts, editor].concat(args)));\n  };\n}\n/**\n * Insert a new row when pressing \"Enter\"\n */\n\n\nfunction onEnter(event, editor, opts, next) {\n  event.preventDefault();\n  var _editor$value = editor.value,\n      selection = _editor$value.selection,\n      document = _editor$value.document;\n  var pos = TablePosition.create(opts, document, selection.start.key);\n  var isAtEdgeOfCell = selection.focus.isAtStartOfNode(pos.cell) || selection.focus.isAtEndOfNode(pos.cell);\n\n  if (!opts.insertRowOnEnter || !isAtEdgeOfCell) {\n    return next();\n  }\n\n  if (event.shiftKey) {\n    return editor.splitBlock().setBlocks({\n      type: opts.typeContent,\n      data: {}\n    });\n  }\n\n  return insertRow(opts, editor);\n}\n/**\n * Exit the current table, by inserting a default block after the table.\n */\n\n\nfunction onModEnter(event, editor, opts, next) {\n  var value = editor.value;\n\n  if (!value.selection.isCollapsed) {\n    return next();\n  }\n\n  event.preventDefault();\n  var exitBlock = Block.create({\n    type: opts.exitBlockType,\n    nodes: [Text.create('')]\n  });\n  var table = TablePosition.create(opts, value.document, value.selection.start.key).table;\n  var tableParent = value.document.getParent(table.key);\n  var insertionIndex = tableParent.nodes.indexOf(table) + 1;\n  return editor.insertNodeByKey(tableParent.key, insertionIndex, exitBlock).moveToStartOfNode(exitBlock);\n}\n/**\n * Select all text of current block.\n */\n\n\nfunction selectAllText(editor) {\n  var value = editor.value;\n  var startBlock = value.startBlock;\n  return editor.moveTo(0).moveFocusForward(startBlock.text.length);\n}\n/**\n * Pressing \"Tab\" moves the cursor to the next cell\n * and select the whole text\n */\n\n\nfunction onTab(event, editor, opts) {\n  event.preventDefault();\n  var value = editor.value;\n  var direction = event.shiftKey ? -1 : +1; // Create new row if needed\n\n  var selection = value.selection;\n  var pos = TablePosition.create(opts, value.document, selection.start.key);\n\n  if (pos.isFirstCell() && direction === -1) {\n    insertRow(opts, editor, 0);\n  } else if (pos.isLastCell() && direction === 1) {\n    insertRow(opts, editor);\n  } // Move back to initial cell (insertRow moves selection automatically).\n\n\n  editor.select(selection); // Move\n\n  moveSelectionBy(opts, editor, direction, 0); // Select all cell.\n\n  return selectAllText(editor);\n}\n\nfunction onBackspace(event, editor, opts, next) {\n  var value = editor.value;\n  var startBlock = value.startBlock,\n      selection = value.selection,\n      endBlock = value.endBlock,\n      document = value.document;\n  var isCollapsed = selection.isCollapsed;\n  var startCell = document.getClosest(startBlock.key, opts.isCell);\n  var endCell = document.getClosest(endBlock.key, opts.isCell);\n  var startPath = startCell.getPath(selection.start.key); // If a cursor is collapsed at the start of the first block, do nothing\n\n  if (selection.start.offset === 0 && isCollapsed && startPath && startPath.every(function (index) {\n    return index === 0;\n  })) {\n    if (editor.isVoid(startBlock)) {\n      // Delete the block normally if it is a void block\n      return next();\n    }\n\n    event.preventDefault();\n    return editor;\n  } // If \"normal\" deletion, we continue\n\n\n  if (startCell === endCell) {\n    return next();\n  } // If cursor is between multiple blocks,\n  // we clear the content of the cells.\n\n\n  event.preventDefault();\n  var blocks = value.blocks; // Get all cells that contains the selection\n\n  var cells = blocks.map(function (node) {\n    return node.type === opts.typeCell ? node : document.getClosest(node.key, function (a) {\n      return a.type === opts.typeCell;\n    });\n  }).toSet(); // If the cursor is at the very end of the first cell, ignore it.\n  // If the cursor is at the very start of the last cell, ignore it.\n  // This behavior is to compensate hanging selection behaviors:\n  // https://github.com/ianstormtaylor/slate/pull/1605\n\n  var ignoreFirstCell = value.selection.moveToStart().anchor.isAtEndOfNode(cells.first());\n  var ignoreLastCell = value.selection.moveToEnd().anchor.isAtStartOfNode(cells.last());\n  var cellsToClear = cells;\n\n  if (ignoreFirstCell) {\n    cellsToClear = cellsToClear.rest();\n  }\n\n  if (ignoreLastCell) {\n    cellsToClear = cellsToClear.butLast();\n  } // Clear all the selection\n\n\n  cellsToClear.forEach(function (cell) {\n    return clearCell(opts, editor, cell);\n  }); // Update the selection properly, and avoid reset of selection\n\n  var updatedStartCell = editor.value.document.getDescendant(cellsToClear.first().key);\n  return editor.moveToStartOfNode(updatedStartCell);\n}\n\nfunction onUpDown(event, editor, opts, next) {\n  var value = editor.value;\n  var direction = event.key === 'ArrowUp' ? -1 : +1;\n  var pos = TablePosition.create(opts, value.document, value.selection.start.key);\n\n  if (pos.isFirstRow() && direction === -1 && pos.isTopOfCell() || pos.isLastRow() && direction === +1 && pos.isBottomOfCell()) {\n    if (opts.edgeRowExitOnDirection) {\n      event.preventDefault();\n      return moveSelectionOutOfTable(opts, editor, direction);\n    } else {\n      // Let the default behavior move out of the table\n      return next();\n    }\n  }\n\n  if (direction === -1 && !pos.isTopOfCell()) {\n    return next();\n  }\n\n  if (direction === +1 && !pos.isBottomOfCell()) {\n    return next();\n  }\n\n  event.preventDefault();\n  moveSelectionBy(opts, editor, 0, direction);\n  return editor;\n}\n\nfunction onUpDown$1(event, editor, opts) {\n  var direction = event.key === 'ArrowUp' ? -1 : +1;\n  event.preventDefault();\n  moveSelectionOutOfTable(opts, editor, direction);\n  return editor;\n}\n\nvar KEY_ENTER = 'Enter';\nvar KEY_TAB = 'Tab';\nvar KEY_BACKSPACE = 'Backspace';\nvar KEY_DOWN = 'ArrowDown';\nvar KEY_UP = 'ArrowUp';\n/**\n * User is pressing a key in the editor\n */\n\nfunction onKeyDown(opts, event, editor, next) {\n  // Only handle events in cells\n  if (!editor.isSelectionInTable()) {\n    return next();\n  } // Build arguments list\n\n\n  var args = [event, editor, opts, next];\n\n  switch (event.key) {\n    case KEY_ENTER:\n      if (event.metaKey && opts.exitBlockType) {\n        return onModEnter.apply(void 0, args);\n      }\n\n      return onEnter.apply(void 0, args);\n\n    case KEY_TAB:\n      return onTab.apply(void 0, args);\n\n    case KEY_BACKSPACE:\n      return onBackspace.apply(void 0, args);\n\n    case KEY_DOWN:\n    case KEY_UP:\n      if (event.metaKey) {\n        return onUpDown$1.apply(void 0, args);\n      }\n\n      return onUpDown.apply(void 0, args);\n\n    default:\n      return next();\n  }\n}\n\nfunction onCopy(opts, event, editor, next) {\n  if (!editor.isSelectionInTable()) {\n    return next();\n  }\n\n  var fragment = getCopiedFragment(opts, editor.value);\n  if (!fragment) return next();\n  var tempEditor = new Editor({\n    value: Value.fromJSON({\n      document: fragment\n    })\n  });\n  tempEditor.moveToRangeOfDocument();\n  cloneFragment(event, tempEditor);\n}\n/**\n *  Returns the full plugin object (behavior + rendering + schema)\n */\n\n\nfunction EditTable( // The plugin options\noptionsParam) {\n  var opts = new Options(optionsParam || {});\n  var corePlugin = core(opts);\n  return _objectSpread({}, corePlugin, {\n    onKeyDown: onKeyDown.bind(null, opts),\n    onCopy: onCopy.bind(null, opts)\n  });\n}\n\nexport default EditTable;","map":{"version":3,"sources":["../src/options.js","../src/utils/createCell.js","../src/utils/createRow.js","../src/utils/createTable.js","../src/utils/TablePosition.js","../src/utils/getPosition.js","../src/utils/getPositionByKey.js","../src/utils/isRangeInTable.js","../src/utils/isSelectionInTable.js","../src/utils/isSelectionOutOfTable.js","../src/utils/forEachCells.js","../src/utils/getCellsAtRow.js","../src/utils/getCellsAtColumn.js","../src/utils/getCopiedFragment.js","../src/changes/insertTable.js","../src/changes/insertRow.js","../src/changes/moveSelection.js","../src/changes/insertColumn.js","../src/changes/insertTableFragmentAtRange.js","../src/changes/clearCell.js","../src/changes/removeRowByKey.js","../src/changes/removeRow.js","../src/changes/removeColumnByKey.js","../src/changes/removeColumn.js","../src/changes/removeTableByKey.js","../src/changes/removeTable.js","../src/changes/moveSelectionBy.js","../src/changes/moveSelectionOutOfTable.js","../src/validation/slate-schema-violations.js","../src/validation/schema.js","../src/validation/normalizeNode.js","../src/core.js","../src/handlers/onEnter.js","../src/handlers/onModEnter.js","../src/handlers/onTab.js","../src/handlers/onBackspace.js","../src/handlers/onUpDown.js","../src/handlers/onModUpDown.js","../src/handlers/onKeyDown.js","../src/handlers/onCopy.js","../src/index.js"],"names":["Options","Record","typeTable","typeRow","typeCell","typeContent","exitBlockType","insertRowOnEnter","edgeRowExitOnDirection","isCell","node","type","opts","nodes","createEmptyContent","Text","cellNodes","createCell","getCellContent","Block","rowNodes","createRow","TablePosition","tableBlock","rowBlock","cellBlock","contentBlock","containerNode","key","ancestors","p","ancestor","Boolean","index","next","table","rows","cells","row","x","cell","value","editor","start","end","range","startPosition","endPosition","selection","isRangeInTable","fn","document","baseFragment","copiedCell","n","columns","change","createTable","pos","newRow","getRow","at","columnIndex","newCell","getCell","moveSelection","insertedTable","fragment","targetPosition","fragmentRows","fragmentHeight","fragmentWidth","missingWidth","missingHeight","Array","insertColumn","insertRow","existingTable","fragmentRow","existingCell","lastPastedCell","newBlock","clearCell","rowKey","removeRowByKey","colIndex","columnKey","removeColumnByKey","nextFocusBlock","shouldCollapseToEnd","nextBlock","prevBlock","tableParent","insertionIndex","removeTableByKey","rowIndex","width","height","absX","absY","normPos","y","isGoingUp","direction","previousNode","nextNode","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","PARENT_TYPE_INVALID","blocks","match","parent","object","normalize","code","error","onlyCellsInRow","rowOnlyInTable","onlyBlocksInCell","cellOnlyInRow","child","wrapper","isRow","countNodes","maxColumns","rowsMissingColumns","numberOfCellsToAdd","length","schema","normalizeNode","queries","isSelectionInTable","isSelectionOutOfTable","getPosition","getPositionByKey","forEachCells","getCellsAtRow","getCellsAtColumn","getCopiedFragment","commands","insertTable","insertTableFragmentAtRange","bindAndScopeChange","removeRow","removeColumn","removeTable","moveSelectionBy","moveSelectionOutOfTable","args","event","isAtEdgeOfCell","data","exitBlock","startBlock","selectAllText","endBlock","isCollapsed","startCell","endCell","startPath","a","ignoreFirstCell","ignoreLastCell","cellsToClear","updatedStartCell","KEY_ENTER","KEY_TAB","KEY_BACKSPACE","KEY_DOWN","KEY_UP","onModEnter","onEnter","onTab","onBackspace","onModUpDown","onUpDown","tempEditor","cloneFragment","optionsParam","corePlugin","core","onKeyDown","onCopy"],"mappings":"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","sourcesContent":["// @flow\n\nimport { Record } from 'immutable';\nimport type { Node } from 'slate';\n\nexport type OptionsFormat = {\n    typeTable?: string,\n    typeRow?: string,\n    typeCell?: string,\n    typeContent?: string,\n    exitBlockType?: string\n};\n\n/**\n * The plugin options\n */\nclass Options extends Record({\n    typeTable: 'table',\n    typeRow: 'table_row',\n    typeCell: 'table_cell',\n    typeContent: 'paragraph',\n    exitBlockType: 'paragraph',\n    insertRowOnEnter: true,\n    edgeRowExitOnDirection: false,\n}) {\n    // Done as comments to prevent defining properties\n    // https://github.com/babel/babel/issues/8417\n    /*:: typeTable: string; */\n    /*:: typeRow: string; */\n    /*:: typeCell: string; */\n    /*:: typeContent: string; */\n    /*:: exitBlockType: string; */\n\n    /*\n     * Return a node filter to find a cell.\n     */\n    isCell = (node: Node): boolean =>\n        node.object == 'block' && node.type == this.typeCell;\n}\n\nexport default Options;\n","// @flow\nimport { Block, Text, type Node } from 'slate';\n\nimport type Options from '../options';\n\n/**\n * Create a new cell\n */\nfunction createCell(opts: Options, nodes?: Node[]): Block {\n    return Block.create({\n        type: opts.typeCell,\n        nodes: nodes || [createEmptyContent(opts)],\n    });\n}\n\n/**\n * Create a new default content block\n */\nfunction createEmptyContent(opts: Options): Block {\n    return Block.create({\n        type: opts.typeContent,\n        nodes: [Text.create()],\n    });\n}\n\nexport default createCell;\n","// @flow\nimport { Range } from 'immutable';\nimport { Block, type Node } from 'slate';\n\nimport type Options from '../options';\nimport createCell from './createCell';\n\n/**\n * Create a new row block\n */\nfunction createRow(\n    opts: Options,\n    columns: number,\n    getCellContent?: (column: number) => Node[],\n): Block {\n    const cellNodes = Range(0, columns)\n        .map(i =>\n            createCell(opts, getCellContent ? getCellContent(i) : undefined),\n        )\n        .toJS();\n\n    return Block.create({\n        type: opts.typeRow,\n        nodes: Block.createList(cellNodes),\n    });\n}\n\nexport default createRow;\n","// @flow\nimport { Range } from 'immutable';\nimport { Block, type Node } from 'slate';\n\nimport type Options from '../options';\nimport createRow from './createRow';\n\n/**\n * Create a table\n */\nfunction createTable(\n    opts: Options,\n    columns: number,\n    rows: number,\n    getCellContent?: (row: number, column: number) => Node[]\n): Block {\n    const rowNodes = Range(0, rows)\n        .map(i =>\n            createRow(\n                opts,\n                columns,\n                getCellContent ? getCellContent.bind(null, i) : undefined\n            )\n        )\n        .toJS();\n\n    return Block.create({\n        type: opts.typeTable,\n        nodes: Block.createList(rowNodes)\n    });\n}\n\nexport default createTable;\n","// @flow\nimport { Record } from 'immutable';\nimport { Block, type Node } from 'slate';\n\nimport type Options from '../options';\n\nclass TablePosition extends Record({\n    tableBlock: null,\n    rowBlock: null,\n    cellBlock: null,\n    contentBlock: null,\n    node: null,\n}) {\n    // Block container for the table\n    /*::tableBlock: ?Block;*/\n\n    // Block for current row\n    /*::rowBlock: ?Block;*/\n\n    // Block for current cell\n    /*::cellBlock: ?Block;*/\n\n    // Current content block in the cell\n    /*::contentBlock: ?Block;*/\n\n    /**\n     * Create a new instance of a TablePosition from a Slate document\n     * and a node key.\n     */\n    static create(\n        opts: Options,\n        containerNode: Node,\n        key: string,\n    ): TablePosition {\n        const node = containerNode.getDescendant(key);\n        const ancestors = containerNode.getAncestors(key).push(node);\n        const tableBlock = ancestors.findLast(p => p.type === opts.typeTable);\n        const rowBlock = ancestors.findLast(p => p.type === opts.typeRow);\n\n        const cellBlock = ancestors.findLast(p => p.type === opts.typeCell);\n        const contentBlock = ancestors\n            .skipUntil(ancestor => ancestor === cellBlock)\n            .skip(1)\n            .first();\n\n        return new TablePosition({\n            tableBlock,\n            rowBlock,\n            cellBlock,\n            contentBlock,\n            node,\n        });\n    }\n\n    get table(): Block {\n        if (!this.tableBlock) {\n            throw new Error('Not in a table');\n        }\n        return this.tableBlock;\n    }\n\n    get row(): Block {\n        if (!this.rowBlock) {\n            throw new Error('Not in a row');\n        }\n        return this.rowBlock;\n    }\n\n    get cell(): Block {\n        if (!this.cellBlock) {\n            throw new Error('Not in a cell');\n        }\n        return this.cellBlock;\n    }\n\n    /**\n     * Check to see if this position is within a cell\n     */\n    isInCell(): boolean {\n        return Boolean(this.cellBlock);\n    }\n\n    /**\n     * Check to see if this position is within a row\n     */\n    isInRow(): boolean {\n        return Boolean(this.rowBlock);\n    }\n\n    /**\n     * Check to see if this position is within a table\n     */\n    isInTable(): boolean {\n        return Boolean(this.tableBlock);\n    }\n\n    /**\n     * Check to see if this position is at the top of the cell.\n     */\n    isTopOfCell(): boolean {\n        const { cellBlock, node} = this;\n\n        if (!cellBlock || !node) {\n            return false;\n        }\n        \n        return cellBlock.getPath(node.key).every(index => index === 0);\n    }\n\n    /**\n     * Check to see if this position is at the bottom of the cell.\n     */\n    isBottomOfCell(): boolean {\n        const { node, cellBlock } = this;\n\n        if (!node || !cellBlock) {\n            return false;\n        }\n\n        const ancestors = cellBlock.getAncestors(node.key);\n\n\n        return ancestors.every((node, index) => {\n          const next = ancestors.get(index + 1);\n          if(!next) return true;\n          return node.nodes.indexOf(next) === (node.nodes.size - 1);\n        });\n    }\n\n    /**\n     * Get count of columns\n     */\n    getWidth(): number {\n        const { table } = this;\n        const rows = table.nodes;\n        const cells = rows.first().nodes;\n\n        return cells.size;\n    }\n\n    /**\n     * Get count of rows\n     */\n    getHeight(): number {\n        const { table } = this;\n        const rows = table.nodes;\n\n        return rows.size;\n    }\n\n    /**\n     * Get index of current row in the table.\n     */\n    getRowIndex(): number {\n        const { table, row } = this;\n        const rows = table.nodes;\n\n        return rows.findIndex(x => x === row);\n    }\n\n    /**\n     * Get index of current column in the row.\n     */\n    getColumnIndex(): number {\n        const { row, cell } = this;\n        const cells = row.nodes;\n\n        return cells.findIndex(x => x === cell);\n    }\n\n    /**\n     * True if on first cell of the table\n     */\n    isFirstCell(): boolean {\n        return this.isFirstRow() && this.isFirstColumn();\n    }\n\n    /**\n     * True if on last cell of the table\n     */\n    isLastCell(): boolean {\n        return this.isLastRow() && this.isLastColumn();\n    }\n\n    /**\n     * True if on first row\n     */\n    isFirstRow(): boolean {\n        return this.getRowIndex() === 0;\n    }\n\n    /**\n     * True if on last row\n     */\n    isLastRow(): boolean {\n        return this.getRowIndex() === this.getHeight() - 1;\n    }\n\n    /**\n     * True if on first column\n     */\n    isFirstColumn(): boolean {\n        return this.getColumnIndex() === 0;\n    }\n\n    /**\n     * True if on last column\n     */\n    isLastColumn(): boolean {\n        return this.getColumnIndex() === this.getWidth() - 1;\n    }\n}\n\nexport default TablePosition;\n","// @flow\nimport type Options from '../options';\n\nimport TablePosition from './TablePosition';\n\n/**\n * The position of the selection start block, in the current table\n */\nfunction getPosition(\n    opts: Options,\n    editor,\n): TablePosition {\n    const {value} = editor;\n    if (!value.selection.start || !value.selection.start.key) return new TablePosition();\n    return TablePosition.create(opts, value.document, value.selection.start.key);\n}\n\nexport default getPosition;\n","// @flow\nimport { type Node } from 'slate';\n\nimport type Options from '../options';\n\nimport TablePosition from './TablePosition';\n\n/*\n * The position of a particular node, in the current table\n */\nfunction getPositionByKey(\n    opts: Options,\n    editor,\n    containerNode: Node,\n    // Key of the node in desired position\n    key: string\n): TablePosition {\n    return TablePosition.create(opts, containerNode, key);\n}\n\nexport default getPositionByKey;\n","// @flow\n\nimport type { Node, Range } from 'slate';\n\nimport TablePosition from './TablePosition';\nimport type Options from '../options';\n\n/**\n * True if the given range is inside one table\n */\nfunction isRangeInTable(opts: Options, node: Node, range: Range): boolean {\n    const { start, end } = range;\n    const startPosition = TablePosition.create(opts, node, start.key);\n    const endPosition = TablePosition.create(opts, node, end.key);\n\n    // Only handle events in tables\n    if (!startPosition.isInTable() || !endPosition.isInTable()) {\n        return false;\n    }\n\n    // Inside the same table\n    return startPosition.table === endPosition.table;\n}\n\nexport default isRangeInTable;\n","// @flow\n\nimport type Options from '../options';\nimport isRangeInTable from './isRangeInTable';\n\n/**\n * Is the selection in a table\n */\nfunction isSelectionInTable(opts: Options, editor): boolean {\n    const {value} = editor;\n    const {selection} = value;\n\n    if (!selection.start.key) return false;\n    return isRangeInTable(opts, value.document, value.selection);\n}\n\nexport default isSelectionInTable;\n","// @flow\n\nimport TablePosition from './TablePosition';\nimport type Options from '../options';\n\n/**\n * Are the selection start and end outside a table.\n */\nfunction isSelectionOutOfTable(opts: Options, editor): boolean {\n    const {value} = editor;\n    const {selection} = value;\n\n    if (!selection.start.key) return false;\n\n    const startPosition = TablePosition.create(opts, value.document, selection.start.key);\n    const endPosition = TablePosition.create(opts, value.document, selection.end.key);\n\n    // Only handle events in tables\n    return !startPosition.isInTable() && !endPosition.isInTable();\n}\n\nexport default isSelectionOutOfTable;\n","// @flow\nimport { type Block } from 'slate';\n\nimport type Options from '../options';\n\n/**\n * Run the given function against each cells of the table\n */\nfunction forEachCells(\n    opts: Options,\n    // The table\n    table: Block,\n    fn: (cell: Block, row: number, column: number) => any\n): void {\n    return table.nodes.forEach((row, rowIndex) =>\n        row.nodes.forEach((cell, columnIndex) =>\n            fn(cell, rowIndex, columnIndex)\n        )\n    );\n}\n\nexport default forEachCells;\n","// @flow\nimport { type Block } from 'slate';\nimport { type List } from 'immutable';\n\nimport type Options from '../options';\n\n/**\n * Returns the list of cells at the given row index\n */\nfunction getCellsAtRow(\n    opts: Options,\n    editor,\n    table: Block,\n    rowIndex: number\n): List<Block> {\n    return table.nodes.get(rowIndex).nodes;\n}\n\nexport default getCellsAtRow;\n","// @flow\nimport { type Block } from 'slate';\nimport { type List } from 'immutable';\n\nimport type Options from '../options';\n\n/**\n * Returns the list of cells at the given column index\n */\nfunction getCellsAtColumn(\n    opts: Options,\n    editor,\n    table: Block,\n    columnIndex: number\n): List<Block> {\n    return table.nodes.map(row => row.nodes.get(columnIndex));\n}\n\nexport default getCellsAtColumn;\n","/* @flow */\nimport {type Value, type Document} from 'slate';\n\nimport type Options from '../options';\nimport TablePosition from './TablePosition';\n\nfunction getCopiedFragment(opts: Options, value: Value): ?Document {\n  const {selection, document} = value;\n  const startPosition = TablePosition.create(\n    opts,\n    document,\n    selection.start.key\n  );\n  const endPosition = TablePosition.create(opts, document, selection.end.key);\n\n  // Fragment as it would be copied by Slate\n  const baseFragment = value.fragment;\n\n  if (endPosition.cell === startPosition.cell) {\n    // The selection is inside a single cell. Only copy the content of that cell\n    const copiedCell = baseFragment\n      .getAncestors(baseFragment.getFirstText().key)\n      .findLast(n => n.type === opts.typeCell);\n\n    return baseFragment.merge({\n      nodes: copiedCell.nodes,\n    });\n  }\n}\n\nexport default getCopiedFragment;\n","// @flow\nimport { type Change, type Node } from 'slate';\n\nimport { createTable } from '../utils';\nimport type Options from '../options';\n\n/**\n * Insert a new table\n */\nfunction insertTable(\n    opts: Options,\n    change: Change,\n    columns?: number = 2,\n    rows?: number = 2,\n    getCellContent?: (column: number, row: number) => Node[]\n): Change {\n    const { value } = change;\n\n    if (!value.selection.start.key) return change;\n\n    // Create the table node\n    const table = createTable(opts, columns, rows, getCellContent);\n\n    return change.insertBlock(table);\n}\n\nexport default insertTable;\n","// @flow\nimport { type Change, type Block } from 'slate';\n\nimport { TablePosition, createRow } from '../utils';\nimport type Options from '../options';\n\n/**\n * Insert a new row in current table\n */\nfunction insertRow(\n    opts: Options,\n    change: Change,\n    at?: number, // row index\n    getRow?: (columns: number) => Block, // Generate the row yourself\n) {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    const { table } = pos;\n\n    // Create a new row with the right count of cells\n    const columns = table.nodes.get(0).nodes.size;\n    const newRow = getRow ? getRow(columns) : createRow(opts, columns);\n\n    if (typeof at === 'undefined') {\n        at = pos.getRowIndex() + 1;\n    }\n\n    return change\n        .insertNodeByKey(table.key, at, newRow)\n        .moveToEndOfNode(newRow.nodes.get(pos.getColumnIndex()));\n}\n\nexport default insertRow;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Move selection to {x,y}\n */\nfunction moveSelection(\n    opts: Options,\n    change: Change,\n    x: number,\n    y: number\n): Change {\n    const { value } = change;\n    const { selection } = value;\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n\n    if (!pos.isInCell()) {\n        throw new Error('moveSelection can only be applied from within a cell');\n    }\n\n    const { table } = pos;\n    const row = table.nodes.get(y);\n    const cell = row.nodes.get(x);\n\n    return change.moveToStartOfNode(cell);\n}\n\nexport default moveSelection;\n","// @flow\nimport { type Change, type Block } from 'slate';\n\nimport { TablePosition, createCell } from '../utils';\nimport moveSelection from './moveSelection';\n\nimport type Options from '../options';\n\n/**\n * Insert a new column in current table\n */\nfunction insertColumn(\n    opts: Options,\n    change: Change,\n    at?: number, // Column index\n    getCell?: (column: number, row: number) => Block,\n): Change {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    const { table } = pos;\n\n    const columnIndex =\n        typeof at === 'undefined' ? pos.getColumnIndex() + 1 : at;\n\n    // Insert the new cell\n    change.withoutNormalizing(() => {\n        table.nodes.forEach((row, rowIndex) => {\n            const newCell = getCell\n                ? getCell(columnIndex, rowIndex)\n                : createCell(opts);\n            change.insertNodeByKey(row.key, columnIndex, newCell);\n        });\n    });\n\n    // Update the selection (not doing can break the undo)\n    return moveSelection(\n        opts,\n        change,\n        pos.getColumnIndex() + 1,\n        pos.getRowIndex(),\n    );\n}\n\nexport default insertColumn;\n","// @flow\nimport { type Change, type Range, type Document } from 'slate';\n\nimport insertRow from './insertRow';\nimport insertColumn from './insertColumn';\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Used when pasting a fragment of table into another one\n */\nfunction insertTableFragmentAtRange(\n    opts: Options,\n    change: Change,\n    range: Range,\n    // This fragment should contain only one table,\n    // with a valid number of cells\n    fragment: Document\n): Change {\n    const insertedTable = fragment.nodes.first();\n    if (\n        !(\n            fragment.nodes.size === 1 &&\n            insertedTable &&\n            insertedTable.type === opts.typeTable\n        )\n    ) {\n        throw new Error('Expected to insert a fragment containing one table');\n    }\n\n    const { value } = change;\n    const targetPosition = TablePosition.create(\n        opts,\n        value.document,\n        value.selection.start.key\n    );\n\n    const fragmentRows = insertedTable.nodes;\n    const fragmentHeight = fragmentRows.size;\n    const fragmentWidth = fragmentRows.first().nodes.size;\n\n    // Insert columns and rows to accomodate the incoming pasted cells\n    const missingWidth =\n        fragmentWidth +\n        targetPosition.getColumnIndex() -\n        targetPosition.getWidth();\n    const missingHeight =\n        fragmentHeight +\n        targetPosition.getRowIndex() -\n        targetPosition.getHeight();\n\n    if (missingWidth > 0) {\n        // Add columns\n        Array(missingWidth)\n            .fill()\n            .forEach(() => {\n                insertColumn(opts, change, targetPosition.getWidth());\n            });\n    }\n    if (missingHeight > 0) {\n        // Add rows\n        Array(missingHeight)\n            .fill()\n            .forEach(() => {\n                insertRow(opts, change, targetPosition.getHeight());\n            });\n    }\n\n    // Patch the inserted table over the target table, overwritting the cells\n    const existingTable = change.value.document.getDescendant(\n        targetPosition.table.key\n    );\n\n    change.withoutNormalizing(() => {\n    fragmentRows.forEach((fragmentRow, fragmentRowIndex) => {\n        fragmentRow.nodes.forEach((newCell, fragmentColumnIndex) => {\n            const existingCell = existingTable.nodes\n                .get(targetPosition.getRowIndex() + fragmentRowIndex)\n                .nodes.get(\n                    targetPosition.getColumnIndex() + fragmentColumnIndex\n                );\n            change.replaceNodeByKey(existingCell.key, newCell);\n                });\n        });\n    });\n\n    const lastPastedCell = fragmentRows.last().nodes.last();\n    return change.moveToEndOfNode(lastPastedCell);\n}\n\nexport default insertTableFragmentAtRange;\n","// @flow\nimport { Block, type Change } from 'slate';\n\nimport type Options from '../options';\n\n/**\n * Clear the content of the given cell\n */\nfunction clearCell(opts: Options, change: Change, cell: Block): Change {\n    const newBlock = Block.create({ type: opts.typeContent });\n    const { nodes } = cell;\n\n    // Insert a new empty node\n    change.withoutNormalizing(() => {\n        change.insertNodeByKey(cell.key, 0, newBlock);\n    });\n\n    // Remove all previous nodes\n    nodes.forEach(node => {\n        change.removeNodeByKey(node.key);\n    });\n\n    return change;\n}\n\nexport default clearCell;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport clearCell from './clearCell';\nimport type Options from '../options';\n\n/**\n * Remove the row associated to a given key in a table.\n * Clear thw row if last remaining row\n */\nfunction removeRowByKey(opts: Options, change: Change, key: string): Change {\n    const { value } = change;\n\n    const pos = TablePosition.create(opts, value.document, key);\n\n    // Update table by removing the row\n    if (pos.getHeight() > 1) {\n        change.removeNodeByKey(key);\n    } else {\n        // If last remaining row, clear it instead\n        pos.row.nodes.forEach(cell => {\n            cell.nodes.forEach(() => clearCell(opts, change, cell));\n        });\n    }\n    // this will also invalidate the selection - move it to the first cell\n    // change.moveToRangeOfNode(pos.row.nodes.first());\n    \n    return change;\n}\n\nexport default removeRowByKey;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\nimport removeRowByKey from './removeRowByKey';\n\n/**\n * Remove current row in a table. Clear it if last remaining row\n */\nfunction removeRow(opts: Options, change: Change, at: number): Change {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n\n    let rowKey;\n    if (typeof at === 'undefined') {\n        rowKey = pos.row.key;\n    } else {\n        rowKey = pos.table.nodes.get(at).key;\n    }\n\n    return removeRowByKey(opts, change, rowKey);\n}\n\nexport default removeRow;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport clearCell from './clearCell';\nimport type Options from '../options';\n\n/**\n * Delete the column associated with the given cell key in a table\n */\nfunction removeColumnByKey(opts: Options, change: Change, key: string): Change {\n    const { value } = change;\n\n    const pos = TablePosition.create(opts, value.document, key);\n    const { table } = pos;\n\n    const colIndex = pos.getColumnIndex();\n    \n    const rows = table.nodes;\n\n    // Remove the cell from every row\n    if (pos.getWidth() > 1) {\n        change.withoutNormalizing(() => {\n        rows.forEach(row => {\n            const cell = row.nodes.get(colIndex);\n                change.removeNodeByKey(cell.key);\n            });\n        });\n    } else {\n        // If last column, clear text in cells instead\n        rows.forEach(row => {\n            row.nodes.forEach(cell => {\n                cell.nodes.forEach(() => clearCell(opts, change, cell));\n            });\n        });\n    }\n\n    // this will also invalidate the selection - move it to the first cell\n    // change.moveToRangeOfNode(rows.first().nodes.first());\n\n    // Replace the table\n    return change;\n}\n\nexport default removeColumnByKey;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport removeColumnByKey from './removeColumnByKey';\n\nimport type Options from '../options';\n\n/**\n * Delete current column in a table\n */\nfunction removeColumn(opts: Options, change: Change, at: number): Change {\n    const { value } = change;\n    const { selection } = value;\n\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n\n    let columnKey;\n    if (typeof at === 'undefined') {\n        columnKey = pos.cell.key;\n    } else {\n        columnKey = pos.row.nodes.get(at).key;\n    }\n\n    return removeColumnByKey(opts, change, columnKey);\n}\n\nexport default removeColumn;\n","// @flow\nimport { Block, Text } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Delete the whole table at the given node key\n */\nfunction removeTableByKey(opts: Options, editor, key: string): * {\n    const { value } = editor;\n\n    const pos = TablePosition.create(opts, value.document, key);\n    const { table } = pos;\n    const { document } = editor.value;\n    let nextFocusBlock = null;\n    let shouldCollapseToEnd = false;\n\n    const nextBlock = editor.value.document.getNextBlock(table.key);\n    if (nextBlock) {\n        nextFocusBlock = nextBlock;\n    } else {\n        const prevBlock = editor.value.document.getPreviousBlock(table.key);\n        if (prevBlock) {\n            nextFocusBlock = prevBlock;\n            shouldCollapseToEnd = true;\n        } else if (opts.exitBlockType) {\n            nextFocusBlock = Block.create({\n                type: opts.exitBlockType,\n                nodes: [Text.create('')],\n            });\n            const tableParent = document.getParent(table.key);\n            const insertionIndex = tableParent.nodes.indexOf(table) + 1;\n            editor.insertNodeByKey(\n                tableParent.key,\n                insertionIndex,\n                nextFocusBlock,\n            );\n        }\n    }\n\n    editor.removeNodeByKey(table.key);\n    if (!nextFocusBlock) {\n        return editor;\n    }\n    if (shouldCollapseToEnd) {\n        editor.moveToEndOfNode(nextFocusBlock).focus();\n    } else {\n        editor.moveToStartOfNode(nextFocusBlock).focus();\n    }\n    return editor;\n}\n\nexport default removeTableByKey;\n","// @flow\n\nimport type Options from '../options';\nimport removeTableByKey from './removeTableByKey';\n\n/**\n * Delete the whole table at position\n */\nfunction removeTable(opts: Options, editor) {\n    const { value } = editor;\n    const { selection } = value;\n\n    return removeTableByKey(opts, editor, selection.start.key);\n}\n\nexport default removeTable;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Move selection by a {x,y} relative movement\n */\nfunction moveSelectionBy(\n    opts: Options,\n    change: Change,\n    x: number, //  Move horizontally by x\n    y: number // Move vertically by y\n): Change {\n    const { value } = change;\n    const { selection } = value;\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    if (!pos.isInCell()) {\n        throw new Error('moveSelectionBy can only be applied in a cell');\n    }\n\n    const rowIndex = pos.getRowIndex();\n    const colIndex = pos.getColumnIndex();\n    const width = pos.getWidth();\n    const height = pos.getHeight();\n\n    const [absX, absY] = normPos(x + colIndex, y + rowIndex, width, height);\n    const isGoingUp = y < 0;\n\n    if (absX === -1) {\n        // Out of table\n        return change;\n    }\n\n    const { table } = pos;\n    const row = table.nodes.get(absY);\n    const cell = row.nodes.get(absX);\n\n    if (isGoingUp) {\n        change.moveToEndOfNode(cell);\n    } else {\n        change.moveToStartOfNode(cell);\n    }\n\n    return change;\n}\n\n/**\n * Normalize position in a table. If x is out of the row, update y accordingly.\n * Returns [-1, -1] if the new selection is out of table\n */\nfunction normPos(\n    x: number,\n    y: number,\n    width: number,\n    height: number\n): number[] {\n    if (x < 0) {\n        x = width - 1;\n        y -= 1;\n    }\n\n    if (y < 0) {\n        return [-1, -1];\n    }\n\n    if (x >= width) {\n        x = 0;\n        y += 1;\n    }\n\n    if (y >= height) {\n        return [-1, -1];\n    }\n\n    return [x, y];\n}\n\nexport default moveSelectionBy;\n","// @flow\nimport { type Editor } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Move selection by a {x,y} relative movement\n */\nfunction moveSelectionOutOfTable(\n    opts: Options,\n    editor: Editor,\n    direction: number = 1 // Move down: +1, up: -1\n): Editor {\n    const { value } = editor;\n    const { selection, document } = value;\n    const pos = TablePosition.create(opts, document, selection.start.key);\n    \n    if (!pos.isInCell()) {\n        throw new Error('moveSelectionOutOfTable can only be applied in a cell');\n    }\n\n    const table = pos.table;\n\n    const isGoingUp = direction < 0;\n\n    if (isGoingUp) {\n        const previousNode = document.getPreviousBlock(table.key);\n        previousNode && editor.moveToEndOfNode(previousNode);\n    } else {\n        const nextNode = document.getNextBlock(table.key);\n        nextNode && editor.moveToStartOfNode(nextNode);\n    }\n\n    return editor;\n}\n\nexport default moveSelectionOutOfTable;\n","const CHILD_OBJECT_INVALID = 'child_object_invalid';\nconst CHILD_REQUIRED = 'child_required';\nconst CHILD_TYPE_INVALID = 'child_type_invalid';\nconst CHILD_UNKNOWN = 'child_unknown';\nconst FIRST_CHILD_OBJECT_INVALID = 'first_child_object_invalid';\nconst FIRST_CHILD_TYPE_INVALID = 'first_child_type_invalid';\nconst LAST_CHILD_OBJECT_INVALID = 'last_child_object_invalid';\nconst LAST_CHILD_TYPE_INVALID = 'last_child_type_invalid';\nconst NODE_DATA_INVALID = 'node_data_invalid';\nconst NODE_IS_VOID_INVALID = 'node_is_void_invalid';\nconst NODE_MARK_INVALID = 'node_mark_invalid';\nconst NODE_TEXT_INVALID = 'node_text_invalid';\nconst PARENT_INVALID = 'parent_invalid';\nconst PARENT_TYPE_INVALID = 'parent_type_invalid';\n\nexport {\n  CHILD_OBJECT_INVALID,\n  CHILD_REQUIRED,\n  CHILD_TYPE_INVALID,\n  CHILD_UNKNOWN,\n  FIRST_CHILD_OBJECT_INVALID,\n  FIRST_CHILD_TYPE_INVALID,\n  LAST_CHILD_OBJECT_INVALID,\n  LAST_CHILD_TYPE_INVALID,\n  NODE_DATA_INVALID,\n  NODE_IS_VOID_INVALID,\n  NODE_MARK_INVALID,\n  NODE_TEXT_INVALID,\n  PARENT_INVALID,\n  PARENT_TYPE_INVALID,\n};\n","// @flow\n\nimport { type Change } from 'slate';\nimport {\n    CHILD_OBJECT_INVALID,\n    CHILD_TYPE_INVALID,\n    PARENT_TYPE_INVALID,\n} from './slate-schema-violations';\nimport { createCell } from '../utils';\nimport type Options from '../options';\n\n/*\n * Returns a schema definition for the plugin\n */\nfunction schema(opts: Options): Object {\n    return {\n        blocks: {\n            [opts.typeTable]: {\n                nodes: [{ match: { type: opts.typeRow } }],\n                parent: [{object: 'document'}],\n                normalize: (editor, {code, node}) => {\n                  if (code === 'parent_object_invalid') {\n                    editor.insertText(node.text);\n                    editor.removeNodeByKey(node.key);\n                  }\n                }\n            },\n            [opts.typeRow]: {\n                nodes: [{ match: { type: opts.typeCell } }],\n                parent: { type: opts.typeTable },\n                normalize(change: Change, error) {\n                    switch (error.code) {\n                        case CHILD_TYPE_INVALID:\n                            return onlyCellsInRow(opts, change, error);\n                        case PARENT_TYPE_INVALID:\n                            return rowOnlyInTable(opts, change, error);\n                    }\n                },\n            },\n            [opts.typeCell]: {\n                nodes: [{ match: { object: 'block' } }],\n                parent: { type: opts.typeRow },\n                normalize(change: Change, error) {\n                    switch (error.code) {\n                        case CHILD_OBJECT_INVALID:\n                            return onlyBlocksInCell(opts, change, error.node);\n                        case PARENT_TYPE_INVALID:\n                            return cellOnlyInRow(opts, change, error);\n                    }\n                },\n            },\n        },\n    };\n}\n\n/*\n * A row's children must be cells.\n * If they're not then we wrap them within a cell.\n */\nfunction onlyCellsInRow(opts: Options, change: Change, error) {\n    const cell = createCell(opts, []);\n    const index = error.node.nodes.findIndex(\n        child => child.key === error.child.key,\n    );\n\n    change.withoutNormalizing(() => {\n        change.insertNodeByKey(error.node.key, index, cell);\n        change.moveNodeByKey(error.child.key, cell.key, 0);\n    });\n}\n\n/*\n * Rows can't live outside a table, if one is found then we wrap it within a table.\n */\nfunction rowOnlyInTable(opts: Options, change: Change, error: Object) {\n    return change.wrapBlockByKey(error.node.key, opts.typeTable);\n}\n\n/*\n * A cell's children must be \"block\"s.\n * If they're not then we wrap them within a block with a type of opts.typeContent\n */\nfunction onlyBlocksInCell(opts: Options, change: Change, node: Object) {\n    change.wrapBlockByKey(node.nodes.first().key, opts.typeContent);\n    const wrapper = change.value.document.getDescendant(node.key).nodes.first();\n\n    // Add in the remaining items\n    node.nodes\n        .rest()\n        .forEach((child, index) =>\n            change.moveNodeByKey(child.key, wrapper.key, index + 1),\n        );\n\n    return change;\n    /*     const block = Block.create({\n        type: opts.typeContent,\n    });\n    change.withoutNormalizing(() => {\n        change.insertNodeByKey(error.node.key, 0, block);\n        const inlines = error.node.nodes.filter(\n            node => node.object !== 'block',\n        );\n        inlines.forEach((inline, index) => {\n            change.moveNodeByKey(inline.key, block.key, index);\n        });\n    }); */\n}\n\n/*\n * Cells can't live outside a row, if one is found then we wrap it within a row.\n */\nfunction cellOnlyInRow(opts: Options, change: Change, error: Object) {\n    return change.wrapBlockByKey(error.node.key, opts.typeRow);\n}\n\nexport default schema;\n","// @flow\n\nimport type Options from '../options';\nimport { createCell } from '../utils';\n\n/*\n * Ensure each row has the same number of columns.\n */\nfunction normalizeNode(opts: Options) {\n    const isRow = node => node.type === opts.typeRow;\n    const countNodes = row => row.nodes.size;\n\n    return (node, editor, next) => {\n        if (node.type !== opts.typeTable) {\n            return next();\n        }\n        const rows = node.nodes.filter(isRow);\n        const maxColumns = Math.max(\n            // Minimum 1 column\n            1,\n            rows.map(countNodes).max(),\n        );\n        const rowsMissingColumns = rows.filter(\n            row => countNodes(row) < maxColumns,\n        );\n\n        if (rowsMissingColumns.isEmpty()) {\n            return next();\n        }\n\n        return change => {\n            change.withoutNormalizing(() => {\n                rowsMissingColumns.forEach(row => {\n                    const numberOfCellsToAdd = maxColumns - row.nodes.size;\n                    const cells = Array.from({\n                        length: numberOfCellsToAdd,\n                    }).map(() => createCell(opts));\n                    cells.forEach(cell =>\n                        change.insertNodeByKey(row.key, row.nodes.size, cell),\n                    );\n                });\n            });\n        };\n    };\n}\n\nexport default normalizeNode;\n","// @flow\nimport {\n    insertTable,\n    insertTableFragmentAtRange,\n    insertRow,\n    removeRow,\n    insertColumn,\n    removeColumn,\n    removeTable,\n    clearCell,\n    moveSelection,\n    moveSelectionBy,\n    moveSelectionOutOfTable,\n    removeRowByKey,\n    removeColumnByKey,\n    removeTableByKey\n} from './changes';\nimport {\n    isSelectionInTable,\n    isSelectionOutOfTable,\n    getPosition,\n    getPositionByKey,\n    createCell,\n    createRow,\n    createTable,\n    forEachCells,\n    getCellsAtRow,\n    getCellsAtColumn,\n    getCopiedFragment\n} from './utils';\nimport { schema, normalizeNode } from './validation';\n\nimport Options, { type OptionsFormat } from './options';\n\n/**\n * Returns the core of the plugin, limited to the validation and normalization\n * part of `slate-edit-table`, and utils.\n *\n * Import this directly: `import EditTable from 'slate-edit-table/lib/core'`\n * if you don't care about behavior/rendering and you\n * are only manipulating `Slate.Values` without rendering them.\n * That way you do not depend on `slate-react`.\n */\nfunction core(optionsParam: Options | OptionsFormat): Object {\n    const opts = new Options(optionsParam);\n\n    return {\n        schema: schema(opts),\n        normalizeNode: normalizeNode(opts),\n\n        queries: {\n            isSelectionInTable: isSelectionInTable.bind(null, opts),\n            isSelectionOutOfTable: isSelectionOutOfTable.bind(null, opts),\n            getPosition: getPosition.bind(null, opts),\n            getPositionByKey: getPositionByKey.bind(null, opts),\n            createCell: createCell.bind(null, opts),\n            createRow: createRow.bind(null, opts),\n            createTable: createTable.bind(null, opts),\n            forEachCells: forEachCells.bind(null, opts),\n            getCellsAtRow: getCellsAtRow.bind(null, opts),\n            getCellsAtColumn: getCellsAtColumn.bind(null, opts),\n            getCopiedFragment: getCopiedFragment.bind(null, opts)\n        },\n\n        commands: {\n            insertTable: insertTable.bind(null, opts),\n            insertTableFragmentAtRange: insertTableFragmentAtRange.bind(\n                null,\n                opts\n            ),\n            clearCell: clearCell.bind(null, opts),\n            removeRowByKey: removeRowByKey.bind(null, opts),\n            removeColumnByKey: removeColumnByKey.bind(null, opts),\n            removeTableByKey: removeTableByKey.bind(null, opts),\n            insertRow: bindAndScopeChange(opts, insertRow),\n            removeRow: bindAndScopeChange(opts, removeRow),\n            insertColumn: bindAndScopeChange(opts, insertColumn),\n            removeColumn: bindAndScopeChange(opts, removeColumn),\n            removeTable: bindAndScopeChange(opts, removeTable),\n            moveSelection: bindAndScopeChange(opts, moveSelection),\n            moveSelectionBy: bindAndScopeChange(opts, moveSelectionBy),\n            moveSelectionOutOfTable: bindAndScopeChange(opts, moveSelectionOutOfTable)\n        }\n    };\n}\n\n/**\n * Bind a change to given options, and scope it to act only inside a table\n */\nfunction bindAndScopeChange(opts: Options, fn: *): * {\n    return (editor, ...args) => {\n        if (!editor.isSelectionInTable()) {\n            return editor;\n        }\n\n        // $FlowFixMe\n        return fn(...[opts, editor].concat(args));\n    };\n}\n\nexport default core;\n","// @flow\nimport {type Change} from 'slate';\n\nimport type Options from '../options';\nimport {TablePosition} from '../utils';\nimport {insertRow} from '../changes';\n\n/**\n * Insert a new row when pressing \"Enter\"\n */\nfunction onEnter(event: *, editor: *, opts: Options, next: *): void | Change {\n  event.preventDefault();\n  const {selection, document} = editor.value;\n  const pos = TablePosition.create(opts, document, selection.start.key);\n  const isAtEdgeOfCell =\n    selection.focus.isAtStartOfNode(pos.cell) ||\n    selection.focus.isAtEndOfNode(pos.cell);\n\n  if (!opts.insertRowOnEnter || !isAtEdgeOfCell) {\n    return next();\n  }\n\n  if (event.shiftKey) {\n    return editor.splitBlock().setBlocks({type: opts.typeContent, data: {}});\n  }\n\n  return insertRow(opts, editor);\n}\n\nexport default onEnter;\n","// @flow\nimport { Block, Text, type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport type Options from '../options';\n\n/**\n * Exit the current table, by inserting a default block after the table.\n */\nfunction onModEnter(\n    event: *,\n    editor: *,\n    opts: Options,\n    next: *\n): void | Change {\n    const { value } = editor;\n    if (!value.selection.isCollapsed) {\n        return next();\n    }\n\n    event.preventDefault();\n\n    const exitBlock = Block.create({\n        type: opts.exitBlockType,\n        nodes: [Text.create('')]\n    });\n\n    const table = TablePosition.create(opts, value.document, value.selection.start.key)\n        .table;\n    const tableParent = value.document.getParent(table.key);\n    const insertionIndex = tableParent.nodes.indexOf(table) + 1;\n\n    return editor\n        .insertNodeByKey(tableParent.key, insertionIndex, exitBlock)\n        .moveToStartOfNode(exitBlock);\n}\n\nexport default onModEnter;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport { moveSelectionBy, insertRow } from '../changes';\nimport type Options from '../options';\n\n/**\n * Select all text of current block.\n */\nfunction selectAllText(editor)  {\n    const { value } = editor;\n    const { startBlock } = value;\n\n    return editor.moveTo(0).moveFocusForward(startBlock.text.length);\n}\n\n/**\n * Pressing \"Tab\" moves the cursor to the next cell\n * and select the whole text\n */\nfunction onTab(\n    event: *,\n    editor: *,\n    opts: Options\n): void | Change {\n    event.preventDefault();\n    const { value } = editor;\n    const direction = event.shiftKey ? -1 : +1;\n\n    // Create new row if needed\n    const { selection } = value;\n    const pos = TablePosition.create(opts, value.document, selection.start.key);\n    if (pos.isFirstCell() && direction === -1) {\n        insertRow(opts, editor, 0);\n    } else if (pos.isLastCell() && direction === 1) {\n        insertRow(opts, editor);\n    }\n\n    // Move back to initial cell (insertRow moves selection automatically).\n    editor.select(selection);\n\n    // Move\n    moveSelectionBy(opts, editor, direction, 0);\n\n    // Select all cell.\n    return selectAllText(editor);\n}\n\nexport default onTab;\n","// @flow\nimport { type Change } from 'slate';\n\nimport type Options from '../options';\nimport { clearCell } from '../changes';\n\nfunction onBackspace(\n    event: *,\n    editor: *,\n    opts: Options,\n    next: *\n): void | Change {\n    const { value } = editor;\n    const { startBlock, selection, endBlock, document} = value;\n    const { isCollapsed } = selection;\n\n    const startCell = document.getClosest(startBlock.key, opts.isCell);\n    const endCell = document.getClosest(endBlock.key, opts.isCell);\n\n    const startPath = startCell.getPath(selection.start.key);\n    // If a cursor is collapsed at the start of the first block, do nothing\n    if (selection.start.offset === 0 && isCollapsed && startPath && startPath.every(index => index === 0)) {\n        if (editor.isVoid(startBlock)) {\n            // Delete the block normally if it is a void block\n            return next();\n        }\n\n        event.preventDefault();\n        return editor;\n    }\n\n    // If \"normal\" deletion, we continue\n    if (startCell === endCell) {\n        return next();\n    }\n\n    // If cursor is between multiple blocks,\n    // we clear the content of the cells.\n    event.preventDefault();\n\n    const { blocks } = value;\n\n    // Get all cells that contains the selection\n    const cells = blocks\n        .map(\n            node =>\n                node.type === opts.typeCell\n                    ? node\n                    : document.getClosest(\n                          node.key,\n                          a => a.type === opts.typeCell\n                      )\n        )\n        .toSet();\n\n    // If the cursor is at the very end of the first cell, ignore it.\n    // If the cursor is at the very start of the last cell, ignore it.\n    // This behavior is to compensate hanging selection behaviors:\n    // https://github.com/ianstormtaylor/slate/pull/1605\n    const ignoreFirstCell = value.selection\n        .moveToStart()\n        .anchor.isAtEndOfNode(cells.first());\n    const ignoreLastCell = value.selection\n        .moveToEnd()\n        .anchor.isAtStartOfNode(cells.last());\n\n    let cellsToClear = cells;\n    if (ignoreFirstCell) {\n        cellsToClear = cellsToClear.rest();\n    }\n    if (ignoreLastCell) {\n        cellsToClear = cellsToClear.butLast();\n    }\n\n    // Clear all the selection\n    cellsToClear.forEach(cell => clearCell(opts, editor, cell));\n\n    // Update the selection properly, and avoid reset of selection\n    const updatedStartCell = editor.value.document.getDescendant(\n        cellsToClear.first().key\n    );\n    return editor.moveToStartOfNode(updatedStartCell);\n}\n\nexport default onBackspace;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { TablePosition } from '../utils';\nimport { moveSelectionBy, moveSelectionOutOfTable } from '../changes';\nimport type Options from '../options';\n\nfunction onUpDown(\n    event: *,\n    editor: *,\n    opts: Options,\n    next: *\n): void | Change {\n    const { value } = editor;\n    const direction = event.key === 'ArrowUp' ? -1 : +1;\n    const pos = TablePosition.create(opts, value.document, value.selection.start.key);\n\n    if (\n        (pos.isFirstRow() && direction === -1 && pos.isTopOfCell()) ||\n        (pos.isLastRow() && direction === +1 && pos.isBottomOfCell())\n    ) {\n      if (opts.edgeRowExitOnDirection) {\n        event.preventDefault();\n        return moveSelectionOutOfTable(opts, editor, direction);\n      } else {\n        // Let the default behavior move out of the table\n        return next();\n      }\n    }\n\n    if (direction === -1 && !pos.isTopOfCell()) {\n        return next();\n    }\n\n    if (direction === +1 && !pos.isBottomOfCell()) {\n        return next();\n    }\n\n    event.preventDefault();\n\n    moveSelectionBy(opts, editor, 0, direction);\n\n    return editor;\n}\n\nexport default onUpDown;\n","// @flow\nimport { type Change } from 'slate';\n\nimport { moveSelectionOutOfTable } from '../changes';\nimport type Options from '../options';\n\nfunction onUpDown(\n    event: *,\n    editor: *,\n    opts: Options,\n): void | Change {\n    const direction = event.key === 'ArrowUp' ? -1 : +1;\n\n    event.preventDefault();\n\n    moveSelectionOutOfTable(opts, editor, direction);\n\n    return editor;\n}\n\nexport default onUpDown;\n","// @flow\n\nimport type Options from '../options';\n\nimport onEnter from './onEnter';\nimport onModEnter from './onModEnter';\nimport onTab from './onTab';\nimport onBackspace from './onBackspace';\nimport onUpDown from './onUpDown';\nimport onModUpDown from './onModUpDown';\n\nconst KEY_ENTER = 'Enter';\nconst KEY_TAB = 'Tab';\nconst KEY_BACKSPACE = 'Backspace';\nconst KEY_DOWN = 'ArrowDown';\nconst KEY_UP = 'ArrowUp';\n\n/**\n * User is pressing a key in the editor\n */\nfunction onKeyDown(\n    opts: Options,\n    event: *,\n    editor: *,\n    next: *\n): void | any {\n    // Only handle events in cells\n    if (!editor.isSelectionInTable()) {\n        return next();\n    }\n\n    // Build arguments list\n    const args = [event, editor, opts, next];\n\n    switch (event.key) {\n        case KEY_ENTER:\n            if (event.metaKey && opts.exitBlockType) {\n                return onModEnter(...args);\n            }\n            return onEnter(...args);\n        case KEY_TAB:\n            return onTab(...args);\n        case KEY_BACKSPACE:\n            return onBackspace(...args);\n        case KEY_DOWN:\n        case KEY_UP:\n          if (event.metaKey) {\n            return onModUpDown(...args);\n          }\n          return onUpDown(...args);\n        default:\n            return next();\n    }\n}\n\nexport default onKeyDown;\n","// @flow\n\nimport type Options from '../options';\nimport {Editor, Value} from 'slate';\nimport getCopiedFragment from '../utils/getCopiedFragment';\nimport {cloneFragment} from 'slate-react';\n\nfunction onCopy(opts: Options, event: *, editor: *, next: *): void | any {\n  if (!editor.isSelectionInTable()) {\n    return next();\n  }\n\n  const fragment = getCopiedFragment(opts, editor.value);\n\n  if (!fragment) return next();\n\n  const tempEditor = new Editor({\n    value: Value.fromJSON({document: fragment}),\n  });\n  tempEditor.moveToRangeOfDocument();\n\n  cloneFragment(event, tempEditor);\n}\n\nexport default onCopy;\n","/* @flow */\nimport Options, { type OptionsFormat } from './options';\nimport type { TablePosition as _TablePosition } from './utils/TablePosition';\nimport core from './core';\nimport { onKeyDown, onCopy} from './handlers';\n\n/**\n *  Returns the full plugin object (behavior + rendering + schema)\n */\nfunction EditTable(\n    // The plugin options\n    optionsParam?: OptionsFormat\n): Object {\n    const opts = new Options(optionsParam || {});\n    const corePlugin = core(opts);\n\n    return {\n        ...corePlugin,\n        onKeyDown: onKeyDown.bind(null, opts),\n        onCopy: onCopy.bind(null, opts),\n    };\n}\n\nexport type TablePosition = _TablePosition;\n\nexport default EditTable;\n"]},"metadata":{},"sourceType":"module"}