{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slate = require('slate');\n\nvar _immutable = require('immutable');\n\nvar _utils = require('../utils');\n/**\n * Wrap the blocks in the current selection in a new list. Selected\n * lists are merged together.\n */\n\n\nfunction wrapInList(opts, change, type, data, itemType) {\n  var selectedBlocks = getHighestSelectedBlocks(change.value);\n  type = type || opts.types[0];\n  change.withoutNormalizing(function () {\n    // Wrap in container\n    change.wrapBlock({\n      type: type,\n      data: _slate.Data.create(data)\n    }); // Wrap in list items\n\n    selectedBlocks.forEach(function (node) {\n      if ((0, _utils.isList)(opts, node)) {\n        // Merge its items with the created list\n        node.nodes.forEach(function (_ref) {\n          var key = _ref.key;\n          return change.unwrapNodeByKey(key);\n        });\n      } else {\n        change.wrapBlockByKey(node.key, itemType || opts.typeItem);\n      }\n    });\n  });\n  return change.normalize();\n}\n/**\n * Returns the highest list of blocks that cover the current selection\n */\n\n\nfunction getHighestSelectedBlocks(value) {\n  var range = value.selection;\n  var document = value.document;\n  var startBlock = document.getClosestBlock(range.start.key);\n  var endBlock = document.getClosestBlock(range.end.key);\n\n  if (startBlock === endBlock) {\n    return (0, _immutable.List)([startBlock]);\n  }\n\n  var ancestor = document.getCommonAncestor(startBlock.key, endBlock.key);\n  var startPath = ancestor.getPath(startBlock.key);\n  var endPath = ancestor.getPath(endBlock.key);\n  return ancestor.nodes.slice(startPath[0], endPath[0] + 1);\n}\n\nexports.default = wrapInList;","map":{"version":3,"sources":["C:/Users/ayomi/source/repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/@tommoor/slate-edit-list/dist/changes/wrapInList.js"],"names":["Object","defineProperty","exports","value","_slate","require","_immutable","_utils","wrapInList","opts","change","type","data","itemType","selectedBlocks","getHighestSelectedBlocks","types","withoutNormalizing","wrapBlock","Data","create","forEach","node","isList","nodes","_ref","key","unwrapNodeByKey","wrapBlockByKey","typeItem","normalize","range","selection","document","startBlock","getClosestBlock","start","endBlock","end","List","ancestor","getCommonAncestor","startPath","getPath","endPath","slice","default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AACzCC,EAAAA,KAAK,EAAE;AADkC,CAA7C;;AAIA,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;;AAEA,IAAIC,UAAU,GAAGD,OAAO,CAAC,WAAD,CAAxB;;AAEA,IAAIE,MAAM,GAAGF,OAAO,CAAC,UAAD,CAApB;AAEA;;;;;;AAIA,SAASG,UAAT,CAAoBC,IAApB,EAA0BC,MAA1B,EAAkCC,IAAlC,EAAwCC,IAAxC,EAA8CC,QAA9C,EAAwD;AACpD,MAAIC,cAAc,GAAGC,wBAAwB,CAACL,MAAM,CAACP,KAAR,CAA7C;AACAQ,EAAAA,IAAI,GAAGA,IAAI,IAAIF,IAAI,CAACO,KAAL,CAAW,CAAX,CAAf;AAEAN,EAAAA,MAAM,CAACO,kBAAP,CAA0B,YAAY;AAClC;AACAP,IAAAA,MAAM,CAACQ,SAAP,CAAiB;AACbP,MAAAA,IAAI,EAAEA,IADO;AAEbC,MAAAA,IAAI,EAAER,MAAM,CAACe,IAAP,CAAYC,MAAZ,CAAmBR,IAAnB;AAFO,KAAjB,EAFkC,CAOlC;;AACAE,IAAAA,cAAc,CAACO,OAAf,CAAuB,UAAUC,IAAV,EAAgB;AACnC,UAAI,CAAC,GAAGf,MAAM,CAACgB,MAAX,EAAmBd,IAAnB,EAAyBa,IAAzB,CAAJ,EAAoC;AAChC;AACAA,QAAAA,IAAI,CAACE,KAAL,CAAWH,OAAX,CAAmB,UAAUI,IAAV,EAAgB;AAC/B,cAAIC,GAAG,GAAGD,IAAI,CAACC,GAAf;AACA,iBAAOhB,MAAM,CAACiB,eAAP,CAAuBD,GAAvB,CAAP;AACH,SAHD;AAIH,OAND,MAMO;AACHhB,QAAAA,MAAM,CAACkB,cAAP,CAAsBN,IAAI,CAACI,GAA3B,EAAgCb,QAAQ,IAAIJ,IAAI,CAACoB,QAAjD;AACH;AACJ,KAVD;AAWH,GAnBD;AAqBA,SAAOnB,MAAM,CAACoB,SAAP,EAAP;AACH;AAED;;;;;AAIA,SAASf,wBAAT,CAAkCZ,KAAlC,EAAyC;AACrC,MAAI4B,KAAK,GAAG5B,KAAK,CAAC6B,SAAlB;AACA,MAAIC,QAAQ,GAAG9B,KAAK,CAAC8B,QAArB;AAGA,MAAIC,UAAU,GAAGD,QAAQ,CAACE,eAAT,CAAyBJ,KAAK,CAACK,KAAN,CAAYV,GAArC,CAAjB;AACA,MAAIW,QAAQ,GAAGJ,QAAQ,CAACE,eAAT,CAAyBJ,KAAK,CAACO,GAAN,CAAUZ,GAAnC,CAAf;;AAEA,MAAIQ,UAAU,KAAKG,QAAnB,EAA6B;AACzB,WAAO,CAAC,GAAG/B,UAAU,CAACiC,IAAf,EAAqB,CAACL,UAAD,CAArB,CAAP;AACH;;AACD,MAAIM,QAAQ,GAAGP,QAAQ,CAACQ,iBAAT,CAA2BP,UAAU,CAACR,GAAtC,EAA2CW,QAAQ,CAACX,GAApD,CAAf;AACA,MAAIgB,SAAS,GAAGF,QAAQ,CAACG,OAAT,CAAiBT,UAAU,CAACR,GAA5B,CAAhB;AACA,MAAIkB,OAAO,GAAGJ,QAAQ,CAACG,OAAT,CAAiBN,QAAQ,CAACX,GAA1B,CAAd;AAEA,SAAOc,QAAQ,CAAChB,KAAT,CAAeqB,KAAf,CAAqBH,SAAS,CAAC,CAAD,CAA9B,EAAmCE,OAAO,CAAC,CAAD,CAAP,GAAa,CAAhD,CAAP;AACH;;AAED1C,OAAO,CAAC4C,OAAR,GAAkBtC,UAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slate = require('slate');\n\nvar _immutable = require('immutable');\n\nvar _utils = require('../utils');\n\n/**\n * Wrap the blocks in the current selection in a new list. Selected\n * lists are merged together.\n */\nfunction wrapInList(opts, change, type, data, itemType) {\n    var selectedBlocks = getHighestSelectedBlocks(change.value);\n    type = type || opts.types[0];\n\n    change.withoutNormalizing(function () {\n        // Wrap in container\n        change.wrapBlock({\n            type: type,\n            data: _slate.Data.create(data)\n        });\n\n        // Wrap in list items\n        selectedBlocks.forEach(function (node) {\n            if ((0, _utils.isList)(opts, node)) {\n                // Merge its items with the created list\n                node.nodes.forEach(function (_ref) {\n                    var key = _ref.key;\n                    return change.unwrapNodeByKey(key);\n                });\n            } else {\n                change.wrapBlockByKey(node.key, itemType || opts.typeItem);\n            }\n        });\n    });\n\n    return change.normalize();\n}\n\n/**\n * Returns the highest list of blocks that cover the current selection\n */\n\nfunction getHighestSelectedBlocks(value) {\n    var range = value.selection;\n    var document = value.document;\n\n\n    var startBlock = document.getClosestBlock(range.start.key);\n    var endBlock = document.getClosestBlock(range.end.key);\n\n    if (startBlock === endBlock) {\n        return (0, _immutable.List)([startBlock]);\n    }\n    var ancestor = document.getCommonAncestor(startBlock.key, endBlock.key);\n    var startPath = ancestor.getPath(startBlock.key);\n    var endPath = ancestor.getPath(endBlock.key);\n\n    return ancestor.nodes.slice(startPath[0], endPath[0] + 1);\n}\n\nexports.default = wrapInList;"]},"metadata":{},"sourceType":"script"}