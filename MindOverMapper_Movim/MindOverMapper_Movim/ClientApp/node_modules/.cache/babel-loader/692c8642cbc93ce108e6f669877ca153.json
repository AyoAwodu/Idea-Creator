{"ast":null,"code":"import isDataUri from 'is-data-uri';\nimport Promise from 'es6-promise';\nimport isImage from 'is-image';\nimport isUrl from 'is-url';\nimport logger from 'slate-dev-logger';\nimport { getEventTransfer, getEventRange } from 'slate-react';\n/**\n * Return a `Blob` for the given data `uri`.\n *\n * Copied from: https://github.com/component/data-uri-to-blob/blob/master/index.js\n *\n * @param {String} uri\n * @return {Blob}\n */\n\nfunction dataUriToBlob(uri) {\n  var data = uri.split(',')[1];\n  var bytes = atob(data);\n  var buffer = new window.ArrayBuffer(bytes.length);\n  var array = new window.Uint8Array(buffer);\n\n  for (var i = 0; i < bytes.length; i++) {\n    array[i] = bytes.charCodeAt(i);\n  }\n\n  if (!hasArrayBufferView()) {\n    array = buffer;\n  }\n\n  var blob = new Blob([array], {\n    type: mime(uri)\n  }); // COMPAT: ???\n\n  blob.slice = blob.slice || blob.webkitSlice;\n  return blob;\n}\n/**\n * Return the mime type of a data `uri`.\n *\n * @param {String} uri\n * @return {String}\n */\n\n\nfunction mime(uri) {\n  return uri.split('')[0].slice(5);\n}\n/**\n * Check if the environment suppoers `ArrayBufferView`.\n *\n * @return {Boolean}\n */\n\n\nfunction hasArrayBufferView() {\n  return new Blob([new window.Uint8Array(100)]).size == 100;\n}\n/**\n * Convert an <img> source `url` to a data URI and `callback(err, uri)`.\n *\n * @param {String} url\n * @param {Function} callback\n */\n\n\nfunction srcToDataUri(url, callback) {\n  var canvas = window.document.createElement('canvas');\n  var img = window.document.createElement('img');\n\n  if (!canvas.getContext) {\n    return setTimeout(callback, 0, new Error('Canvas is not supported.'));\n  }\n\n  img.onload = function () {\n    var ctx = canvas.getContext('2d');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n    var dataUri = canvas.toDataURL('image/png');\n    callback(null, dataUri);\n  };\n\n  img.ononerror = function () {\n    callback(new Error('Failed to load image.'));\n  };\n\n  img.setAttribute('crossOrigin', 'anonymous');\n  img.src = url;\n}\n/**\n * Load an image file from a src `url`.\n *\n * @param {String} url\n * @param {Function} callback\n */\n\n\nfunction loadImageFile(url, callback) {\n  if (isDataUri(url)) {\n    var file = dataUriToBlob(url);\n    setTimeout(function () {\n      callback(null, file);\n    });\n  } else {\n    srcToDataUri(url, function (err, uri) {\n      var file = dataUriToBlob(uri);\n      callback(err, file);\n    });\n  }\n} // Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\n\n\nvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\nvar splitPath = function (filename) {\n  return splitPathRe.exec(filename).slice(1);\n}; // path.resolve([from ...], to)\n// posix version\n// path.normalize(path)\n// posix version\n// posix version\n// posix version\n// path.relative(from, to)\n// posix version\n\n\nfunction extname(path) {\n  return splitPath(path)[3];\n} // String.prototype.substr - negative index don't work in IE8\n\n\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n/**\n * Insert images on drop or paste.\n *\n * @param {Object} options\n *   @property {Function} insertImage\n *   @property {Array} extensions (optional)\n * @return {Object} plugin\n */\n\n\nfunction DropOrPasteImages() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var insertImage = options.insertImage,\n      extensions = options.extensions;\n\n  if (options.applyTransform) {\n    logger.deprecate('0.6.0', 'The `applyTransform` argument to `slate-drop-or-paste-images` has been renamed to `insertImage` instead.');\n    insertImage = options.applyTransform;\n  }\n\n  if (!insertImage) {\n    throw new Error('You must supply an `insertImage` function.');\n  }\n  /**\n   * Check file extension against user-defined options.\n   *\n   * @param {Type} string\n   * @return {Boolean}\n   */\n\n\n  function matchExt(type) {\n    var accepted = false;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var ext = _step.value;\n        if (type.includes(ext)) accepted = true;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return accepted;\n  }\n  /**\n   * Apply the change for a given file and update the editor with the result.\n   *\n   * @param {Change} change\n   * @param {Blob} file\n   * @return {Promise}\n   */\n\n\n  function asyncApplyChange(change, file) {\n    var editor = change.editor;\n    return Promise.resolve(insertImage(change, file)).then(function () {\n      editor.onChange(change);\n    });\n  }\n  /**\n   * On drop or paste.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @return {State}\n   */\n\n\n  function onInsert(event, change, next) {\n    var editor = change.editor;\n    var transfer = getEventTransfer(event);\n    var range = getEventRange(event, editor);\n\n    switch (transfer.type) {\n      case 'files':\n        return onInsertFiles(event, change, next, transfer, range);\n\n      case 'html':\n        return onInsertHtml(event, change, next, transfer, range);\n\n      case 'text':\n        return onInsertText(event, change, next, transfer, range);\n\n      default:\n        return next();\n    }\n  }\n  /**\n   * On drop or paste files.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @param {Object} transfer\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n\n  function onInsertFiles(event, change, next, transfer, range) {\n    var files = transfer.files;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var file = _step2.value;\n\n        if (extensions) {\n          var type = file.type;\n\n          var _type$split = type.split('/'),\n              _type$split2 = _slicedToArray(_type$split, 2),\n              ext = _type$split2[1];\n\n          if (!matchExt(ext)) continue;\n        }\n\n        if (range) {\n          change.select(range);\n        }\n\n        asyncApplyChange(change, file);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n  /**\n   * On drop or paste html.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @param {Object} transfer\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n\n  function onInsertHtml(event, change, next, transfer, range) {\n    var editor = change.editor;\n    var html = transfer.html;\n    var parser = new DOMParser();\n    var doc = parser.parseFromString(html, 'text/html');\n    var body = doc.body;\n    var firstChild = body.firstChild;\n    if (firstChild.nodeName.toLowerCase() != 'img') return next();\n    var src = firstChild.src;\n\n    if (extensions) {\n      var ext = extname(src).slice(1);\n      if (!matchExt(ext)) return next();\n    }\n\n    loadImageFile(src, function (err, file) {\n      if (err) return;\n      editor.change(function (c) {\n        if (range) {\n          c.select(range);\n        }\n\n        asyncApplyChange(c, file);\n      });\n    });\n  }\n  /**\n   * On drop or paste text.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @param {Object} transfer\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n\n  function onInsertText(event, change, next, transfer, range) {\n    var editor = change.editor;\n    var text = transfer.text;\n    if (!isUrl(text)) return next();\n    if (!isImage(text)) return next();\n    loadImageFile(text, function (err, file) {\n      if (err) return;\n      editor.change(function (c) {\n        if (range) {\n          c.select(range);\n        }\n\n        asyncApplyChange(c, editor, file);\n      });\n    });\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onDrop: onInsert,\n    onPaste: onInsert\n  };\n}\n\nexport default DropOrPasteImages;","map":{"version":3,"sources":["../src/data-uri-to-blob.js","../src/image-to-data-uri.js","../src/load-image-file.js","../../../node_modules/rollup-plugin-node-builtins/src/es6/path.js","../src/index.js"],"names":["data","uri","bytes","atob","buffer","window","array","i","hasArrayBufferView","blob","type","mime","canvas","img","setTimeout","ctx","dataUri","isDataUri","file","dataUriToBlob","options","insertImage","extensions","accepted","ext","editor","change","transfer","getEventTransfer","range","getEventRange","onInsertFiles","onInsertHtml","onInsertText","next","files","matchExt","html","parser","doc","body","firstChild","src","extname","text","isUrl","isImage","onInsert"],"mappings":"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","sourcesContent":["/**\n * Return a `Blob` for the given data `uri`.\n *\n * Copied from: https://github.com/component/data-uri-to-blob/blob/master/index.js\n *\n * @param {String} uri\n * @return {Blob}\n */\n\nfunction dataUriToBlob(uri) {\n  const data = uri.split(',')[1]\n  const bytes = atob(data)\n  const buffer = new window.ArrayBuffer(bytes.length)\n  let array = new window.Uint8Array(buffer)\n\n  for (let i = 0; i < bytes.length; i++) {\n    array[i] = bytes.charCodeAt(i)\n  }\n\n  if (!hasArrayBufferView()) {\n    array = buffer\n  }\n\n  const blob = new Blob([array], { type: mime(uri) })\n\n  // COMPAT: ???\n  blob.slice = blob.slice || blob.webkitSlice\n\n  return blob\n}\n\n/**\n * Return the mime type of a data `uri`.\n *\n * @param {String} uri\n * @return {String}\n */\n\nfunction mime(uri) {\n  return uri.split('')[0].slice(5)\n}\n\n/**\n * Check if the environment suppoers `ArrayBufferView`.\n *\n * @return {Boolean}\n */\n\nfunction hasArrayBufferView() {\n  return new Blob([new window.Uint8Array(100)]).size == 100\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default dataUriToBlob\n","/**\n * Convert an <img> source `url` to a data URI and `callback(err, uri)`.\n *\n * @param {String} url\n * @param {Function} callback\n */\n\nfunction srcToDataUri(url, callback) {\n  const canvas = window.document.createElement('canvas')\n  const img = window.document.createElement('img')\n\n  if (!canvas.getContext) {\n    return setTimeout(callback, 0, new Error('Canvas is not supported.'))\n  }\n\n  img.onload = () => {\n    const ctx = canvas.getContext('2d')\n    canvas.width = img.width\n    canvas.height = img.height\n    ctx.drawImage(img, 0, 0)\n    const dataUri = canvas.toDataURL('image/png')\n    callback(null, dataUri)\n  }\n\n  img.ononerror = () => {\n    callback(new Error('Failed to load image.'))\n  }\n\n  img.setAttribute('crossOrigin', 'anonymous')\n  img.src = url\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default srcToDataUri\n","import dataUriToBlob from './data-uri-to-blob'\nimport isDataUri from 'is-data-uri'\nimport imageToDataUri from './image-to-data-uri'\n\n/**\n * Load an image file from a src `url`.\n *\n * @param {String} url\n * @param {Function} callback\n */\n\nfunction loadImageFile(url, callback) {\n  if (isDataUri(url)) {\n    const file = dataUriToBlob(url)\n    setTimeout(() => {\n      callback(null, file)\n    })\n  } else {\n    imageToDataUri(url, (err, uri) => {\n      const file = dataUriToBlob(uri)\n      callback(err, file)\n    })\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default loadImageFile\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexport function resolve() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : '/';\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexport function normalize(path) {\n  var isPathAbsolute = isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isPathAbsolute).join('/');\n\n  if (!path && !isPathAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isPathAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexport function isAbsolute(path) {\n  return path.charAt(0) === '/';\n}\n\n// posix version\nexport function join() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n}\n\n\n// path.relative(from, to)\n// posix version\nexport function relative(from, to) {\n  from = resolve(from).substr(1);\n  to = resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\nexport var sep = '/';\nexport var delimiter = ':';\n\nexport function dirname(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\nexport function basename(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n}\n\n\nexport function extname(path) {\n  return splitPath(path)[3];\n}\nexport default {\n  extname: extname,\n  basename: basename,\n  dirname: dirname,\n  sep: sep,\n  delimiter: delimiter,\n  relative: relative,\n  join: join,\n  isAbsolute: isAbsolute,\n  normalize: normalize,\n  resolve: resolve\n};\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b' ?\n    function (str, start, len) { return str.substr(start, len) } :\n    function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","import Promise from 'es6-promise'\nimport isImage from 'is-image'\nimport isUrl from 'is-url'\nimport logger from 'slate-dev-logger'\nimport loadImageFile from './load-image-file'\nimport { extname } from 'path'\nimport { getEventTransfer, getEventRange } from 'slate-react'\n\n/**\n * Insert images on drop or paste.\n *\n * @param {Object} options\n *   @property {Function} insertImage\n *   @property {Array} extensions (optional)\n * @return {Object} plugin\n */\n\nfunction DropOrPasteImages(options = {}) {\n  let { insertImage, extensions } = options\n\n  if (options.applyTransform) {\n    logger.deprecate(\n      '0.6.0',\n      'The `applyTransform` argument to `slate-drop-or-paste-images` has been renamed to `insertImage` instead.'\n    )\n    insertImage = options.applyTransform\n  }\n\n  if (!insertImage) {\n    throw new Error('You must supply an `insertImage` function.')\n  }\n\n  /**\n   * Check file extension against user-defined options.\n   *\n   * @param {Type} string\n   * @return {Boolean}\n   */\n\n  function matchExt(type) {\n    let accepted = false\n\n    for (const ext of extensions) {\n      if (type.includes(ext)) accepted = true\n    }\n\n    return accepted\n  }\n\n  /**\n   * Apply the change for a given file and update the editor with the result.\n   *\n   * @param {Change} change\n   * @param {Blob} file\n   * @return {Promise}\n   */\n\n  function asyncApplyChange(change, file) {\n    const { editor } = change\n\n    return Promise.resolve(insertImage(change, file)).then(() => {\n      editor.onChange(change)\n    })\n  }\n\n  /**\n   * On drop or paste.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @return {State}\n   */\n\n  function onInsert(event, change, next) {\n    const { editor } = change\n    const transfer = getEventTransfer(event)\n    const range = getEventRange(event, editor)\n\n    switch (transfer.type) {\n      case 'files':\n        return onInsertFiles(event, change, next, transfer, range)\n      case 'html':\n        return onInsertHtml(event, change, next, transfer, range)\n      case 'text':\n        return onInsertText(event, change, next, transfer, range)\n      default:\n        return next()\n    }\n  }\n\n  /**\n   * On drop or paste files.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @param {Object} transfer\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n  function onInsertFiles(event, change, next, transfer, range) {\n    const { files } = transfer\n\n    for (const file of files) {\n      if (extensions) {\n        const type = file.type\n        const [, ext] = type.split('/')\n        if (!matchExt(ext)) continue\n      }\n\n      if (range) {\n        change.select(range)\n      }\n\n      asyncApplyChange(change, file)\n    }\n  }\n\n  /**\n   * On drop or paste html.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @param {Object} transfer\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n  function onInsertHtml(event, change, next, transfer, range) {\n    const { editor } = change\n    const { html } = transfer\n    const parser = new DOMParser()\n    const doc = parser.parseFromString(html, 'text/html')\n    const body = doc.body\n    const firstChild = body.firstChild\n    if (firstChild.nodeName.toLowerCase() != 'img') return next()\n\n    const src = firstChild.src\n\n    if (extensions) {\n      const ext = extname(src).slice(1)\n      if (!matchExt(ext)) return next()\n    }\n\n    loadImageFile(src, (err, file) => {\n      if (err) return\n\n      editor.change(c => {\n        if (range) {\n          c.select(range)\n        }\n\n        asyncApplyChange(c, file)\n      })\n    })\n  }\n\n  /**\n   * On drop or paste text.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Function} next\n   * @param {Object} transfer\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n  function onInsertText(event, change, next, transfer, range) {\n    const { editor } = change\n    const { text } = transfer\n    if (!isUrl(text)) return next()\n    if (!isImage(text)) return next()\n\n    loadImageFile(text, (err, file) => {\n      if (err) return\n\n      editor.change(c => {\n        if (range) {\n          c.select(range)\n        }\n\n        asyncApplyChange(c, editor, file)\n      })\n    })\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onDrop: onInsert,\n    onPaste: onInsert,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DropOrPasteImages\n"]},"metadata":{},"sourceType":"module"}