{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _prismjs = require('prismjs');\n\nvar _prismjs2 = _interopRequireDefault(_prismjs);\n\nrequire('slate');\n\nvar _options = require('./options');\n\nvar _options2 = _interopRequireDefault(_options);\n\nvar _TOKEN_MARK = require('./TOKEN_MARK');\n\nvar _TOKEN_MARK2 = _interopRequireDefault(_TOKEN_MARK);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A Slate plugin to highlight code syntax.\n */\n\n\nfunction PrismPlugin() {\n  var optsParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var opts = new _options2.default(optsParam);\n  return {\n    decorateNode: function decorateNode(node) {\n      if (!opts.onlyIn(node)) {\n        return undefined;\n      }\n\n      return _decorateNode(opts, node);\n    },\n    renderMark: opts.renderMark,\n    TOKEN_MARK: _TOKEN_MARK2.default\n  };\n}\n/**\n * Returns the decoration for a node\n */\n\n\nfunction _decorateNode(opts, block) {\n  var grammarName = opts.getSyntax(block);\n  var grammar = _prismjs2.default.languages[grammarName];\n\n  if (!grammar) {\n    // Grammar not loaded\n    return [];\n  } // Tokenize the whole block text\n\n\n  var texts = block.getTexts();\n  var blockText = texts.map(function (t) {\n    return t.text;\n  }).join('\\n');\n\n  var tokens = _prismjs2.default.tokenize(blockText, grammar); // The list of decorations to return\n\n\n  var decorations = [];\n  var textStart = 0;\n  var textEnd = 0;\n  texts.forEach(function (text) {\n    textEnd = textStart + text.text.length;\n    var offset = 0;\n\n    function processToken(token, accu) {\n      accu = accu || '';\n\n      if (typeof token === 'string') {\n        if (accu) {\n          var decoration = createDecoration({\n            text: text,\n            textStart: textStart,\n            textEnd: textEnd,\n            start: offset,\n            end: offset + token.length,\n            className: 'prism-token token ' + accu\n          });\n\n          if (decoration) {\n            decorations.push(decoration);\n          }\n        }\n\n        offset += token.length;\n      } else {\n        accu = accu + ' ' + token.type + ' ' + (token.alias || '');\n\n        if (typeof token.content === 'string') {\n          var _decoration = createDecoration({\n            text: text,\n            textStart: textStart,\n            textEnd: textEnd,\n            start: offset,\n            end: offset + token.content.length,\n            className: 'prism-token token ' + accu\n          });\n\n          if (_decoration) {\n            decorations.push(_decoration);\n          }\n\n          offset += token.content.length;\n        } else {\n          // When using token.content instead of token.matchedStr, token can be deep\n          for (var i = 0; i < token.content.length; i += 1) {\n            processToken(token.content[i], accu);\n          }\n        }\n      }\n    }\n\n    tokens.forEach(processToken);\n    textStart = textEnd + 1; // account for added `\\n`\n  });\n  return decorations;\n}\n/**\n * Return a decoration range for the given text.\n */\n\n\nfunction createDecoration(_ref) {\n  var text = _ref.text,\n      textStart = _ref.textStart,\n      textEnd = _ref.textEnd,\n      start = _ref.start,\n      end = _ref.end,\n      className = _ref.className;\n\n  if (start >= textEnd || end <= textStart) {\n    // Ignore, the token is not in the text\n    return null;\n  } // Shrink to this text boundaries\n\n\n  start = Math.max(start, textStart);\n  end = Math.min(end, textEnd); // Now shift offsets to be relative to this text\n\n  start -= textStart;\n  end -= textStart;\n  return {\n    anchor: {\n      key: text.key,\n      offset: start\n    },\n    focus: {\n      key: text.key,\n      offset: end\n    },\n    mark: {\n      type: 'prism-token',\n      data: {\n        className: className\n      }\n    }\n  };\n}\n\nexports.default = PrismPlugin;","map":{"version":3,"sources":["C:/Users/ayomi/source/repos/Idea-Creator/Idea-Creator/MindOverMapper_Movim/MindOverMapper_Movim/ClientApp/node_modules/golery-slate-prism/dist/index.js"],"names":["Object","defineProperty","exports","value","_prismjs","require","_prismjs2","_interopRequireDefault","_options","_options2","_TOKEN_MARK","_TOKEN_MARK2","obj","__esModule","default","PrismPlugin","optsParam","arguments","length","undefined","opts","decorateNode","node","onlyIn","_decorateNode","renderMark","TOKEN_MARK","block","grammarName","getSyntax","grammar","languages","texts","getTexts","blockText","map","t","text","join","tokens","tokenize","decorations","textStart","textEnd","forEach","offset","processToken","token","accu","decoration","createDecoration","start","end","className","push","type","alias","content","_decoration","i","_ref","Math","max","min","anchor","key","focus","mark","data"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _prismjs = require('prismjs');\n\nvar _prismjs2 = _interopRequireDefault(_prismjs);\n\nrequire('slate');\n\nvar _options = require('./options');\n\nvar _options2 = _interopRequireDefault(_options);\n\nvar _TOKEN_MARK = require('./TOKEN_MARK');\n\nvar _TOKEN_MARK2 = _interopRequireDefault(_TOKEN_MARK);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * A Slate plugin to highlight code syntax.\n */\nfunction PrismPlugin() {\n    var optsParam = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var opts = new _options2.default(optsParam);\n\n    return {\n        decorateNode: function decorateNode(node) {\n            if (!opts.onlyIn(node)) {\n                return undefined;\n            }\n            return _decorateNode(opts, node);\n        },\n\n        renderMark: opts.renderMark,\n\n        TOKEN_MARK: _TOKEN_MARK2.default\n    };\n}\n\n/**\n * Returns the decoration for a node\n */\nfunction _decorateNode(opts, block) {\n    var grammarName = opts.getSyntax(block);\n    var grammar = _prismjs2.default.languages[grammarName];\n    if (!grammar) {\n        // Grammar not loaded\n        return [];\n    }\n\n    // Tokenize the whole block text\n    var texts = block.getTexts();\n    var blockText = texts.map(function (t) {\n        return t.text;\n    }).join('\\n');\n    var tokens = _prismjs2.default.tokenize(blockText, grammar);\n\n    // The list of decorations to return\n    var decorations = [];\n    var textStart = 0;\n    var textEnd = 0;\n\n    texts.forEach(function (text) {\n        textEnd = textStart + text.text.length;\n\n        var offset = 0;\n\n        function processToken(token, accu) {\n            accu = accu || '';\n\n            if (typeof token === 'string') {\n                if (accu) {\n                    var decoration = createDecoration({\n                        text: text,\n                        textStart: textStart,\n                        textEnd: textEnd,\n                        start: offset,\n                        end: offset + token.length,\n                        className: 'prism-token token ' + accu\n                    });\n                    if (decoration) {\n                        decorations.push(decoration);\n                    }\n                }\n                offset += token.length;\n            } else {\n                accu = accu + ' ' + token.type + ' ' + (token.alias || '');\n\n                if (typeof token.content === 'string') {\n                    var _decoration = createDecoration({\n                        text: text,\n                        textStart: textStart,\n                        textEnd: textEnd,\n                        start: offset,\n                        end: offset + token.content.length,\n                        className: 'prism-token token ' + accu\n                    });\n                    if (_decoration) {\n                        decorations.push(_decoration);\n                    }\n\n                    offset += token.content.length;\n                } else {\n                    // When using token.content instead of token.matchedStr, token can be deep\n                    for (var i = 0; i < token.content.length; i += 1) {\n                        processToken(token.content[i], accu);\n                    }\n                }\n            }\n        }\n\n        tokens.forEach(processToken);\n        textStart = textEnd + 1; // account for added `\\n`\n    });\n\n    return decorations;\n}\n\n/**\n * Return a decoration range for the given text.\n */\nfunction createDecoration(_ref) {\n    var text = _ref.text,\n        textStart = _ref.textStart,\n        textEnd = _ref.textEnd,\n        start = _ref.start,\n        end = _ref.end,\n        className = _ref.className;\n\n    if (start >= textEnd || end <= textStart) {\n        // Ignore, the token is not in the text\n        return null;\n    }\n\n    // Shrink to this text boundaries\n    start = Math.max(start, textStart);\n    end = Math.min(end, textEnd);\n\n    // Now shift offsets to be relative to this text\n    start -= textStart;\n    end -= textStart;\n\n    return {\n        anchor: {\n            key: text.key,\n            offset: start\n        },\n        focus: {\n            key: text.key,\n            offset: end\n        },\n        mark: { type: 'prism-token', data: { className: className } }\n    };\n}\n\nexports.default = PrismPlugin;"]},"metadata":{},"sourceType":"script"}